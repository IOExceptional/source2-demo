// This file is @generated by prost-build.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDemoFileHeader {
    #[prost(string, required, tag = "1")]
    pub demo_file_stamp: ::prost::alloc::string::String,
    #[prost(int32, optional, tag = "2")]
    pub network_protocol: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "3")]
    pub server_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "4")]
    pub client_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "5")]
    pub map_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "6")]
    pub game_directory: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "7")]
    pub fullpackets_version: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "8")]
    pub allow_clientside_entities: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "9")]
    pub allow_clientside_particles: ::core::option::Option<bool>,
    #[prost(string, optional, tag = "10")]
    pub addons: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "11")]
    pub demo_version_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "12")]
    pub demo_version_guid: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "13")]
    pub build_num: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "14")]
    pub game: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "15")]
    pub server_start_tick: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CGameInfo {
    #[prost(message, optional, tag = "4")]
    pub dota: ::core::option::Option<c_game_info::CDotaGameInfo>,
    #[prost(message, optional, tag = "5")]
    pub cs: ::core::option::Option<c_game_info::CcsGameInfo>,
}
/// Nested message and enum types in `CGameInfo`.
pub mod c_game_info {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CDotaGameInfo {
        #[prost(uint64, optional, tag = "1")]
        pub match_id: ::core::option::Option<u64>,
        #[prost(int32, optional, tag = "2")]
        pub game_mode: ::core::option::Option<i32>,
        #[prost(int32, optional, tag = "3")]
        pub game_winner: ::core::option::Option<i32>,
        #[prost(message, repeated, tag = "4")]
        pub player_info: ::prost::alloc::vec::Vec<c_dota_game_info::CPlayerInfo>,
        #[prost(uint32, optional, tag = "5")]
        pub leagueid: ::core::option::Option<u32>,
        #[prost(message, repeated, tag = "6")]
        pub picks_bans: ::prost::alloc::vec::Vec<c_dota_game_info::CHeroSelectEvent>,
        #[prost(uint32, optional, tag = "7")]
        pub radiant_team_id: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "8")]
        pub dire_team_id: ::core::option::Option<u32>,
        #[prost(string, optional, tag = "9")]
        pub radiant_team_tag: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag = "10")]
        pub dire_team_tag: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(uint32, optional, tag = "11")]
        pub end_time: ::core::option::Option<u32>,
    }
    /// Nested message and enum types in `CDotaGameInfo`.
    pub mod c_dota_game_info {
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct CPlayerInfo {
            #[prost(string, optional, tag = "1")]
            pub hero_name: ::core::option::Option<::prost::alloc::string::String>,
            #[prost(string, optional, tag = "2")]
            pub player_name: ::core::option::Option<::prost::alloc::string::String>,
            #[prost(bool, optional, tag = "3")]
            pub is_fake_client: ::core::option::Option<bool>,
            #[prost(uint64, optional, tag = "4")]
            pub steamid: ::core::option::Option<u64>,
            #[prost(int32, optional, tag = "5")]
            pub game_team: ::core::option::Option<i32>,
        }
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct CHeroSelectEvent {
            #[prost(bool, optional, tag = "1")]
            pub is_pick: ::core::option::Option<bool>,
            #[prost(uint32, optional, tag = "2")]
            pub team: ::core::option::Option<u32>,
            #[prost(int32, optional, tag = "3")]
            pub hero_id: ::core::option::Option<i32>,
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CcsGameInfo {
        #[prost(int32, repeated, packed = "false", tag = "1")]
        pub round_start_ticks: ::prost::alloc::vec::Vec<i32>,
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDemoFileInfo {
    #[prost(float, optional, tag = "1")]
    pub playback_time: ::core::option::Option<f32>,
    #[prost(int32, optional, tag = "2")]
    pub playback_ticks: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub playback_frames: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "4")]
    pub game_info: ::core::option::Option<CGameInfo>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDemoPacket {
    #[prost(bytes = "vec", optional, tag = "3")]
    pub data: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDemoFullPacket {
    #[prost(message, optional, tag = "1")]
    pub string_table: ::core::option::Option<CDemoStringTables>,
    #[prost(message, optional, tag = "2")]
    pub packet: ::core::option::Option<CDemoPacket>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDemoSaveGame {
    #[prost(bytes = "vec", optional, tag = "1")]
    pub data: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(fixed64, optional, tag = "2")]
    pub steam_id: ::core::option::Option<u64>,
    #[prost(fixed64, optional, tag = "3")]
    pub signature: ::core::option::Option<u64>,
    #[prost(int32, optional, tag = "4")]
    pub version: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CDemoSyncTick {}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDemoConsoleCmd {
    #[prost(string, optional, tag = "1")]
    pub cmdstring: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDemoSendTables {
    #[prost(bytes = "vec", optional, tag = "1")]
    pub data: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDemoClassInfo {
    #[prost(message, repeated, tag = "1")]
    pub classes: ::prost::alloc::vec::Vec<c_demo_class_info::ClassT>,
}
/// Nested message and enum types in `CDemoClassInfo`.
pub mod c_demo_class_info {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ClassT {
        #[prost(int32, optional, tag = "1")]
        pub class_id: ::core::option::Option<i32>,
        #[prost(string, optional, tag = "2")]
        pub network_name: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag = "3")]
        pub table_name: ::core::option::Option<::prost::alloc::string::String>,
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDemoCustomData {
    #[prost(int32, optional, tag = "1")]
    pub callback_index: ::core::option::Option<i32>,
    #[prost(bytes = "vec", optional, tag = "2")]
    pub data: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDemoCustomDataCallbacks {
    #[prost(string, repeated, tag = "1")]
    pub save_id: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDemoAnimationHeader {
    #[prost(sint32, optional, tag = "1")]
    pub entity_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub tick: ::core::option::Option<i32>,
    #[prost(bytes = "vec", optional, tag = "3")]
    pub data: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDemoAnimationData {
    #[prost(sint32, optional, tag = "1")]
    pub entity_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub start_tick: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub end_tick: ::core::option::Option<i32>,
    #[prost(bytes = "vec", optional, tag = "4")]
    pub data: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(int64, optional, tag = "5")]
    pub data_checksum: ::core::option::Option<i64>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDemoStringTables {
    #[prost(message, repeated, tag = "1")]
    pub tables: ::prost::alloc::vec::Vec<c_demo_string_tables::TableT>,
}
/// Nested message and enum types in `CDemoStringTables`.
pub mod c_demo_string_tables {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ItemsT {
        #[prost(string, optional, tag = "1")]
        pub str: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(bytes = "vec", optional, tag = "2")]
        pub data: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TableT {
        #[prost(string, optional, tag = "1")]
        pub table_name: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(message, repeated, tag = "2")]
        pub items: ::prost::alloc::vec::Vec<ItemsT>,
        #[prost(message, repeated, tag = "3")]
        pub items_clientside: ::prost::alloc::vec::Vec<ItemsT>,
        #[prost(int32, optional, tag = "4")]
        pub table_flags: ::core::option::Option<i32>,
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CDemoStop {}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDemoUserCmd {
    #[prost(int32, optional, tag = "1")]
    pub cmd_number: ::core::option::Option<i32>,
    #[prost(bytes = "vec", optional, tag = "2")]
    pub data: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDemoSpawnGroups {
    #[prost(bytes = "vec", repeated, tag = "3")]
    pub msgs: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum EDemoCommands {
    DemError = -1,
    DemStop = 0,
    DemFileHeader = 1,
    DemFileInfo = 2,
    DemSyncTick = 3,
    DemSendTables = 4,
    DemClassInfo = 5,
    DemStringTables = 6,
    DemPacket = 7,
    DemSignonPacket = 8,
    DemConsoleCmd = 9,
    DemCustomData = 10,
    DemCustomDataCallbacks = 11,
    DemUserCmd = 12,
    DemFullPacket = 13,
    DemSaveGame = 14,
    DemSpawnGroups = 15,
    DemAnimationData = 16,
    DemAnimationHeader = 17,
    DemMax = 18,
    DemIsCompressed = 64,
}
impl EDemoCommands {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic
    /// use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            EDemoCommands::DemError => "DEM_Error",
            EDemoCommands::DemStop => "DEM_Stop",
            EDemoCommands::DemFileHeader => "DEM_FileHeader",
            EDemoCommands::DemFileInfo => "DEM_FileInfo",
            EDemoCommands::DemSyncTick => "DEM_SyncTick",
            EDemoCommands::DemSendTables => "DEM_SendTables",
            EDemoCommands::DemClassInfo => "DEM_ClassInfo",
            EDemoCommands::DemStringTables => "DEM_StringTables",
            EDemoCommands::DemPacket => "DEM_Packet",
            EDemoCommands::DemSignonPacket => "DEM_SignonPacket",
            EDemoCommands::DemConsoleCmd => "DEM_ConsoleCmd",
            EDemoCommands::DemCustomData => "DEM_CustomData",
            EDemoCommands::DemCustomDataCallbacks => "DEM_CustomDataCallbacks",
            EDemoCommands::DemUserCmd => "DEM_UserCmd",
            EDemoCommands::DemFullPacket => "DEM_FullPacket",
            EDemoCommands::DemSaveGame => "DEM_SaveGame",
            EDemoCommands::DemSpawnGroups => "DEM_SpawnGroups",
            EDemoCommands::DemAnimationData => "DEM_AnimationData",
            EDemoCommands::DemAnimationHeader => "DEM_AnimationHeader",
            EDemoCommands::DemMax => "DEM_Max",
            EDemoCommands::DemIsCompressed => "DEM_IsCompressed",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DEM_Error" => Some(Self::DemError),
            "DEM_Stop" => Some(Self::DemStop),
            "DEM_FileHeader" => Some(Self::DemFileHeader),
            "DEM_FileInfo" => Some(Self::DemFileInfo),
            "DEM_SyncTick" => Some(Self::DemSyncTick),
            "DEM_SendTables" => Some(Self::DemSendTables),
            "DEM_ClassInfo" => Some(Self::DemClassInfo),
            "DEM_StringTables" => Some(Self::DemStringTables),
            "DEM_Packet" => Some(Self::DemPacket),
            "DEM_SignonPacket" => Some(Self::DemSignonPacket),
            "DEM_ConsoleCmd" => Some(Self::DemConsoleCmd),
            "DEM_CustomData" => Some(Self::DemCustomData),
            "DEM_CustomDataCallbacks" => Some(Self::DemCustomDataCallbacks),
            "DEM_UserCmd" => Some(Self::DemUserCmd),
            "DEM_FullPacket" => Some(Self::DemFullPacket),
            "DEM_SaveGame" => Some(Self::DemSaveGame),
            "DEM_SpawnGroups" => Some(Self::DemSpawnGroups),
            "DEM_AnimationData" => Some(Self::DemAnimationData),
            "DEM_AnimationHeader" => Some(Self::DemAnimationHeader),
            "DEM_Max" => Some(Self::DemMax),
            "DEM_IsCompressed" => Some(Self::DemIsCompressed),
            _ => None,
        }
    }
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum ENetworkDisconnectionReason {
    NetworkDisconnectInvalid = 0,
    NetworkDisconnectShutdown = 1,
    NetworkDisconnectDisconnectByUser = 2,
    NetworkDisconnectDisconnectByServer = 3,
    NetworkDisconnectLost = 4,
    NetworkDisconnectOverflow = 5,
    NetworkDisconnectSteamBanned = 6,
    NetworkDisconnectSteamInuse = 7,
    NetworkDisconnectSteamTicket = 8,
    NetworkDisconnectSteamLogon = 9,
    NetworkDisconnectSteamAuthcancelled = 10,
    NetworkDisconnectSteamAuthalreadyused = 11,
    NetworkDisconnectSteamAuthinvalid = 12,
    NetworkDisconnectSteamVacbanstate = 13,
    NetworkDisconnectSteamLoggedInElsewhere = 14,
    NetworkDisconnectSteamVacCheckTimedout = 15,
    NetworkDisconnectSteamDropped = 16,
    NetworkDisconnectSteamOwnership = 17,
    NetworkDisconnectServerinfoOverflow = 18,
    NetworkDisconnectTickmsgOverflow = 19,
    NetworkDisconnectStringtablemsgOverflow = 20,
    NetworkDisconnectDeltaentmsgOverflow = 21,
    NetworkDisconnectTempentmsgOverflow = 22,
    NetworkDisconnectSoundsmsgOverflow = 23,
    NetworkDisconnectSnapshotoverflow = 24,
    NetworkDisconnectSnapshoterror = 25,
    NetworkDisconnectReliableoverflow = 26,
    NetworkDisconnectBaddeltatick = 27,
    NetworkDisconnectNomoresplits = 28,
    NetworkDisconnectTimedout = 29,
    NetworkDisconnectDisconnected = 30,
    NetworkDisconnectLeavingsplit = 31,
    NetworkDisconnectDifferentclasstables = 32,
    NetworkDisconnectBadrelaypassword = 33,
    NetworkDisconnectBadspectatorpassword = 34,
    NetworkDisconnectHltvrestricted = 35,
    NetworkDisconnectNospectators = 36,
    NetworkDisconnectHltvunavailable = 37,
    NetworkDisconnectHltvstop = 38,
    NetworkDisconnectKicked = 39,
    NetworkDisconnectBanadded = 40,
    NetworkDisconnectKickbanadded = 41,
    NetworkDisconnectHltvdirect = 42,
    NetworkDisconnectPureserverClientextra = 43,
    NetworkDisconnectPureserverMismatch = 44,
    NetworkDisconnectUsercmd = 45,
    NetworkDisconnectRejectedByGame = 46,
    NetworkDisconnectMessageParseError = 47,
    NetworkDisconnectInvalidMessageError = 48,
    NetworkDisconnectBadServerPassword = 49,
    NetworkDisconnectDirectConnectReservation = 50,
    NetworkDisconnectConnectionFailure = 51,
    NetworkDisconnectNoPeerGroupHandlers = 52,
    NetworkDisconnectReconnection = 53,
    NetworkDisconnectLoopshutdown = 54,
    NetworkDisconnectLoopdeactivate = 55,
    NetworkDisconnectHostEndgame = 56,
    NetworkDisconnectLoopLevelloadActivate = 57,
    NetworkDisconnectCreateServerFailed = 58,
    NetworkDisconnectExiting = 59,
    NetworkDisconnectRequestHoststateIdle = 60,
    NetworkDisconnectRequestHoststateHltvrelay = 61,
    NetworkDisconnectClientConsistencyFail = 62,
    NetworkDisconnectClientUnableToCrcMap = 63,
    NetworkDisconnectClientNoMap = 64,
    NetworkDisconnectClientDifferentMap = 65,
    NetworkDisconnectServerRequiresSteam = 66,
    NetworkDisconnectSteamDenyMisc = 67,
    NetworkDisconnectSteamDenyBadAntiCheat = 68,
    NetworkDisconnectServerShutdown = 69,
    NetworkDisconnectReplayIncompatible = 71,
    NetworkDisconnectConnectRequestTimedout = 72,
    NetworkDisconnectServerIncompatible = 73,
    NetworkDisconnectLocalproblemManyrelays = 74,
    NetworkDisconnectLocalproblemHostedserverprimaryrelay = 75,
    NetworkDisconnectLocalproblemNetworkconfig = 76,
    NetworkDisconnectLocalproblemOther = 77,
    NetworkDisconnectRemoteTimeout = 79,
    NetworkDisconnectRemoteTimeoutConnecting = 80,
    NetworkDisconnectRemoteOther = 81,
    NetworkDisconnectRemoteBadcrypt = 82,
    NetworkDisconnectRemoteCertnottrusted = 83,
    NetworkDisconnectUnusual = 84,
    NetworkDisconnectInternalError = 85,
    NetworkDisconnectRejectBadchallenge = 128,
    NetworkDisconnectRejectNolobby = 129,
    NetworkDisconnectRejectBackgroundMap = 130,
    NetworkDisconnectRejectSinglePlayer = 131,
    NetworkDisconnectRejectHiddenGame = 132,
    NetworkDisconnectRejectLanrestrict = 133,
    NetworkDisconnectRejectBadpassword = 134,
    NetworkDisconnectRejectServerfull = 135,
    NetworkDisconnectRejectInvalidreservation = 136,
    NetworkDisconnectRejectFailedchannel = 137,
    NetworkDisconnectRejectConnectFromLobby = 138,
    NetworkDisconnectRejectReservedForLobby = 139,
    NetworkDisconnectRejectInvalidkeylength = 140,
    NetworkDisconnectRejectOldprotocol = 141,
    NetworkDisconnectRejectNewprotocol = 142,
    NetworkDisconnectRejectInvalidconnection = 143,
    NetworkDisconnectRejectInvalidcertlen = 144,
    NetworkDisconnectRejectInvalidsteamcertlen = 145,
    NetworkDisconnectRejectSteam = 146,
    NetworkDisconnectRejectServerauthdisabled = 147,
    NetworkDisconnectRejectServercdkeyauthinvalid = 148,
    NetworkDisconnectRejectBanned = 149,
    NetworkDisconnectKickedTeamkilling = 150,
    NetworkDisconnectKickedTkStart = 151,
    NetworkDisconnectKickedUntrustedaccount = 152,
    NetworkDisconnectKickedConvictedaccount = 153,
    NetworkDisconnectKickedCompetitivecooldown = 154,
    NetworkDisconnectKickedTeamhurting = 155,
    NetworkDisconnectKickedHostagekilling = 156,
    NetworkDisconnectKickedVotedoff = 157,
    NetworkDisconnectKickedIdle = 158,
    NetworkDisconnectKickedSuicide = 159,
    NetworkDisconnectKickedNosteamlogin = 160,
    NetworkDisconnectKickedNosteamticket = 161,
    NetworkDisconnectKickedInputautomation = 162,
}
impl ENetworkDisconnectionReason {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic
    /// use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ENetworkDisconnectionReason::NetworkDisconnectInvalid => "NETWORK_DISCONNECT_INVALID",
            ENetworkDisconnectionReason::NetworkDisconnectShutdown => "NETWORK_DISCONNECT_SHUTDOWN",
            ENetworkDisconnectionReason::NetworkDisconnectDisconnectByUser => {
                "NETWORK_DISCONNECT_DISCONNECT_BY_USER"
            }
            ENetworkDisconnectionReason::NetworkDisconnectDisconnectByServer => {
                "NETWORK_DISCONNECT_DISCONNECT_BY_SERVER"
            }
            ENetworkDisconnectionReason::NetworkDisconnectLost => "NETWORK_DISCONNECT_LOST",
            ENetworkDisconnectionReason::NetworkDisconnectOverflow => "NETWORK_DISCONNECT_OVERFLOW",
            ENetworkDisconnectionReason::NetworkDisconnectSteamBanned => {
                "NETWORK_DISCONNECT_STEAM_BANNED"
            }
            ENetworkDisconnectionReason::NetworkDisconnectSteamInuse => {
                "NETWORK_DISCONNECT_STEAM_INUSE"
            }
            ENetworkDisconnectionReason::NetworkDisconnectSteamTicket => {
                "NETWORK_DISCONNECT_STEAM_TICKET"
            }
            ENetworkDisconnectionReason::NetworkDisconnectSteamLogon => {
                "NETWORK_DISCONNECT_STEAM_LOGON"
            }
            ENetworkDisconnectionReason::NetworkDisconnectSteamAuthcancelled => {
                "NETWORK_DISCONNECT_STEAM_AUTHCANCELLED"
            }
            ENetworkDisconnectionReason::NetworkDisconnectSteamAuthalreadyused => {
                "NETWORK_DISCONNECT_STEAM_AUTHALREADYUSED"
            }
            ENetworkDisconnectionReason::NetworkDisconnectSteamAuthinvalid => {
                "NETWORK_DISCONNECT_STEAM_AUTHINVALID"
            }
            ENetworkDisconnectionReason::NetworkDisconnectSteamVacbanstate => {
                "NETWORK_DISCONNECT_STEAM_VACBANSTATE"
            }
            ENetworkDisconnectionReason::NetworkDisconnectSteamLoggedInElsewhere => {
                "NETWORK_DISCONNECT_STEAM_LOGGED_IN_ELSEWHERE"
            }
            ENetworkDisconnectionReason::NetworkDisconnectSteamVacCheckTimedout => {
                "NETWORK_DISCONNECT_STEAM_VAC_CHECK_TIMEDOUT"
            }
            ENetworkDisconnectionReason::NetworkDisconnectSteamDropped => {
                "NETWORK_DISCONNECT_STEAM_DROPPED"
            }
            ENetworkDisconnectionReason::NetworkDisconnectSteamOwnership => {
                "NETWORK_DISCONNECT_STEAM_OWNERSHIP"
            }
            ENetworkDisconnectionReason::NetworkDisconnectServerinfoOverflow => {
                "NETWORK_DISCONNECT_SERVERINFO_OVERFLOW"
            }
            ENetworkDisconnectionReason::NetworkDisconnectTickmsgOverflow => {
                "NETWORK_DISCONNECT_TICKMSG_OVERFLOW"
            }
            ENetworkDisconnectionReason::NetworkDisconnectStringtablemsgOverflow => {
                "NETWORK_DISCONNECT_STRINGTABLEMSG_OVERFLOW"
            }
            ENetworkDisconnectionReason::NetworkDisconnectDeltaentmsgOverflow => {
                "NETWORK_DISCONNECT_DELTAENTMSG_OVERFLOW"
            }
            ENetworkDisconnectionReason::NetworkDisconnectTempentmsgOverflow => {
                "NETWORK_DISCONNECT_TEMPENTMSG_OVERFLOW"
            }
            ENetworkDisconnectionReason::NetworkDisconnectSoundsmsgOverflow => {
                "NETWORK_DISCONNECT_SOUNDSMSG_OVERFLOW"
            }
            ENetworkDisconnectionReason::NetworkDisconnectSnapshotoverflow => {
                "NETWORK_DISCONNECT_SNAPSHOTOVERFLOW"
            }
            ENetworkDisconnectionReason::NetworkDisconnectSnapshoterror => {
                "NETWORK_DISCONNECT_SNAPSHOTERROR"
            }
            ENetworkDisconnectionReason::NetworkDisconnectReliableoverflow => {
                "NETWORK_DISCONNECT_RELIABLEOVERFLOW"
            }
            ENetworkDisconnectionReason::NetworkDisconnectBaddeltatick => {
                "NETWORK_DISCONNECT_BADDELTATICK"
            }
            ENetworkDisconnectionReason::NetworkDisconnectNomoresplits => {
                "NETWORK_DISCONNECT_NOMORESPLITS"
            }
            ENetworkDisconnectionReason::NetworkDisconnectTimedout => "NETWORK_DISCONNECT_TIMEDOUT",
            ENetworkDisconnectionReason::NetworkDisconnectDisconnected => {
                "NETWORK_DISCONNECT_DISCONNECTED"
            }
            ENetworkDisconnectionReason::NetworkDisconnectLeavingsplit => {
                "NETWORK_DISCONNECT_LEAVINGSPLIT"
            }
            ENetworkDisconnectionReason::NetworkDisconnectDifferentclasstables => {
                "NETWORK_DISCONNECT_DIFFERENTCLASSTABLES"
            }
            ENetworkDisconnectionReason::NetworkDisconnectBadrelaypassword => {
                "NETWORK_DISCONNECT_BADRELAYPASSWORD"
            }
            ENetworkDisconnectionReason::NetworkDisconnectBadspectatorpassword => {
                "NETWORK_DISCONNECT_BADSPECTATORPASSWORD"
            }
            ENetworkDisconnectionReason::NetworkDisconnectHltvrestricted => {
                "NETWORK_DISCONNECT_HLTVRESTRICTED"
            }
            ENetworkDisconnectionReason::NetworkDisconnectNospectators => {
                "NETWORK_DISCONNECT_NOSPECTATORS"
            }
            ENetworkDisconnectionReason::NetworkDisconnectHltvunavailable => {
                "NETWORK_DISCONNECT_HLTVUNAVAILABLE"
            }
            ENetworkDisconnectionReason::NetworkDisconnectHltvstop => "NETWORK_DISCONNECT_HLTVSTOP",
            ENetworkDisconnectionReason::NetworkDisconnectKicked => "NETWORK_DISCONNECT_KICKED",
            ENetworkDisconnectionReason::NetworkDisconnectBanadded => "NETWORK_DISCONNECT_BANADDED",
            ENetworkDisconnectionReason::NetworkDisconnectKickbanadded => {
                "NETWORK_DISCONNECT_KICKBANADDED"
            }
            ENetworkDisconnectionReason::NetworkDisconnectHltvdirect => {
                "NETWORK_DISCONNECT_HLTVDIRECT"
            }
            ENetworkDisconnectionReason::NetworkDisconnectPureserverClientextra => {
                "NETWORK_DISCONNECT_PURESERVER_CLIENTEXTRA"
            }
            ENetworkDisconnectionReason::NetworkDisconnectPureserverMismatch => {
                "NETWORK_DISCONNECT_PURESERVER_MISMATCH"
            }
            ENetworkDisconnectionReason::NetworkDisconnectUsercmd => "NETWORK_DISCONNECT_USERCMD",
            ENetworkDisconnectionReason::NetworkDisconnectRejectedByGame => {
                "NETWORK_DISCONNECT_REJECTED_BY_GAME"
            }
            ENetworkDisconnectionReason::NetworkDisconnectMessageParseError => {
                "NETWORK_DISCONNECT_MESSAGE_PARSE_ERROR"
            }
            ENetworkDisconnectionReason::NetworkDisconnectInvalidMessageError => {
                "NETWORK_DISCONNECT_INVALID_MESSAGE_ERROR"
            }
            ENetworkDisconnectionReason::NetworkDisconnectBadServerPassword => {
                "NETWORK_DISCONNECT_BAD_SERVER_PASSWORD"
            }
            ENetworkDisconnectionReason::NetworkDisconnectDirectConnectReservation => {
                "NETWORK_DISCONNECT_DIRECT_CONNECT_RESERVATION"
            }
            ENetworkDisconnectionReason::NetworkDisconnectConnectionFailure => {
                "NETWORK_DISCONNECT_CONNECTION_FAILURE"
            }
            ENetworkDisconnectionReason::NetworkDisconnectNoPeerGroupHandlers => {
                "NETWORK_DISCONNECT_NO_PEER_GROUP_HANDLERS"
            }
            ENetworkDisconnectionReason::NetworkDisconnectReconnection => {
                "NETWORK_DISCONNECT_RECONNECTION"
            }
            ENetworkDisconnectionReason::NetworkDisconnectLoopshutdown => {
                "NETWORK_DISCONNECT_LOOPSHUTDOWN"
            }
            ENetworkDisconnectionReason::NetworkDisconnectLoopdeactivate => {
                "NETWORK_DISCONNECT_LOOPDEACTIVATE"
            }
            ENetworkDisconnectionReason::NetworkDisconnectHostEndgame => {
                "NETWORK_DISCONNECT_HOST_ENDGAME"
            }
            ENetworkDisconnectionReason::NetworkDisconnectLoopLevelloadActivate => {
                "NETWORK_DISCONNECT_LOOP_LEVELLOAD_ACTIVATE"
            }
            ENetworkDisconnectionReason::NetworkDisconnectCreateServerFailed => {
                "NETWORK_DISCONNECT_CREATE_SERVER_FAILED"
            }
            ENetworkDisconnectionReason::NetworkDisconnectExiting => "NETWORK_DISCONNECT_EXITING",
            ENetworkDisconnectionReason::NetworkDisconnectRequestHoststateIdle => {
                "NETWORK_DISCONNECT_REQUEST_HOSTSTATE_IDLE"
            }
            ENetworkDisconnectionReason::NetworkDisconnectRequestHoststateHltvrelay => {
                "NETWORK_DISCONNECT_REQUEST_HOSTSTATE_HLTVRELAY"
            }
            ENetworkDisconnectionReason::NetworkDisconnectClientConsistencyFail => {
                "NETWORK_DISCONNECT_CLIENT_CONSISTENCY_FAIL"
            }
            ENetworkDisconnectionReason::NetworkDisconnectClientUnableToCrcMap => {
                "NETWORK_DISCONNECT_CLIENT_UNABLE_TO_CRC_MAP"
            }
            ENetworkDisconnectionReason::NetworkDisconnectClientNoMap => {
                "NETWORK_DISCONNECT_CLIENT_NO_MAP"
            }
            ENetworkDisconnectionReason::NetworkDisconnectClientDifferentMap => {
                "NETWORK_DISCONNECT_CLIENT_DIFFERENT_MAP"
            }
            ENetworkDisconnectionReason::NetworkDisconnectServerRequiresSteam => {
                "NETWORK_DISCONNECT_SERVER_REQUIRES_STEAM"
            }
            ENetworkDisconnectionReason::NetworkDisconnectSteamDenyMisc => {
                "NETWORK_DISCONNECT_STEAM_DENY_MISC"
            }
            ENetworkDisconnectionReason::NetworkDisconnectSteamDenyBadAntiCheat => {
                "NETWORK_DISCONNECT_STEAM_DENY_BAD_ANTI_CHEAT"
            }
            ENetworkDisconnectionReason::NetworkDisconnectServerShutdown => {
                "NETWORK_DISCONNECT_SERVER_SHUTDOWN"
            }
            ENetworkDisconnectionReason::NetworkDisconnectReplayIncompatible => {
                "NETWORK_DISCONNECT_REPLAY_INCOMPATIBLE"
            }
            ENetworkDisconnectionReason::NetworkDisconnectConnectRequestTimedout => {
                "NETWORK_DISCONNECT_CONNECT_REQUEST_TIMEDOUT"
            }
            ENetworkDisconnectionReason::NetworkDisconnectServerIncompatible => {
                "NETWORK_DISCONNECT_SERVER_INCOMPATIBLE"
            }
            ENetworkDisconnectionReason::NetworkDisconnectLocalproblemManyrelays => {
                "NETWORK_DISCONNECT_LOCALPROBLEM_MANYRELAYS"
            }
            ENetworkDisconnectionReason::NetworkDisconnectLocalproblemHostedserverprimaryrelay => {
                "NETWORK_DISCONNECT_LOCALPROBLEM_HOSTEDSERVERPRIMARYRELAY"
            }
            ENetworkDisconnectionReason::NetworkDisconnectLocalproblemNetworkconfig => {
                "NETWORK_DISCONNECT_LOCALPROBLEM_NETWORKCONFIG"
            }
            ENetworkDisconnectionReason::NetworkDisconnectLocalproblemOther => {
                "NETWORK_DISCONNECT_LOCALPROBLEM_OTHER"
            }
            ENetworkDisconnectionReason::NetworkDisconnectRemoteTimeout => {
                "NETWORK_DISCONNECT_REMOTE_TIMEOUT"
            }
            ENetworkDisconnectionReason::NetworkDisconnectRemoteTimeoutConnecting => {
                "NETWORK_DISCONNECT_REMOTE_TIMEOUT_CONNECTING"
            }
            ENetworkDisconnectionReason::NetworkDisconnectRemoteOther => {
                "NETWORK_DISCONNECT_REMOTE_OTHER"
            }
            ENetworkDisconnectionReason::NetworkDisconnectRemoteBadcrypt => {
                "NETWORK_DISCONNECT_REMOTE_BADCRYPT"
            }
            ENetworkDisconnectionReason::NetworkDisconnectRemoteCertnottrusted => {
                "NETWORK_DISCONNECT_REMOTE_CERTNOTTRUSTED"
            }
            ENetworkDisconnectionReason::NetworkDisconnectUnusual => "NETWORK_DISCONNECT_UNUSUAL",
            ENetworkDisconnectionReason::NetworkDisconnectInternalError => {
                "NETWORK_DISCONNECT_INTERNAL_ERROR"
            }
            ENetworkDisconnectionReason::NetworkDisconnectRejectBadchallenge => {
                "NETWORK_DISCONNECT_REJECT_BADCHALLENGE"
            }
            ENetworkDisconnectionReason::NetworkDisconnectRejectNolobby => {
                "NETWORK_DISCONNECT_REJECT_NOLOBBY"
            }
            ENetworkDisconnectionReason::NetworkDisconnectRejectBackgroundMap => {
                "NETWORK_DISCONNECT_REJECT_BACKGROUND_MAP"
            }
            ENetworkDisconnectionReason::NetworkDisconnectRejectSinglePlayer => {
                "NETWORK_DISCONNECT_REJECT_SINGLE_PLAYER"
            }
            ENetworkDisconnectionReason::NetworkDisconnectRejectHiddenGame => {
                "NETWORK_DISCONNECT_REJECT_HIDDEN_GAME"
            }
            ENetworkDisconnectionReason::NetworkDisconnectRejectLanrestrict => {
                "NETWORK_DISCONNECT_REJECT_LANRESTRICT"
            }
            ENetworkDisconnectionReason::NetworkDisconnectRejectBadpassword => {
                "NETWORK_DISCONNECT_REJECT_BADPASSWORD"
            }
            ENetworkDisconnectionReason::NetworkDisconnectRejectServerfull => {
                "NETWORK_DISCONNECT_REJECT_SERVERFULL"
            }
            ENetworkDisconnectionReason::NetworkDisconnectRejectInvalidreservation => {
                "NETWORK_DISCONNECT_REJECT_INVALIDRESERVATION"
            }
            ENetworkDisconnectionReason::NetworkDisconnectRejectFailedchannel => {
                "NETWORK_DISCONNECT_REJECT_FAILEDCHANNEL"
            }
            ENetworkDisconnectionReason::NetworkDisconnectRejectConnectFromLobby => {
                "NETWORK_DISCONNECT_REJECT_CONNECT_FROM_LOBBY"
            }
            ENetworkDisconnectionReason::NetworkDisconnectRejectReservedForLobby => {
                "NETWORK_DISCONNECT_REJECT_RESERVED_FOR_LOBBY"
            }
            ENetworkDisconnectionReason::NetworkDisconnectRejectInvalidkeylength => {
                "NETWORK_DISCONNECT_REJECT_INVALIDKEYLENGTH"
            }
            ENetworkDisconnectionReason::NetworkDisconnectRejectOldprotocol => {
                "NETWORK_DISCONNECT_REJECT_OLDPROTOCOL"
            }
            ENetworkDisconnectionReason::NetworkDisconnectRejectNewprotocol => {
                "NETWORK_DISCONNECT_REJECT_NEWPROTOCOL"
            }
            ENetworkDisconnectionReason::NetworkDisconnectRejectInvalidconnection => {
                "NETWORK_DISCONNECT_REJECT_INVALIDCONNECTION"
            }
            ENetworkDisconnectionReason::NetworkDisconnectRejectInvalidcertlen => {
                "NETWORK_DISCONNECT_REJECT_INVALIDCERTLEN"
            }
            ENetworkDisconnectionReason::NetworkDisconnectRejectInvalidsteamcertlen => {
                "NETWORK_DISCONNECT_REJECT_INVALIDSTEAMCERTLEN"
            }
            ENetworkDisconnectionReason::NetworkDisconnectRejectSteam => {
                "NETWORK_DISCONNECT_REJECT_STEAM"
            }
            ENetworkDisconnectionReason::NetworkDisconnectRejectServerauthdisabled => {
                "NETWORK_DISCONNECT_REJECT_SERVERAUTHDISABLED"
            }
            ENetworkDisconnectionReason::NetworkDisconnectRejectServercdkeyauthinvalid => {
                "NETWORK_DISCONNECT_REJECT_SERVERCDKEYAUTHINVALID"
            }
            ENetworkDisconnectionReason::NetworkDisconnectRejectBanned => {
                "NETWORK_DISCONNECT_REJECT_BANNED"
            }
            ENetworkDisconnectionReason::NetworkDisconnectKickedTeamkilling => {
                "NETWORK_DISCONNECT_KICKED_TEAMKILLING"
            }
            ENetworkDisconnectionReason::NetworkDisconnectKickedTkStart => {
                "NETWORK_DISCONNECT_KICKED_TK_START"
            }
            ENetworkDisconnectionReason::NetworkDisconnectKickedUntrustedaccount => {
                "NETWORK_DISCONNECT_KICKED_UNTRUSTEDACCOUNT"
            }
            ENetworkDisconnectionReason::NetworkDisconnectKickedConvictedaccount => {
                "NETWORK_DISCONNECT_KICKED_CONVICTEDACCOUNT"
            }
            ENetworkDisconnectionReason::NetworkDisconnectKickedCompetitivecooldown => {
                "NETWORK_DISCONNECT_KICKED_COMPETITIVECOOLDOWN"
            }
            ENetworkDisconnectionReason::NetworkDisconnectKickedTeamhurting => {
                "NETWORK_DISCONNECT_KICKED_TEAMHURTING"
            }
            ENetworkDisconnectionReason::NetworkDisconnectKickedHostagekilling => {
                "NETWORK_DISCONNECT_KICKED_HOSTAGEKILLING"
            }
            ENetworkDisconnectionReason::NetworkDisconnectKickedVotedoff => {
                "NETWORK_DISCONNECT_KICKED_VOTEDOFF"
            }
            ENetworkDisconnectionReason::NetworkDisconnectKickedIdle => {
                "NETWORK_DISCONNECT_KICKED_IDLE"
            }
            ENetworkDisconnectionReason::NetworkDisconnectKickedSuicide => {
                "NETWORK_DISCONNECT_KICKED_SUICIDE"
            }
            ENetworkDisconnectionReason::NetworkDisconnectKickedNosteamlogin => {
                "NETWORK_DISCONNECT_KICKED_NOSTEAMLOGIN"
            }
            ENetworkDisconnectionReason::NetworkDisconnectKickedNosteamticket => {
                "NETWORK_DISCONNECT_KICKED_NOSTEAMTICKET"
            }
            ENetworkDisconnectionReason::NetworkDisconnectKickedInputautomation => {
                "NETWORK_DISCONNECT_KICKED_INPUTAUTOMATION"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "NETWORK_DISCONNECT_INVALID" => Some(Self::NetworkDisconnectInvalid),
            "NETWORK_DISCONNECT_SHUTDOWN" => Some(Self::NetworkDisconnectShutdown),
            "NETWORK_DISCONNECT_DISCONNECT_BY_USER" => {
                Some(Self::NetworkDisconnectDisconnectByUser)
            }
            "NETWORK_DISCONNECT_DISCONNECT_BY_SERVER" => {
                Some(Self::NetworkDisconnectDisconnectByServer)
            }
            "NETWORK_DISCONNECT_LOST" => Some(Self::NetworkDisconnectLost),
            "NETWORK_DISCONNECT_OVERFLOW" => Some(Self::NetworkDisconnectOverflow),
            "NETWORK_DISCONNECT_STEAM_BANNED" => Some(Self::NetworkDisconnectSteamBanned),
            "NETWORK_DISCONNECT_STEAM_INUSE" => Some(Self::NetworkDisconnectSteamInuse),
            "NETWORK_DISCONNECT_STEAM_TICKET" => Some(Self::NetworkDisconnectSteamTicket),
            "NETWORK_DISCONNECT_STEAM_LOGON" => Some(Self::NetworkDisconnectSteamLogon),
            "NETWORK_DISCONNECT_STEAM_AUTHCANCELLED" => {
                Some(Self::NetworkDisconnectSteamAuthcancelled)
            }
            "NETWORK_DISCONNECT_STEAM_AUTHALREADYUSED" => {
                Some(Self::NetworkDisconnectSteamAuthalreadyused)
            }
            "NETWORK_DISCONNECT_STEAM_AUTHINVALID" => Some(Self::NetworkDisconnectSteamAuthinvalid),
            "NETWORK_DISCONNECT_STEAM_VACBANSTATE" => Some(Self::NetworkDisconnectSteamVacbanstate),
            "NETWORK_DISCONNECT_STEAM_LOGGED_IN_ELSEWHERE" => {
                Some(Self::NetworkDisconnectSteamLoggedInElsewhere)
            }
            "NETWORK_DISCONNECT_STEAM_VAC_CHECK_TIMEDOUT" => {
                Some(Self::NetworkDisconnectSteamVacCheckTimedout)
            }
            "NETWORK_DISCONNECT_STEAM_DROPPED" => Some(Self::NetworkDisconnectSteamDropped),
            "NETWORK_DISCONNECT_STEAM_OWNERSHIP" => Some(Self::NetworkDisconnectSteamOwnership),
            "NETWORK_DISCONNECT_SERVERINFO_OVERFLOW" => {
                Some(Self::NetworkDisconnectServerinfoOverflow)
            }
            "NETWORK_DISCONNECT_TICKMSG_OVERFLOW" => Some(Self::NetworkDisconnectTickmsgOverflow),
            "NETWORK_DISCONNECT_STRINGTABLEMSG_OVERFLOW" => {
                Some(Self::NetworkDisconnectStringtablemsgOverflow)
            }
            "NETWORK_DISCONNECT_DELTAENTMSG_OVERFLOW" => {
                Some(Self::NetworkDisconnectDeltaentmsgOverflow)
            }
            "NETWORK_DISCONNECT_TEMPENTMSG_OVERFLOW" => {
                Some(Self::NetworkDisconnectTempentmsgOverflow)
            }
            "NETWORK_DISCONNECT_SOUNDSMSG_OVERFLOW" => {
                Some(Self::NetworkDisconnectSoundsmsgOverflow)
            }
            "NETWORK_DISCONNECT_SNAPSHOTOVERFLOW" => Some(Self::NetworkDisconnectSnapshotoverflow),
            "NETWORK_DISCONNECT_SNAPSHOTERROR" => Some(Self::NetworkDisconnectSnapshoterror),
            "NETWORK_DISCONNECT_RELIABLEOVERFLOW" => Some(Self::NetworkDisconnectReliableoverflow),
            "NETWORK_DISCONNECT_BADDELTATICK" => Some(Self::NetworkDisconnectBaddeltatick),
            "NETWORK_DISCONNECT_NOMORESPLITS" => Some(Self::NetworkDisconnectNomoresplits),
            "NETWORK_DISCONNECT_TIMEDOUT" => Some(Self::NetworkDisconnectTimedout),
            "NETWORK_DISCONNECT_DISCONNECTED" => Some(Self::NetworkDisconnectDisconnected),
            "NETWORK_DISCONNECT_LEAVINGSPLIT" => Some(Self::NetworkDisconnectLeavingsplit),
            "NETWORK_DISCONNECT_DIFFERENTCLASSTABLES" => {
                Some(Self::NetworkDisconnectDifferentclasstables)
            }
            "NETWORK_DISCONNECT_BADRELAYPASSWORD" => Some(Self::NetworkDisconnectBadrelaypassword),
            "NETWORK_DISCONNECT_BADSPECTATORPASSWORD" => {
                Some(Self::NetworkDisconnectBadspectatorpassword)
            }
            "NETWORK_DISCONNECT_HLTVRESTRICTED" => Some(Self::NetworkDisconnectHltvrestricted),
            "NETWORK_DISCONNECT_NOSPECTATORS" => Some(Self::NetworkDisconnectNospectators),
            "NETWORK_DISCONNECT_HLTVUNAVAILABLE" => Some(Self::NetworkDisconnectHltvunavailable),
            "NETWORK_DISCONNECT_HLTVSTOP" => Some(Self::NetworkDisconnectHltvstop),
            "NETWORK_DISCONNECT_KICKED" => Some(Self::NetworkDisconnectKicked),
            "NETWORK_DISCONNECT_BANADDED" => Some(Self::NetworkDisconnectBanadded),
            "NETWORK_DISCONNECT_KICKBANADDED" => Some(Self::NetworkDisconnectKickbanadded),
            "NETWORK_DISCONNECT_HLTVDIRECT" => Some(Self::NetworkDisconnectHltvdirect),
            "NETWORK_DISCONNECT_PURESERVER_CLIENTEXTRA" => {
                Some(Self::NetworkDisconnectPureserverClientextra)
            }
            "NETWORK_DISCONNECT_PURESERVER_MISMATCH" => {
                Some(Self::NetworkDisconnectPureserverMismatch)
            }
            "NETWORK_DISCONNECT_USERCMD" => Some(Self::NetworkDisconnectUsercmd),
            "NETWORK_DISCONNECT_REJECTED_BY_GAME" => Some(Self::NetworkDisconnectRejectedByGame),
            "NETWORK_DISCONNECT_MESSAGE_PARSE_ERROR" => {
                Some(Self::NetworkDisconnectMessageParseError)
            }
            "NETWORK_DISCONNECT_INVALID_MESSAGE_ERROR" => {
                Some(Self::NetworkDisconnectInvalidMessageError)
            }
            "NETWORK_DISCONNECT_BAD_SERVER_PASSWORD" => {
                Some(Self::NetworkDisconnectBadServerPassword)
            }
            "NETWORK_DISCONNECT_DIRECT_CONNECT_RESERVATION" => {
                Some(Self::NetworkDisconnectDirectConnectReservation)
            }
            "NETWORK_DISCONNECT_CONNECTION_FAILURE" => {
                Some(Self::NetworkDisconnectConnectionFailure)
            }
            "NETWORK_DISCONNECT_NO_PEER_GROUP_HANDLERS" => {
                Some(Self::NetworkDisconnectNoPeerGroupHandlers)
            }
            "NETWORK_DISCONNECT_RECONNECTION" => Some(Self::NetworkDisconnectReconnection),
            "NETWORK_DISCONNECT_LOOPSHUTDOWN" => Some(Self::NetworkDisconnectLoopshutdown),
            "NETWORK_DISCONNECT_LOOPDEACTIVATE" => Some(Self::NetworkDisconnectLoopdeactivate),
            "NETWORK_DISCONNECT_HOST_ENDGAME" => Some(Self::NetworkDisconnectHostEndgame),
            "NETWORK_DISCONNECT_LOOP_LEVELLOAD_ACTIVATE" => {
                Some(Self::NetworkDisconnectLoopLevelloadActivate)
            }
            "NETWORK_DISCONNECT_CREATE_SERVER_FAILED" => {
                Some(Self::NetworkDisconnectCreateServerFailed)
            }
            "NETWORK_DISCONNECT_EXITING" => Some(Self::NetworkDisconnectExiting),
            "NETWORK_DISCONNECT_REQUEST_HOSTSTATE_IDLE" => {
                Some(Self::NetworkDisconnectRequestHoststateIdle)
            }
            "NETWORK_DISCONNECT_REQUEST_HOSTSTATE_HLTVRELAY" => {
                Some(Self::NetworkDisconnectRequestHoststateHltvrelay)
            }
            "NETWORK_DISCONNECT_CLIENT_CONSISTENCY_FAIL" => {
                Some(Self::NetworkDisconnectClientConsistencyFail)
            }
            "NETWORK_DISCONNECT_CLIENT_UNABLE_TO_CRC_MAP" => {
                Some(Self::NetworkDisconnectClientUnableToCrcMap)
            }
            "NETWORK_DISCONNECT_CLIENT_NO_MAP" => Some(Self::NetworkDisconnectClientNoMap),
            "NETWORK_DISCONNECT_CLIENT_DIFFERENT_MAP" => {
                Some(Self::NetworkDisconnectClientDifferentMap)
            }
            "NETWORK_DISCONNECT_SERVER_REQUIRES_STEAM" => {
                Some(Self::NetworkDisconnectServerRequiresSteam)
            }
            "NETWORK_DISCONNECT_STEAM_DENY_MISC" => Some(Self::NetworkDisconnectSteamDenyMisc),
            "NETWORK_DISCONNECT_STEAM_DENY_BAD_ANTI_CHEAT" => {
                Some(Self::NetworkDisconnectSteamDenyBadAntiCheat)
            }
            "NETWORK_DISCONNECT_SERVER_SHUTDOWN" => Some(Self::NetworkDisconnectServerShutdown),
            "NETWORK_DISCONNECT_REPLAY_INCOMPATIBLE" => {
                Some(Self::NetworkDisconnectReplayIncompatible)
            }
            "NETWORK_DISCONNECT_CONNECT_REQUEST_TIMEDOUT" => {
                Some(Self::NetworkDisconnectConnectRequestTimedout)
            }
            "NETWORK_DISCONNECT_SERVER_INCOMPATIBLE" => {
                Some(Self::NetworkDisconnectServerIncompatible)
            }
            "NETWORK_DISCONNECT_LOCALPROBLEM_MANYRELAYS" => {
                Some(Self::NetworkDisconnectLocalproblemManyrelays)
            }
            "NETWORK_DISCONNECT_LOCALPROBLEM_HOSTEDSERVERPRIMARYRELAY" => {
                Some(Self::NetworkDisconnectLocalproblemHostedserverprimaryrelay)
            }
            "NETWORK_DISCONNECT_LOCALPROBLEM_NETWORKCONFIG" => {
                Some(Self::NetworkDisconnectLocalproblemNetworkconfig)
            }
            "NETWORK_DISCONNECT_LOCALPROBLEM_OTHER" => {
                Some(Self::NetworkDisconnectLocalproblemOther)
            }
            "NETWORK_DISCONNECT_REMOTE_TIMEOUT" => Some(Self::NetworkDisconnectRemoteTimeout),
            "NETWORK_DISCONNECT_REMOTE_TIMEOUT_CONNECTING" => {
                Some(Self::NetworkDisconnectRemoteTimeoutConnecting)
            }
            "NETWORK_DISCONNECT_REMOTE_OTHER" => Some(Self::NetworkDisconnectRemoteOther),
            "NETWORK_DISCONNECT_REMOTE_BADCRYPT" => Some(Self::NetworkDisconnectRemoteBadcrypt),
            "NETWORK_DISCONNECT_REMOTE_CERTNOTTRUSTED" => {
                Some(Self::NetworkDisconnectRemoteCertnottrusted)
            }
            "NETWORK_DISCONNECT_UNUSUAL" => Some(Self::NetworkDisconnectUnusual),
            "NETWORK_DISCONNECT_INTERNAL_ERROR" => Some(Self::NetworkDisconnectInternalError),
            "NETWORK_DISCONNECT_REJECT_BADCHALLENGE" => {
                Some(Self::NetworkDisconnectRejectBadchallenge)
            }
            "NETWORK_DISCONNECT_REJECT_NOLOBBY" => Some(Self::NetworkDisconnectRejectNolobby),
            "NETWORK_DISCONNECT_REJECT_BACKGROUND_MAP" => {
                Some(Self::NetworkDisconnectRejectBackgroundMap)
            }
            "NETWORK_DISCONNECT_REJECT_SINGLE_PLAYER" => {
                Some(Self::NetworkDisconnectRejectSinglePlayer)
            }
            "NETWORK_DISCONNECT_REJECT_HIDDEN_GAME" => {
                Some(Self::NetworkDisconnectRejectHiddenGame)
            }
            "NETWORK_DISCONNECT_REJECT_LANRESTRICT" => {
                Some(Self::NetworkDisconnectRejectLanrestrict)
            }
            "NETWORK_DISCONNECT_REJECT_BADPASSWORD" => {
                Some(Self::NetworkDisconnectRejectBadpassword)
            }
            "NETWORK_DISCONNECT_REJECT_SERVERFULL" => Some(Self::NetworkDisconnectRejectServerfull),
            "NETWORK_DISCONNECT_REJECT_INVALIDRESERVATION" => {
                Some(Self::NetworkDisconnectRejectInvalidreservation)
            }
            "NETWORK_DISCONNECT_REJECT_FAILEDCHANNEL" => {
                Some(Self::NetworkDisconnectRejectFailedchannel)
            }
            "NETWORK_DISCONNECT_REJECT_CONNECT_FROM_LOBBY" => {
                Some(Self::NetworkDisconnectRejectConnectFromLobby)
            }
            "NETWORK_DISCONNECT_REJECT_RESERVED_FOR_LOBBY" => {
                Some(Self::NetworkDisconnectRejectReservedForLobby)
            }
            "NETWORK_DISCONNECT_REJECT_INVALIDKEYLENGTH" => {
                Some(Self::NetworkDisconnectRejectInvalidkeylength)
            }
            "NETWORK_DISCONNECT_REJECT_OLDPROTOCOL" => {
                Some(Self::NetworkDisconnectRejectOldprotocol)
            }
            "NETWORK_DISCONNECT_REJECT_NEWPROTOCOL" => {
                Some(Self::NetworkDisconnectRejectNewprotocol)
            }
            "NETWORK_DISCONNECT_REJECT_INVALIDCONNECTION" => {
                Some(Self::NetworkDisconnectRejectInvalidconnection)
            }
            "NETWORK_DISCONNECT_REJECT_INVALIDCERTLEN" => {
                Some(Self::NetworkDisconnectRejectInvalidcertlen)
            }
            "NETWORK_DISCONNECT_REJECT_INVALIDSTEAMCERTLEN" => {
                Some(Self::NetworkDisconnectRejectInvalidsteamcertlen)
            }
            "NETWORK_DISCONNECT_REJECT_STEAM" => Some(Self::NetworkDisconnectRejectSteam),
            "NETWORK_DISCONNECT_REJECT_SERVERAUTHDISABLED" => {
                Some(Self::NetworkDisconnectRejectServerauthdisabled)
            }
            "NETWORK_DISCONNECT_REJECT_SERVERCDKEYAUTHINVALID" => {
                Some(Self::NetworkDisconnectRejectServercdkeyauthinvalid)
            }
            "NETWORK_DISCONNECT_REJECT_BANNED" => Some(Self::NetworkDisconnectRejectBanned),
            "NETWORK_DISCONNECT_KICKED_TEAMKILLING" => {
                Some(Self::NetworkDisconnectKickedTeamkilling)
            }
            "NETWORK_DISCONNECT_KICKED_TK_START" => Some(Self::NetworkDisconnectKickedTkStart),
            "NETWORK_DISCONNECT_KICKED_UNTRUSTEDACCOUNT" => {
                Some(Self::NetworkDisconnectKickedUntrustedaccount)
            }
            "NETWORK_DISCONNECT_KICKED_CONVICTEDACCOUNT" => {
                Some(Self::NetworkDisconnectKickedConvictedaccount)
            }
            "NETWORK_DISCONNECT_KICKED_COMPETITIVECOOLDOWN" => {
                Some(Self::NetworkDisconnectKickedCompetitivecooldown)
            }
            "NETWORK_DISCONNECT_KICKED_TEAMHURTING" => {
                Some(Self::NetworkDisconnectKickedTeamhurting)
            }
            "NETWORK_DISCONNECT_KICKED_HOSTAGEKILLING" => {
                Some(Self::NetworkDisconnectKickedHostagekilling)
            }
            "NETWORK_DISCONNECT_KICKED_VOTEDOFF" => Some(Self::NetworkDisconnectKickedVotedoff),
            "NETWORK_DISCONNECT_KICKED_IDLE" => Some(Self::NetworkDisconnectKickedIdle),
            "NETWORK_DISCONNECT_KICKED_SUICIDE" => Some(Self::NetworkDisconnectKickedSuicide),
            "NETWORK_DISCONNECT_KICKED_NOSTEAMLOGIN" => {
                Some(Self::NetworkDisconnectKickedNosteamlogin)
            }
            "NETWORK_DISCONNECT_KICKED_NOSTEAMTICKET" => {
                Some(Self::NetworkDisconnectKickedNosteamticket)
            }
            "NETWORK_DISCONNECT_KICKED_INPUTAUTOMATION" => {
                Some(Self::NetworkDisconnectKickedInputautomation)
            }
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgVector {
    #[prost(float, optional, tag = "1")]
    pub x: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "2")]
    pub y: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "3")]
    pub z: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "4")]
    pub w: ::core::option::Option<f32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgVector2D {
    #[prost(float, optional, tag = "1")]
    pub x: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "2")]
    pub y: ::core::option::Option<f32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgQAngle {
    #[prost(float, optional, tag = "1")]
    pub x: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "2")]
    pub y: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "3")]
    pub z: ::core::option::Option<f32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgQuaternion {
    #[prost(float, optional, tag = "1")]
    pub x: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "2")]
    pub y: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "3")]
    pub z: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "4")]
    pub w: ::core::option::Option<f32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgTransform {
    #[prost(message, optional, tag = "1")]
    pub position: ::core::option::Option<CMsgVector>,
    #[prost(float, optional, tag = "2")]
    pub scale: ::core::option::Option<f32>,
    #[prost(message, optional, tag = "3")]
    pub orientation: ::core::option::Option<CMsgQuaternion>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgRgba {
    #[prost(int32, optional, tag = "1")]
    pub r: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub g: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub b: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "4")]
    pub a: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgPlayerInfo {
    #[prost(string, optional, tag = "1")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(fixed64, optional, tag = "2")]
    pub xuid: ::core::option::Option<u64>,
    #[prost(int32, optional, tag = "3")]
    pub userid: ::core::option::Option<i32>,
    #[prost(fixed64, optional, tag = "4")]
    pub steamid: ::core::option::Option<u64>,
    #[prost(bool, optional, tag = "5")]
    pub fakeplayer: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "6")]
    pub ishltv: ::core::option::Option<bool>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CEntityMsg {
    #[prost(uint32, optional, tag = "1", default = "16777215")]
    pub target_entity: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgCVars {
    #[prost(message, repeated, tag = "1")]
    pub cvars: ::prost::alloc::vec::Vec<c_msg_c_vars::CVar>,
}
/// Nested message and enum types in `CMsg_CVars`.
pub mod c_msg_c_vars {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CVar {
        #[prost(string, optional, tag = "1")]
        pub name: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag = "2")]
        pub value: ::core::option::Option<::prost::alloc::string::String>,
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CNetMsgNop {}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CNetMsgSplitScreenUser {
    #[prost(int32, optional, tag = "1")]
    pub slot: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CNetMsgTick {
    #[prost(uint32, optional, tag = "1")]
    pub tick: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub host_frametime: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub host_frametime_std_deviation: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub host_computationtime: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "5")]
    pub host_computationtime_std_deviation: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "6")]
    pub host_framestarttime_std_deviation: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "7")]
    pub host_loss: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "8")]
    pub host_unfiltered_frametime: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "9")]
    pub hltv_replay_flags: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "10")]
    pub expected_long_tick: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "11")]
    pub expected_long_tick_reason: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CNetMsgStringCmd {
    #[prost(string, optional, tag = "1")]
    pub command: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "2")]
    pub prediction_sync: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CNetMsgSetConVar {
    #[prost(message, optional, tag = "1")]
    pub convars: ::core::option::Option<CMsgCVars>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CNetMsgSignonState {
    #[prost(
        enumeration = "SignonStateT",
        optional,
        tag = "1",
        default = "SignonstateNone"
    )]
    pub signon_state: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "2")]
    pub spawn_count: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub num_server_players: ::core::option::Option<u32>,
    #[prost(string, repeated, tag = "4")]
    pub players_networkids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "5")]
    pub map_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "6")]
    pub addons: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CSvcMsgGameEvent {
    #[prost(string, optional, tag = "1")]
    pub event_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "2")]
    pub eventid: ::core::option::Option<i32>,
    #[prost(message, repeated, tag = "3")]
    pub keys: ::prost::alloc::vec::Vec<csvc_msg_game_event::KeyT>,
}
/// Nested message and enum types in `CSVCMsg_GameEvent`.
pub mod csvc_msg_game_event {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct KeyT {
        #[prost(int32, optional, tag = "1")]
        pub r#type: ::core::option::Option<i32>,
        #[prost(string, optional, tag = "2")]
        pub val_string: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(float, optional, tag = "3")]
        pub val_float: ::core::option::Option<f32>,
        #[prost(int32, optional, tag = "4")]
        pub val_long: ::core::option::Option<i32>,
        #[prost(int32, optional, tag = "5")]
        pub val_short: ::core::option::Option<i32>,
        #[prost(int32, optional, tag = "6")]
        pub val_byte: ::core::option::Option<i32>,
        #[prost(bool, optional, tag = "7")]
        pub val_bool: ::core::option::Option<bool>,
        #[prost(uint64, optional, tag = "8")]
        pub val_uint64: ::core::option::Option<u64>,
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CSvcMsgListGameEvents {
    #[prost(message, repeated, tag = "1")]
    pub events: ::prost::alloc::vec::Vec<csvc_msg_list_game_events::EventT>,
}
/// Nested message and enum types in `CSVCMsgList_GameEvents`.
pub mod csvc_msg_list_game_events {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct EventT {
        #[prost(int32, optional, tag = "1")]
        pub tick: ::core::option::Option<i32>,
        #[prost(message, optional, tag = "2")]
        pub event: ::core::option::Option<super::CSvcMsgGameEvent>,
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CNetMsgSpawnGroupLoad {
    #[prost(string, optional, tag = "1")]
    pub worldname: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "2")]
    pub entitylumpname: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3")]
    pub entityfiltername: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "4")]
    pub spawngrouphandle: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "5")]
    pub spawngroupownerhandle: ::core::option::Option<u32>,
    #[prost(message, optional, tag = "6")]
    pub world_offset_pos: ::core::option::Option<CMsgVector>,
    #[prost(message, optional, tag = "7")]
    pub world_offset_angle: ::core::option::Option<CMsgQAngle>,
    #[prost(bytes = "vec", optional, tag = "8")]
    pub spawngroupmanifest: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(uint32, optional, tag = "9")]
    pub flags: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "10")]
    pub tickcount: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "11")]
    pub manifestincomplete: ::core::option::Option<bool>,
    #[prost(string, optional, tag = "12")]
    pub localnamefixup: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "13")]
    pub parentnamefixup: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "14")]
    pub manifestloadpriority: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "15")]
    pub worldgroupid: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "16")]
    pub creationsequence: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "17")]
    pub savegamefilename: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "18")]
    pub spawngroupparenthandle: ::core::option::Option<u32>,
    #[prost(bool, optional, tag = "19")]
    pub leveltransition: ::core::option::Option<bool>,
    #[prost(string, optional, tag = "20")]
    pub worldgroupname: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CNetMsgSpawnGroupManifestUpdate {
    #[prost(uint32, optional, tag = "1")]
    pub spawngrouphandle: ::core::option::Option<u32>,
    #[prost(bytes = "vec", optional, tag = "2")]
    pub spawngroupmanifest: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bool, optional, tag = "3")]
    pub manifestincomplete: ::core::option::Option<bool>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CNetMsgSpawnGroupSetCreationTick {
    #[prost(uint32, optional, tag = "1")]
    pub spawngrouphandle: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "2")]
    pub tickcount: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "3")]
    pub creationsequence: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CNetMsgSpawnGroupUnload {
    #[prost(uint32, optional, tag = "1")]
    pub spawngrouphandle: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub flags: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "3")]
    pub tickcount: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CNetMsgSpawnGroupLoadCompleted {
    #[prost(uint32, optional, tag = "1")]
    pub spawngrouphandle: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CSvcMsgGameSessionConfiguration {
    #[prost(bool, optional, tag = "1")]
    pub is_multiplayer: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "2")]
    pub is_loadsavegame: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "3")]
    pub is_background_map: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "4")]
    pub is_headless: ::core::option::Option<bool>,
    #[prost(uint32, optional, tag = "5")]
    pub min_client_limit: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "6")]
    pub max_client_limit: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "7")]
    pub max_clients: ::core::option::Option<u32>,
    #[prost(fixed32, optional, tag = "8")]
    pub tick_interval: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "9")]
    pub hostname: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "10")]
    pub savegamename: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "11")]
    pub s1_mapname: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "12")]
    pub gamemode: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "13")]
    pub server_ip_address: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bytes = "vec", optional, tag = "14")]
    pub data: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bool, optional, tag = "15")]
    pub is_localonly: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "19")]
    pub no_steam_server: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "16")]
    pub is_transition: ::core::option::Option<bool>,
    #[prost(string, optional, tag = "17")]
    pub previouslevel: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "18")]
    pub landmarkname: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CNetMsgDebugOverlay {
    #[prost(int32, optional, tag = "1")]
    pub etype: ::core::option::Option<i32>,
    #[prost(message, repeated, tag = "2")]
    pub vectors: ::prost::alloc::vec::Vec<CMsgVector>,
    #[prost(message, repeated, tag = "3")]
    pub colors: ::prost::alloc::vec::Vec<CMsgRgba>,
    #[prost(float, repeated, packed = "false", tag = "4")]
    pub dimensions: ::prost::alloc::vec::Vec<f32>,
    #[prost(float, repeated, packed = "false", tag = "5")]
    pub times: ::prost::alloc::vec::Vec<f32>,
    #[prost(bool, repeated, packed = "false", tag = "6")]
    pub bools: ::prost::alloc::vec::Vec<bool>,
    #[prost(uint64, repeated, packed = "false", tag = "7")]
    pub uint64s: ::prost::alloc::vec::Vec<u64>,
    #[prost(string, repeated, tag = "8")]
    pub strings: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum SignonStateT {
    SignonstateNone = 0,
    SignonstateChallenge = 1,
    SignonstateConnected = 2,
    SignonstateNew = 3,
    SignonstatePrespawn = 4,
    SignonstateSpawn = 5,
    SignonstateFull = 6,
    SignonstateChangelevel = 7,
}
impl SignonStateT {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic
    /// use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            SignonStateT::SignonstateNone => "SIGNONSTATE_NONE",
            SignonStateT::SignonstateChallenge => "SIGNONSTATE_CHALLENGE",
            SignonStateT::SignonstateConnected => "SIGNONSTATE_CONNECTED",
            SignonStateT::SignonstateNew => "SIGNONSTATE_NEW",
            SignonStateT::SignonstatePrespawn => "SIGNONSTATE_PRESPAWN",
            SignonStateT::SignonstateSpawn => "SIGNONSTATE_SPAWN",
            SignonStateT::SignonstateFull => "SIGNONSTATE_FULL",
            SignonStateT::SignonstateChangelevel => "SIGNONSTATE_CHANGELEVEL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SIGNONSTATE_NONE" => Some(Self::SignonstateNone),
            "SIGNONSTATE_CHALLENGE" => Some(Self::SignonstateChallenge),
            "SIGNONSTATE_CONNECTED" => Some(Self::SignonstateConnected),
            "SIGNONSTATE_NEW" => Some(Self::SignonstateNew),
            "SIGNONSTATE_PRESPAWN" => Some(Self::SignonstatePrespawn),
            "SIGNONSTATE_SPAWN" => Some(Self::SignonstateSpawn),
            "SIGNONSTATE_FULL" => Some(Self::SignonstateFull),
            "SIGNONSTATE_CHANGELEVEL" => Some(Self::SignonstateChangelevel),
            _ => None,
        }
    }
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum NetMessages {
    NetNop = 0,
    NetDisconnectLegacy = 1,
    NetSplitScreenUser = 3,
    NetTick = 4,
    NetStringCmd = 5,
    NetSetConVar = 6,
    NetSignonState = 7,
    NetSpawnGroupLoad = 8,
    NetSpawnGroupManifestUpdate = 9,
    NetSpawnGroupSetCreationTick = 11,
    NetSpawnGroupUnload = 12,
    NetSpawnGroupLoadCompleted = 13,
    NetDebugOverlay = 15,
}
impl NetMessages {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic
    /// use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            NetMessages::NetNop => "net_NOP",
            NetMessages::NetDisconnectLegacy => "net_Disconnect_Legacy",
            NetMessages::NetSplitScreenUser => "net_SplitScreenUser",
            NetMessages::NetTick => "net_Tick",
            NetMessages::NetStringCmd => "net_StringCmd",
            NetMessages::NetSetConVar => "net_SetConVar",
            NetMessages::NetSignonState => "net_SignonState",
            NetMessages::NetSpawnGroupLoad => "net_SpawnGroup_Load",
            NetMessages::NetSpawnGroupManifestUpdate => "net_SpawnGroup_ManifestUpdate",
            NetMessages::NetSpawnGroupSetCreationTick => "net_SpawnGroup_SetCreationTick",
            NetMessages::NetSpawnGroupUnload => "net_SpawnGroup_Unload",
            NetMessages::NetSpawnGroupLoadCompleted => "net_SpawnGroup_LoadCompleted",
            NetMessages::NetDebugOverlay => "net_DebugOverlay",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "net_NOP" => Some(Self::NetNop),
            "net_Disconnect_Legacy" => Some(Self::NetDisconnectLegacy),
            "net_SplitScreenUser" => Some(Self::NetSplitScreenUser),
            "net_Tick" => Some(Self::NetTick),
            "net_StringCmd" => Some(Self::NetStringCmd),
            "net_SetConVar" => Some(Self::NetSetConVar),
            "net_SignonState" => Some(Self::NetSignonState),
            "net_SpawnGroup_Load" => Some(Self::NetSpawnGroupLoad),
            "net_SpawnGroup_ManifestUpdate" => Some(Self::NetSpawnGroupManifestUpdate),
            "net_SpawnGroup_SetCreationTick" => Some(Self::NetSpawnGroupSetCreationTick),
            "net_SpawnGroup_Unload" => Some(Self::NetSpawnGroupUnload),
            "net_SpawnGroup_LoadCompleted" => Some(Self::NetSpawnGroupLoadCompleted),
            "net_DebugOverlay" => Some(Self::NetDebugOverlay),
            _ => None,
        }
    }
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum SpawnGroupFlagsT {
    SpawnGroupLoadEntitiesFromSave = 1,
    SpawnGroupDontSpawnEntities = 2,
    SpawnGroupSynchronousSpawn = 4,
    SpawnGroupIsInitialSpawnGroup = 8,
    SpawnGroupCreateClientOnlyEntities = 16,
    SpawnGroupBlockUntilLoaded = 64,
    SpawnGroupLoadStreamingData = 128,
    SpawnGroupCreateNewSceneWorld = 256,
}
impl SpawnGroupFlagsT {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic
    /// use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            SpawnGroupFlagsT::SpawnGroupLoadEntitiesFromSave => {
                "SPAWN_GROUP_LOAD_ENTITIES_FROM_SAVE"
            }
            SpawnGroupFlagsT::SpawnGroupDontSpawnEntities => "SPAWN_GROUP_DONT_SPAWN_ENTITIES",
            SpawnGroupFlagsT::SpawnGroupSynchronousSpawn => "SPAWN_GROUP_SYNCHRONOUS_SPAWN",
            SpawnGroupFlagsT::SpawnGroupIsInitialSpawnGroup => "SPAWN_GROUP_IS_INITIAL_SPAWN_GROUP",
            SpawnGroupFlagsT::SpawnGroupCreateClientOnlyEntities => {
                "SPAWN_GROUP_CREATE_CLIENT_ONLY_ENTITIES"
            }
            SpawnGroupFlagsT::SpawnGroupBlockUntilLoaded => "SPAWN_GROUP_BLOCK_UNTIL_LOADED",
            SpawnGroupFlagsT::SpawnGroupLoadStreamingData => "SPAWN_GROUP_LOAD_STREAMING_DATA",
            SpawnGroupFlagsT::SpawnGroupCreateNewSceneWorld => "SPAWN_GROUP_CREATE_NEW_SCENE_WORLD",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SPAWN_GROUP_LOAD_ENTITIES_FROM_SAVE" => Some(Self::SpawnGroupLoadEntitiesFromSave),
            "SPAWN_GROUP_DONT_SPAWN_ENTITIES" => Some(Self::SpawnGroupDontSpawnEntities),
            "SPAWN_GROUP_SYNCHRONOUS_SPAWN" => Some(Self::SpawnGroupSynchronousSpawn),
            "SPAWN_GROUP_IS_INITIAL_SPAWN_GROUP" => Some(Self::SpawnGroupIsInitialSpawnGroup),
            "SPAWN_GROUP_CREATE_CLIENT_ONLY_ENTITIES" => {
                Some(Self::SpawnGroupCreateClientOnlyEntities)
            }
            "SPAWN_GROUP_BLOCK_UNTIL_LOADED" => Some(Self::SpawnGroupBlockUntilLoaded),
            "SPAWN_GROUP_LOAD_STREAMING_DATA" => Some(Self::SpawnGroupLoadStreamingData),
            "SPAWN_GROUP_CREATE_NEW_SCENE_WORLD" => Some(Self::SpawnGroupCreateNewSceneWorld),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgVDebugGameSessionIdEvent {
    #[prost(int32, optional, tag = "1")]
    pub clientid: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "2")]
    pub gamesessionid: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgPlaceDecalEvent {
    #[prost(message, optional, tag = "1")]
    pub position: ::core::option::Option<CMsgVector>,
    #[prost(message, optional, tag = "2")]
    pub normal: ::core::option::Option<CMsgVector>,
    #[prost(message, optional, tag = "3")]
    pub saxis: ::core::option::Option<CMsgVector>,
    #[prost(uint32, optional, tag = "4")]
    pub decalmaterialindex: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "5")]
    pub flags: ::core::option::Option<u32>,
    #[prost(fixed32, optional, tag = "6")]
    pub color: ::core::option::Option<u32>,
    #[prost(float, optional, tag = "7")]
    pub width: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "8")]
    pub height: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "9")]
    pub depth: ::core::option::Option<f32>,
    #[prost(uint32, optional, tag = "10")]
    pub entityhandleindex: ::core::option::Option<u32>,
    #[prost(fixed32, optional, tag = "11")]
    pub skeletoninstancehash: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "12")]
    pub boneindex: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "13")]
    pub translucenthit: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "14")]
    pub is_adjacent: ::core::option::Option<bool>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgClearWorldDecalsEvent {
    #[prost(uint32, optional, tag = "1")]
    pub flagstoclear: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgClearEntityDecalsEvent {
    #[prost(uint32, optional, tag = "1")]
    pub flagstoclear: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgClearDecalsForSkeletonInstanceEvent {
    #[prost(uint32, optional, tag = "1")]
    pub flagstoclear: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub entityhandleindex: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub skeletoninstancehash: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgSource1LegacyGameEventList {
    #[prost(message, repeated, tag = "1")]
    pub descriptors: ::prost::alloc::vec::Vec<c_msg_source1_legacy_game_event_list::DescriptorT>,
}
/// Nested message and enum types in `CMsgSource1LegacyGameEventList`.
pub mod c_msg_source1_legacy_game_event_list {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct KeyT {
        #[prost(int32, optional, tag = "1")]
        pub r#type: ::core::option::Option<i32>,
        #[prost(string, optional, tag = "2")]
        pub name: ::core::option::Option<::prost::alloc::string::String>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DescriptorT {
        #[prost(int32, optional, tag = "1")]
        pub eventid: ::core::option::Option<i32>,
        #[prost(string, optional, tag = "2")]
        pub name: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(message, repeated, tag = "3")]
        pub keys: ::prost::alloc::vec::Vec<KeyT>,
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgSource1LegacyListenEvents {
    #[prost(int32, optional, tag = "1")]
    pub playerslot: ::core::option::Option<i32>,
    #[prost(uint32, repeated, packed = "false", tag = "2")]
    pub eventarraybits: ::prost::alloc::vec::Vec<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgSource1LegacyGameEvent {
    #[prost(string, optional, tag = "1")]
    pub event_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "2")]
    pub eventid: ::core::option::Option<i32>,
    #[prost(message, repeated, tag = "3")]
    pub keys: ::prost::alloc::vec::Vec<c_msg_source1_legacy_game_event::KeyT>,
    #[prost(int32, optional, tag = "4")]
    pub server_tick: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "5")]
    pub passthrough: ::core::option::Option<i32>,
}
/// Nested message and enum types in `CMsgSource1LegacyGameEvent`.
pub mod c_msg_source1_legacy_game_event {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct KeyT {
        #[prost(int32, optional, tag = "1")]
        pub r#type: ::core::option::Option<i32>,
        #[prost(string, optional, tag = "2")]
        pub val_string: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(float, optional, tag = "3")]
        pub val_float: ::core::option::Option<f32>,
        #[prost(int32, optional, tag = "4")]
        pub val_long: ::core::option::Option<i32>,
        #[prost(int32, optional, tag = "5")]
        pub val_short: ::core::option::Option<i32>,
        #[prost(int32, optional, tag = "6")]
        pub val_byte: ::core::option::Option<i32>,
        #[prost(bool, optional, tag = "7")]
        pub val_bool: ::core::option::Option<bool>,
        #[prost(uint64, optional, tag = "8")]
        pub val_uint64: ::core::option::Option<u64>,
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgSosStartSoundEvent {
    #[prost(int32, optional, tag = "1")]
    pub soundevent_guid: ::core::option::Option<i32>,
    #[prost(fixed32, optional, tag = "2")]
    pub soundevent_hash: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "3", default = "-1")]
    pub source_entity_index: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "4")]
    pub seed: ::core::option::Option<i32>,
    #[prost(bytes = "vec", optional, tag = "5")]
    pub packed_params: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(float, optional, tag = "6")]
    pub start_time: ::core::option::Option<f32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgSosStopSoundEvent {
    #[prost(int32, optional, tag = "1")]
    pub soundevent_guid: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgSosStopSoundEventHash {
    #[prost(fixed32, optional, tag = "1")]
    pub soundevent_hash: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "2", default = "-1")]
    pub source_entity_index: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgSosSetSoundEventParams {
    #[prost(int32, optional, tag = "1")]
    pub soundevent_guid: ::core::option::Option<i32>,
    #[prost(bytes = "vec", optional, tag = "5")]
    pub packed_params: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgSosSetLibraryStackFields {
    #[prost(fixed32, optional, tag = "1")]
    pub stack_hash: ::core::option::Option<u32>,
    #[prost(bytes = "vec", optional, tag = "5")]
    pub packed_fields: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum EBaseGameEvents {
    GeVDebugGameSessionIdEvent = 200,
    GePlaceDecalEvent = 201,
    GeClearWorldDecalsEvent = 202,
    GeClearEntityDecalsEvent = 203,
    GeClearDecalsForSkeletonInstanceEvent = 204,
    GeSource1LegacyGameEventList = 205,
    GeSource1LegacyListenEvents = 206,
    GeSource1LegacyGameEvent = 207,
    GeSosStartSoundEvent = 208,
    GeSosStopSoundEvent = 209,
    GeSosSetSoundEventParams = 210,
    GeSosSetLibraryStackFields = 211,
    GeSosStopSoundEventHash = 212,
}
impl EBaseGameEvents {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic
    /// use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            EBaseGameEvents::GeVDebugGameSessionIdEvent => "GE_VDebugGameSessionIDEvent",
            EBaseGameEvents::GePlaceDecalEvent => "GE_PlaceDecalEvent",
            EBaseGameEvents::GeClearWorldDecalsEvent => "GE_ClearWorldDecalsEvent",
            EBaseGameEvents::GeClearEntityDecalsEvent => "GE_ClearEntityDecalsEvent",
            EBaseGameEvents::GeClearDecalsForSkeletonInstanceEvent => {
                "GE_ClearDecalsForSkeletonInstanceEvent"
            }
            EBaseGameEvents::GeSource1LegacyGameEventList => "GE_Source1LegacyGameEventList",
            EBaseGameEvents::GeSource1LegacyListenEvents => "GE_Source1LegacyListenEvents",
            EBaseGameEvents::GeSource1LegacyGameEvent => "GE_Source1LegacyGameEvent",
            EBaseGameEvents::GeSosStartSoundEvent => "GE_SosStartSoundEvent",
            EBaseGameEvents::GeSosStopSoundEvent => "GE_SosStopSoundEvent",
            EBaseGameEvents::GeSosSetSoundEventParams => "GE_SosSetSoundEventParams",
            EBaseGameEvents::GeSosSetLibraryStackFields => "GE_SosSetLibraryStackFields",
            EBaseGameEvents::GeSosStopSoundEventHash => "GE_SosStopSoundEventHash",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "GE_VDebugGameSessionIDEvent" => Some(Self::GeVDebugGameSessionIdEvent),
            "GE_PlaceDecalEvent" => Some(Self::GePlaceDecalEvent),
            "GE_ClearWorldDecalsEvent" => Some(Self::GeClearWorldDecalsEvent),
            "GE_ClearEntityDecalsEvent" => Some(Self::GeClearEntityDecalsEvent),
            "GE_ClearDecalsForSkeletonInstanceEvent" => {
                Some(Self::GeClearDecalsForSkeletonInstanceEvent)
            }
            "GE_Source1LegacyGameEventList" => Some(Self::GeSource1LegacyGameEventList),
            "GE_Source1LegacyListenEvents" => Some(Self::GeSource1LegacyListenEvents),
            "GE_Source1LegacyGameEvent" => Some(Self::GeSource1LegacyGameEvent),
            "GE_SosStartSoundEvent" => Some(Self::GeSosStartSoundEvent),
            "GE_SosStopSoundEvent" => Some(Self::GeSosStopSoundEvent),
            "GE_SosSetSoundEventParams" => Some(Self::GeSosSetSoundEventParams),
            "GE_SosSetLibraryStackFields" => Some(Self::GeSosSetLibraryStackFields),
            "GE_SosStopSoundEventHash" => Some(Self::GeSosStopSoundEventHash),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CclcMsgClientInfo {
    #[prost(fixed32, optional, tag = "1")]
    pub send_table_crc: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub server_count: ::core::option::Option<u32>,
    #[prost(bool, optional, tag = "3")]
    pub is_hltv: ::core::option::Option<bool>,
    #[prost(uint32, optional, tag = "5")]
    pub friends_id: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "6")]
    pub friends_name: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CclcMsgMove {
    #[prost(bytes = "vec", optional, tag = "3")]
    pub data: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(uint32, optional, tag = "4")]
    pub last_command_number: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgVoiceAudio {
    #[prost(
        enumeration = "VoiceDataFormatT",
        optional,
        tag = "1",
        default = "VoicedataFormatSteam"
    )]
    pub format: ::core::option::Option<i32>,
    #[prost(bytes = "vec", optional, tag = "2")]
    pub voice_data: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(int32, optional, tag = "3")]
    pub sequence_bytes: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "4")]
    pub section_number: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "5")]
    pub sample_rate: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "6")]
    pub uncompressed_sample_offset: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "7")]
    pub num_packets: ::core::option::Option<u32>,
    #[prost(uint32, repeated, tag = "8")]
    pub packet_offsets: ::prost::alloc::vec::Vec<u32>,
    #[prost(float, optional, tag = "9")]
    pub voice_level: ::core::option::Option<f32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CclcMsgVoiceData {
    #[prost(message, optional, tag = "1")]
    pub audio: ::core::option::Option<CMsgVoiceAudio>,
    #[prost(fixed64, optional, tag = "2")]
    pub xuid: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "3")]
    pub tick: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CclcMsgBaselineAck {
    #[prost(int32, optional, tag = "1")]
    pub baseline_tick: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub baseline_nr: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CclcMsgListenEvents {
    #[prost(fixed32, repeated, packed = "false", tag = "1")]
    pub event_mask: ::prost::alloc::vec::Vec<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CclcMsgRespondCvarValue {
    #[prost(int32, optional, tag = "1")]
    pub cookie: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub status_code: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "3")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "4")]
    pub value: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CclcMsgFileCrcCheck {
    #[prost(int32, optional, tag = "1")]
    pub code_path: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "2")]
    pub path: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "3")]
    pub code_filename: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "4")]
    pub filename: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(fixed32, optional, tag = "5")]
    pub crc: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CclcMsgLoadingProgress {
    #[prost(int32, optional, tag = "1")]
    pub progress: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CclcMsgSplitPlayerConnect {
    #[prost(string, optional, tag = "1")]
    pub playername: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CclcMsgSplitPlayerDisconnect {
    #[prost(int32, optional, tag = "1")]
    pub slot: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CclcMsgServerStatus {
    #[prost(bool, optional, tag = "1")]
    pub simplified: ::core::option::Option<bool>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CclcMsgRequestPause {
    #[prost(
        enumeration = "RequestPauseT",
        optional,
        tag = "1",
        default = "RpPause"
    )]
    pub pause_type: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub pause_group: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CclcMsgCmdKeyValues {
    #[prost(bytes = "vec", optional, tag = "1")]
    pub data: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CclcMsgRconServerDetails {
    #[prost(bytes = "vec", optional, tag = "1")]
    pub token: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgSource2SystemSpecs {
    #[prost(string, optional, tag = "1")]
    pub cpu_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "2")]
    pub cpu_brand: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "3")]
    pub cpu_model: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub cpu_num_physical: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "21")]
    pub ram_physical_total_mb: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "41")]
    pub gpu_rendersystem_dll_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "42")]
    pub gpu_vendor_id: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "43")]
    pub gpu_driver_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "44")]
    pub gpu_driver_version_high: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "45")]
    pub gpu_driver_version_low: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "46")]
    pub gpu_dx_support_level: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "47")]
    pub gpu_texture_memory_size_mb: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgSource2VProfLiteReportItem {
    #[prost(string, optional, tag = "1")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "2")]
    pub active_samples: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub usec_max: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "11")]
    pub usec_avg_active: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "12")]
    pub usec_p50_active: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "13")]
    pub usec_p99_active: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "21")]
    pub usec_avg_all: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "22")]
    pub usec_p50_all: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "23")]
    pub usec_p99_all: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgSource2VProfLiteReport {
    #[prost(message, optional, tag = "1")]
    pub total: ::core::option::Option<CMsgSource2VProfLiteReportItem>,
    #[prost(message, repeated, tag = "2")]
    pub items: ::prost::alloc::vec::Vec<CMsgSource2VProfLiteReportItem>,
    #[prost(uint32, optional, tag = "3")]
    pub discarded_frames: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CclcMsgDiagnostic {
    #[prost(message, optional, tag = "1")]
    pub system_specs: ::core::option::Option<CMsgSource2SystemSpecs>,
    #[prost(message, optional, tag = "2")]
    pub vprof_report: ::core::option::Option<CMsgSource2VProfLiteReport>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CSource2MetricsMatchPerfSummaryNotification {
    #[prost(uint32, optional, tag = "1")]
    pub appid: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "2")]
    pub game_mode: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "3")]
    pub server_build_id: ::core::option::Option<u32>,
    #[prost(message, optional, tag = "10")]
    pub server_profile: ::core::option::Option<CMsgSource2VProfLiteReport>,
    #[prost(message, repeated, tag = "11")]
    pub clients:
        ::prost::alloc::vec::Vec<c_source2_metrics_match_perf_summary_notification::Client>,
    #[prost(string, optional, tag = "20")]
    pub map: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in
/// `CSource2Metrics_MatchPerfSummary_Notification`.
pub mod c_source2_metrics_match_perf_summary_notification {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Client {
        #[prost(message, optional, tag = "1")]
        pub system_specs: ::core::option::Option<super::CMsgSource2SystemSpecs>,
        #[prost(message, optional, tag = "2")]
        pub profile: ::core::option::Option<super::CMsgSource2VProfLiteReport>,
        #[prost(uint32, optional, tag = "3")]
        pub build_id: ::core::option::Option<u32>,
        #[prost(fixed64, optional, tag = "10")]
        pub steamid: ::core::option::Option<u64>,
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CSvcMsgServerInfo {
    #[prost(int32, optional, tag = "1")]
    pub protocol: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub server_count: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "3")]
    pub is_dedicated: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "4")]
    pub is_hltv: ::core::option::Option<bool>,
    #[prost(int32, optional, tag = "6")]
    pub c_os: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "10")]
    pub max_clients: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "11")]
    pub max_classes: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "12", default = "-1")]
    pub player_slot: ::core::option::Option<i32>,
    #[prost(float, optional, tag = "13")]
    pub tick_interval: ::core::option::Option<f32>,
    #[prost(string, optional, tag = "14")]
    pub game_dir: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "15")]
    pub map_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "16")]
    pub sky_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "17")]
    pub host_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "18")]
    pub addon_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "19")]
    pub game_session_config: ::core::option::Option<CSvcMsgGameSessionConfiguration>,
    #[prost(bytes = "vec", optional, tag = "20")]
    pub game_session_manifest: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CSvcMsgClassInfo {
    #[prost(bool, optional, tag = "1")]
    pub create_on_client: ::core::option::Option<bool>,
    #[prost(message, repeated, tag = "2")]
    pub classes: ::prost::alloc::vec::Vec<csvc_msg_class_info::ClassT>,
}
/// Nested message and enum types in `CSVCMsg_ClassInfo`.
pub mod csvc_msg_class_info {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ClassT {
        #[prost(int32, optional, tag = "1")]
        pub class_id: ::core::option::Option<i32>,
        #[prost(string, optional, tag = "3")]
        pub class_name: ::core::option::Option<::prost::alloc::string::String>,
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CSvcMsgSetPause {
    #[prost(bool, optional, tag = "1")]
    pub paused: ::core::option::Option<bool>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CSvcMsgVoiceInit {
    #[prost(int32, optional, tag = "1")]
    pub quality: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "2")]
    pub codec: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "3", default = "0")]
    pub version: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CSvcMsgPrint {
    #[prost(string, optional, tag = "1")]
    pub text: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CSvcMsgSounds {
    #[prost(bool, optional, tag = "1")]
    pub reliable_sound: ::core::option::Option<bool>,
    #[prost(message, repeated, tag = "2")]
    pub sounds: ::prost::alloc::vec::Vec<csvc_msg_sounds::SounddataT>,
}
/// Nested message and enum types in `CSVCMsg_Sounds`.
pub mod csvc_msg_sounds {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct SounddataT {
        #[prost(sint32, optional, tag = "1")]
        pub origin_x: ::core::option::Option<i32>,
        #[prost(sint32, optional, tag = "2")]
        pub origin_y: ::core::option::Option<i32>,
        #[prost(sint32, optional, tag = "3")]
        pub origin_z: ::core::option::Option<i32>,
        #[prost(uint32, optional, tag = "4")]
        pub volume: ::core::option::Option<u32>,
        #[prost(float, optional, tag = "5")]
        pub delay_value: ::core::option::Option<f32>,
        #[prost(int32, optional, tag = "6")]
        pub sequence_number: ::core::option::Option<i32>,
        #[prost(int32, optional, tag = "7", default = "-1")]
        pub entity_index: ::core::option::Option<i32>,
        #[prost(int32, optional, tag = "8")]
        pub channel: ::core::option::Option<i32>,
        #[prost(int32, optional, tag = "9")]
        pub pitch: ::core::option::Option<i32>,
        #[prost(int32, optional, tag = "10")]
        pub flags: ::core::option::Option<i32>,
        #[prost(uint32, optional, tag = "11")]
        pub sound_num: ::core::option::Option<u32>,
        #[prost(fixed32, optional, tag = "12")]
        pub sound_num_handle: ::core::option::Option<u32>,
        #[prost(int32, optional, tag = "13")]
        pub speaker_entity: ::core::option::Option<i32>,
        #[prost(int32, optional, tag = "14")]
        pub random_seed: ::core::option::Option<i32>,
        #[prost(int32, optional, tag = "15")]
        pub sound_level: ::core::option::Option<i32>,
        #[prost(bool, optional, tag = "16")]
        pub is_sentence: ::core::option::Option<bool>,
        #[prost(bool, optional, tag = "17")]
        pub is_ambient: ::core::option::Option<bool>,
        #[prost(uint32, optional, tag = "18")]
        pub guid: ::core::option::Option<u32>,
        #[prost(fixed64, optional, tag = "19")]
        pub sound_resource_id: ::core::option::Option<u64>,
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CSvcMsgPrefetch {
    #[prost(int32, optional, tag = "1")]
    pub sound_index: ::core::option::Option<i32>,
    #[prost(
        enumeration = "PrefetchType",
        optional,
        tag = "2",
        default = "PftSound"
    )]
    pub resource_type: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CSvcMsgSetView {
    #[prost(int32, optional, tag = "1", default = "-1")]
    pub entity_index: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2", default = "-1")]
    pub slot: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CSvcMsgFixAngle {
    #[prost(bool, optional, tag = "1")]
    pub relative: ::core::option::Option<bool>,
    #[prost(message, optional, tag = "2")]
    pub angle: ::core::option::Option<CMsgQAngle>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CSvcMsgCrosshairAngle {
    #[prost(message, optional, tag = "1")]
    pub angle: ::core::option::Option<CMsgQAngle>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CSvcMsgBspDecal {
    #[prost(message, optional, tag = "1")]
    pub pos: ::core::option::Option<CMsgVector>,
    #[prost(int32, optional, tag = "2")]
    pub decal_texture_index: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3", default = "-1")]
    pub entity_index: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "4")]
    pub model_index: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "5")]
    pub low_priority: ::core::option::Option<bool>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CSvcMsgSplitScreen {
    #[prost(
        enumeration = "ESplitScreenMessageType",
        optional,
        tag = "1",
        default = "MsgSplitscreenAdduser"
    )]
    pub r#type: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub slot: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3", default = "-1")]
    pub player_index: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CSvcMsgGetCvarValue {
    #[prost(int32, optional, tag = "1")]
    pub cookie: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "2")]
    pub cvar_name: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CSvcMsgMenu {
    #[prost(int32, optional, tag = "1")]
    pub dialog_type: ::core::option::Option<i32>,
    #[prost(bytes = "vec", optional, tag = "2")]
    pub menu_key_values: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CSvcMsgUserMessage {
    #[prost(int32, optional, tag = "1")]
    pub msg_type: ::core::option::Option<i32>,
    #[prost(bytes = "vec", optional, tag = "2")]
    pub msg_data: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(int32, optional, tag = "3")]
    pub passthrough: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CSvcMsgSendTable {
    #[prost(bool, optional, tag = "1")]
    pub is_end: ::core::option::Option<bool>,
    #[prost(string, optional, tag = "2")]
    pub net_table_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "3")]
    pub needs_decoder: ::core::option::Option<bool>,
    #[prost(message, repeated, tag = "4")]
    pub props: ::prost::alloc::vec::Vec<csvc_msg_send_table::SendpropT>,
}
/// Nested message and enum types in `CSVCMsg_SendTable`.
pub mod csvc_msg_send_table {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SendpropT {
        #[prost(int32, optional, tag = "1")]
        pub r#type: ::core::option::Option<i32>,
        #[prost(string, optional, tag = "2")]
        pub var_name: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(int32, optional, tag = "3")]
        pub flags: ::core::option::Option<i32>,
        #[prost(int32, optional, tag = "4")]
        pub priority: ::core::option::Option<i32>,
        #[prost(string, optional, tag = "5")]
        pub dt_name: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(int32, optional, tag = "6")]
        pub num_elements: ::core::option::Option<i32>,
        #[prost(float, optional, tag = "7")]
        pub low_value: ::core::option::Option<f32>,
        #[prost(float, optional, tag = "8")]
        pub high_value: ::core::option::Option<f32>,
        #[prost(int32, optional, tag = "9")]
        pub num_bits: ::core::option::Option<i32>,
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CSvcMsgGameEventList {
    #[prost(message, repeated, tag = "1")]
    pub descriptors: ::prost::alloc::vec::Vec<csvc_msg_game_event_list::DescriptorT>,
}
/// Nested message and enum types in `CSVCMsg_GameEventList`.
pub mod csvc_msg_game_event_list {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct KeyT {
        #[prost(int32, optional, tag = "1")]
        pub r#type: ::core::option::Option<i32>,
        #[prost(string, optional, tag = "2")]
        pub name: ::core::option::Option<::prost::alloc::string::String>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DescriptorT {
        #[prost(int32, optional, tag = "1")]
        pub eventid: ::core::option::Option<i32>,
        #[prost(string, optional, tag = "2")]
        pub name: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(message, repeated, tag = "3")]
        pub keys: ::prost::alloc::vec::Vec<KeyT>,
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CSvcMsgPacketEntities {
    #[prost(int32, optional, tag = "1")]
    pub max_entries: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub updated_entries: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "3")]
    pub legacy_is_delta: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "4")]
    pub update_baseline: ::core::option::Option<bool>,
    #[prost(int32, optional, tag = "5")]
    pub baseline: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "6")]
    pub delta_from: ::core::option::Option<i32>,
    #[prost(bytes = "vec", optional, tag = "7")]
    pub entity_data: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bool, optional, tag = "8")]
    pub pending_full_frame: ::core::option::Option<bool>,
    #[prost(uint32, optional, tag = "9")]
    pub active_spawngroup_handle: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "10")]
    pub max_spawngroup_creationsequence: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "11")]
    pub last_cmd_number_executed: ::core::option::Option<u32>,
    #[prost(sint32, optional, tag = "17")]
    pub last_cmd_number_recv_delta: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "12")]
    pub server_tick: ::core::option::Option<u32>,
    #[prost(bytes = "vec", optional, tag = "13")]
    pub serialized_entities: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(message, repeated, tag = "15")]
    pub alternate_baselines: ::prost::alloc::vec::Vec<csvc_msg_packet_entities::AlternateBaselineT>,
    #[prost(uint32, optional, tag = "16")]
    pub has_pvs_vis_bits: ::core::option::Option<u32>,
    #[prost(sint32, repeated, tag = "22")]
    pub cmd_recv_status: ::prost::alloc::vec::Vec<i32>,
    #[prost(message, optional, tag = "19")]
    pub non_transmitted_entities:
        ::core::option::Option<csvc_msg_packet_entities::NonTransmittedEntitiesT>,
    #[prost(uint32, optional, tag = "20")]
    pub cq_starved_command_ticks: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "21")]
    pub cq_discarded_command_ticks: ::core::option::Option<u32>,
    #[prost(bytes = "vec", optional, tag = "999")]
    pub dev_padding: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
/// Nested message and enum types in `CSVCMsg_PacketEntities`.
pub mod csvc_msg_packet_entities {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct AlternateBaselineT {
        #[prost(int32, optional, tag = "1")]
        pub entity_index: ::core::option::Option<i32>,
        #[prost(int32, optional, tag = "2")]
        pub baseline_index: ::core::option::Option<i32>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct NonTransmittedEntitiesT {
        #[prost(int32, optional, tag = "1")]
        pub header_count: ::core::option::Option<i32>,
        #[prost(bytes = "vec", optional, tag = "2")]
        pub data: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CSvcMsgTempEntities {
    #[prost(bool, optional, tag = "1")]
    pub reliable: ::core::option::Option<bool>,
    #[prost(int32, optional, tag = "2")]
    pub num_entries: ::core::option::Option<i32>,
    #[prost(bytes = "vec", optional, tag = "3")]
    pub entity_data: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CSvcMsgCreateStringTable {
    #[prost(string, optional, tag = "1")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "2")]
    pub num_entries: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "3")]
    pub user_data_fixed_size: ::core::option::Option<bool>,
    #[prost(int32, optional, tag = "4")]
    pub user_data_size: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "5")]
    pub user_data_size_bits: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "6")]
    pub flags: ::core::option::Option<i32>,
    #[prost(bytes = "vec", optional, tag = "7")]
    pub string_data: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(int32, optional, tag = "8")]
    pub uncompressed_size: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "9")]
    pub data_compressed: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "10")]
    pub using_varint_bitcounts: ::core::option::Option<bool>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CSvcMsgUpdateStringTable {
    #[prost(int32, optional, tag = "1")]
    pub table_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub num_changed_entries: ::core::option::Option<i32>,
    #[prost(bytes = "vec", optional, tag = "3")]
    pub string_data: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CSvcMsgVoiceData {
    #[prost(message, optional, tag = "1")]
    pub audio: ::core::option::Option<CMsgVoiceAudio>,
    #[prost(int32, optional, tag = "2", default = "-1")]
    pub client: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "3")]
    pub proximity: ::core::option::Option<bool>,
    #[prost(fixed64, optional, tag = "4")]
    pub xuid: ::core::option::Option<u64>,
    #[prost(int32, optional, tag = "5")]
    pub audible_mask: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "6")]
    pub tick: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "7")]
    pub passthrough: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CSvcMsgPacketReliable {
    #[prost(int32, optional, tag = "1")]
    pub tick: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub messagessize: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "3")]
    pub state: ::core::option::Option<bool>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CSvcMsgFullFrameSplit {
    #[prost(int32, optional, tag = "1")]
    pub tick: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub section: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub total: ::core::option::Option<i32>,
    #[prost(bytes = "vec", optional, tag = "4")]
    pub data: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CSvcMsgHltvStatus {
    #[prost(string, optional, tag = "1")]
    pub master: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "2")]
    pub clients: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub slots: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "4")]
    pub proxies: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CSvcMsgServerSteamId {
    #[prost(uint64, optional, tag = "1")]
    pub steam_id: ::core::option::Option<u64>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CSvcMsgCmdKeyValues {
    #[prost(bytes = "vec", optional, tag = "1")]
    pub data: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CSvcMsgRconServerDetails {
    #[prost(bytes = "vec", optional, tag = "1")]
    pub token: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(string, optional, tag = "2")]
    pub details: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgIpcAddress {
    #[prost(fixed64, optional, tag = "1")]
    pub computer_guid: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "2")]
    pub process_id: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgServerPeer {
    #[prost(int32, optional, tag = "1", default = "-1")]
    pub player_slot: ::core::option::Option<i32>,
    #[prost(fixed64, optional, tag = "2")]
    pub steamid: ::core::option::Option<u64>,
    #[prost(message, optional, tag = "3")]
    pub ipc: ::core::option::Option<CMsgIpcAddress>,
    #[prost(bool, optional, tag = "4")]
    pub they_hear_you: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "5")]
    pub you_hear_them: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "6")]
    pub is_listenserver_host: ::core::option::Option<bool>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CSvcMsgPeerList {
    #[prost(message, repeated, tag = "1")]
    pub peer: ::prost::alloc::vec::Vec<CMsgServerPeer>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CSvcMsgClearAllStringTables {
    #[prost(string, optional, tag = "1")]
    pub mapname: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "3")]
    pub create_tables_skipped: ::core::option::Option<bool>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProtoFlattenedSerializerFieldT {
    #[prost(int32, optional, tag = "1")]
    pub var_type_sym: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub var_name_sym: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub bit_count: ::core::option::Option<i32>,
    #[prost(float, optional, tag = "4")]
    pub low_value: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "5")]
    pub high_value: ::core::option::Option<f32>,
    #[prost(int32, optional, tag = "6")]
    pub encode_flags: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "7")]
    pub field_serializer_name_sym: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "8")]
    pub field_serializer_version: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "9")]
    pub send_node_sym: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "10")]
    pub var_encoder_sym: ::core::option::Option<i32>,
    #[prost(message, repeated, tag = "11")]
    pub polymorphic_types:
        ::prost::alloc::vec::Vec<proto_flattened_serializer_field_t::PolymorphicFieldT>,
    #[prost(int32, optional, tag = "12")]
    pub var_serializer_sym: ::core::option::Option<i32>,
}
/// Nested message and enum types in `ProtoFlattenedSerializerField_t`.
pub mod proto_flattened_serializer_field_t {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct PolymorphicFieldT {
        #[prost(int32, optional, tag = "1")]
        pub polymorphic_field_serializer_name_sym: ::core::option::Option<i32>,
        #[prost(int32, optional, tag = "2")]
        pub polymorphic_field_serializer_version: ::core::option::Option<i32>,
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProtoFlattenedSerializerT {
    #[prost(int32, optional, tag = "1")]
    pub serializer_name_sym: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub serializer_version: ::core::option::Option<i32>,
    #[prost(int32, repeated, packed = "false", tag = "3")]
    pub fields_index: ::prost::alloc::vec::Vec<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CSvcMsgFlattenedSerializer {
    #[prost(message, repeated, tag = "1")]
    pub serializers: ::prost::alloc::vec::Vec<ProtoFlattenedSerializerT>,
    #[prost(string, repeated, tag = "2")]
    pub symbols: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "3")]
    pub fields: ::prost::alloc::vec::Vec<ProtoFlattenedSerializerFieldT>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CSvcMsgStopSound {
    #[prost(fixed32, optional, tag = "1")]
    pub guid: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CBidirMsgRebroadcastGameEvent {
    #[prost(bool, optional, tag = "1")]
    pub posttoserver: ::core::option::Option<bool>,
    #[prost(int32, optional, tag = "2")]
    pub buftype: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "3")]
    pub clientbitcount: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "4")]
    pub receivingclients: ::core::option::Option<u64>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CBidirMsgRebroadcastSource {
    #[prost(int32, optional, tag = "1")]
    pub eventsource: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgServerNetworkStats {
    #[prost(bool, optional, tag = "1")]
    pub dedicated: ::core::option::Option<bool>,
    #[prost(int32, optional, tag = "2")]
    pub cpu_usage: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub memory_used_mb: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "4")]
    pub memory_free_mb: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "5")]
    pub uptime: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "6")]
    pub spawn_count: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "8")]
    pub num_clients: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "9")]
    pub num_bots: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "10")]
    pub num_spectators: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "11")]
    pub num_tv_relays: ::core::option::Option<i32>,
    #[prost(float, optional, tag = "12")]
    pub fps: ::core::option::Option<f32>,
    #[prost(message, repeated, tag = "17")]
    pub ports: ::prost::alloc::vec::Vec<c_msg_server_network_stats::Port>,
    #[prost(float, optional, tag = "18")]
    pub avg_ping_ms: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "19")]
    pub avg_engine_latency_out: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "20")]
    pub avg_packets_out: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "21")]
    pub avg_packets_in: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "22")]
    pub avg_loss_out: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "23")]
    pub avg_loss_in: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "24")]
    pub avg_data_out: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "25")]
    pub avg_data_in: ::core::option::Option<f32>,
    #[prost(uint64, optional, tag = "26")]
    pub total_data_in: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "27")]
    pub total_packets_in: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "28")]
    pub total_data_out: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "29")]
    pub total_packets_out: ::core::option::Option<u64>,
    #[prost(message, repeated, tag = "30")]
    pub players: ::prost::alloc::vec::Vec<c_msg_server_network_stats::Player>,
}
/// Nested message and enum types in `CMsgServerNetworkStats`.
pub mod c_msg_server_network_stats {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Port {
        #[prost(int32, optional, tag = "1")]
        pub port: ::core::option::Option<i32>,
        #[prost(string, optional, tag = "2")]
        pub name: ::core::option::Option<::prost::alloc::string::String>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Player {
        #[prost(uint64, optional, tag = "1")]
        pub steamid: ::core::option::Option<u64>,
        #[prost(string, optional, tag = "2")]
        pub remote_addr: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(int32, optional, tag = "4")]
        pub ping_avg_ms: ::core::option::Option<i32>,
        #[prost(float, optional, tag = "5")]
        pub packet_loss_pct: ::core::option::Option<f32>,
        #[prost(bool, optional, tag = "6")]
        pub is_bot: ::core::option::Option<bool>,
        #[prost(float, optional, tag = "7")]
        pub loss_in: ::core::option::Option<f32>,
        #[prost(float, optional, tag = "8")]
        pub loss_out: ::core::option::Option<f32>,
        #[prost(int32, optional, tag = "9")]
        pub engine_latency_ms: ::core::option::Option<i32>,
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CSvcMsgHltvReplay {
    #[prost(int32, optional, tag = "1")]
    pub delay: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2", default = "-1")]
    pub primary_target: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub replay_stop_at: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "4")]
    pub replay_start_at: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "5")]
    pub replay_slowdown_begin: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "6")]
    pub replay_slowdown_end: ::core::option::Option<i32>,
    #[prost(float, optional, tag = "7")]
    pub replay_slowdown_rate: ::core::option::Option<f32>,
    #[prost(int32, optional, tag = "8")]
    pub reason: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CclcMsgHltvReplay {
    #[prost(int32, optional, tag = "1")]
    pub request: ::core::option::Option<i32>,
    #[prost(float, optional, tag = "2")]
    pub slowdown_length: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "3")]
    pub slowdown_rate: ::core::option::Option<f32>,
    #[prost(int32, optional, tag = "4", default = "-1")]
    pub primary_target: ::core::option::Option<i32>,
    #[prost(float, optional, tag = "5")]
    pub event_time: ::core::option::Option<f32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CSvcMsgBroadcastCommand {
    #[prost(string, optional, tag = "1")]
    pub cmd: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CclcMsgHltvFixupOperatorTick {
    #[prost(int32, optional, tag = "1")]
    pub tick: ::core::option::Option<i32>,
    #[prost(bytes = "vec", optional, tag = "2")]
    pub props_data: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(message, optional, tag = "3")]
    pub origin: ::core::option::Option<CMsgVector>,
    #[prost(message, optional, tag = "4")]
    pub eye_angles: ::core::option::Option<CMsgQAngle>,
    #[prost(int32, optional, tag = "5")]
    pub observer_mode: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "6")]
    pub cameraman_scoreboard: ::core::option::Option<bool>,
    #[prost(int32, optional, tag = "7")]
    pub observer_target: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "8")]
    pub view_offset: ::core::option::Option<CMsgVector>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CSvcMsgHltvFixupOperatorStatus {
    #[prost(uint32, optional, tag = "1")]
    pub mode: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "2")]
    pub override_operator_name: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgServerUserCmd {
    #[prost(bytes = "vec", optional, tag = "1")]
    pub data: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(int32, optional, tag = "2")]
    pub cmd_number: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3", default = "-1")]
    pub player_slot: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "4")]
    pub server_tick_executed: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "5")]
    pub client_tick: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CSvcMsgUserCommands {
    #[prost(message, repeated, tag = "1")]
    pub commands: ::prost::alloc::vec::Vec<CMsgServerUserCmd>,
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum ClcMessages {
    ClcClientInfo = 20,
    ClcMove = 21,
    ClcVoiceData = 22,
    ClcBaselineAck = 23,
    ClcRespondCvarValue = 25,
    ClcFileCrcCheck = 26,
    ClcLoadingProgress = 27,
    ClcSplitPlayerConnect = 28,
    ClcSplitPlayerDisconnect = 30,
    ClcServerStatus = 31,
    ClcRequestPause = 33,
    ClcCmdKeyValues = 34,
    ClcRconServerDetails = 35,
    ClcHltvReplay = 36,
    ClcDiagnostic = 37,
}
impl ClcMessages {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic
    /// use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ClcMessages::ClcClientInfo => "clc_ClientInfo",
            ClcMessages::ClcMove => "clc_Move",
            ClcMessages::ClcVoiceData => "clc_VoiceData",
            ClcMessages::ClcBaselineAck => "clc_BaselineAck",
            ClcMessages::ClcRespondCvarValue => "clc_RespondCvarValue",
            ClcMessages::ClcFileCrcCheck => "clc_FileCRCCheck",
            ClcMessages::ClcLoadingProgress => "clc_LoadingProgress",
            ClcMessages::ClcSplitPlayerConnect => "clc_SplitPlayerConnect",
            ClcMessages::ClcSplitPlayerDisconnect => "clc_SplitPlayerDisconnect",
            ClcMessages::ClcServerStatus => "clc_ServerStatus",
            ClcMessages::ClcRequestPause => "clc_RequestPause",
            ClcMessages::ClcCmdKeyValues => "clc_CmdKeyValues",
            ClcMessages::ClcRconServerDetails => "clc_RconServerDetails",
            ClcMessages::ClcHltvReplay => "clc_HltvReplay",
            ClcMessages::ClcDiagnostic => "clc_Diagnostic",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "clc_ClientInfo" => Some(Self::ClcClientInfo),
            "clc_Move" => Some(Self::ClcMove),
            "clc_VoiceData" => Some(Self::ClcVoiceData),
            "clc_BaselineAck" => Some(Self::ClcBaselineAck),
            "clc_RespondCvarValue" => Some(Self::ClcRespondCvarValue),
            "clc_FileCRCCheck" => Some(Self::ClcFileCrcCheck),
            "clc_LoadingProgress" => Some(Self::ClcLoadingProgress),
            "clc_SplitPlayerConnect" => Some(Self::ClcSplitPlayerConnect),
            "clc_SplitPlayerDisconnect" => Some(Self::ClcSplitPlayerDisconnect),
            "clc_ServerStatus" => Some(Self::ClcServerStatus),
            "clc_RequestPause" => Some(Self::ClcRequestPause),
            "clc_CmdKeyValues" => Some(Self::ClcCmdKeyValues),
            "clc_RconServerDetails" => Some(Self::ClcRconServerDetails),
            "clc_HltvReplay" => Some(Self::ClcHltvReplay),
            "clc_Diagnostic" => Some(Self::ClcDiagnostic),
            _ => None,
        }
    }
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum SvcMessages {
    SvcServerInfo = 40,
    SvcFlattenedSerializer = 41,
    SvcClassInfo = 42,
    SvcSetPause = 43,
    SvcCreateStringTable = 44,
    SvcUpdateStringTable = 45,
    SvcVoiceInit = 46,
    SvcVoiceData = 47,
    SvcPrint = 48,
    SvcSounds = 49,
    SvcSetView = 50,
    SvcClearAllStringTables = 51,
    SvcCmdKeyValues = 52,
    SvcBspDecal = 53,
    SvcSplitScreen = 54,
    SvcPacketEntities = 55,
    SvcPrefetch = 56,
    SvcMenu = 57,
    SvcGetCvarValue = 58,
    SvcStopSound = 59,
    SvcPeerList = 60,
    SvcPacketReliable = 61,
    SvcHltvStatus = 62,
    SvcServerSteamId = 63,
    SvcFullFrameSplit = 70,
    SvcRconServerDetails = 71,
    SvcUserMessage = 72,
    SvcBroadcastCommand = 74,
    SvcHltvFixupOperatorStatus = 75,
    SvcUserCmds = 76,
}
impl SvcMessages {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic
    /// use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            SvcMessages::SvcServerInfo => "svc_ServerInfo",
            SvcMessages::SvcFlattenedSerializer => "svc_FlattenedSerializer",
            SvcMessages::SvcClassInfo => "svc_ClassInfo",
            SvcMessages::SvcSetPause => "svc_SetPause",
            SvcMessages::SvcCreateStringTable => "svc_CreateStringTable",
            SvcMessages::SvcUpdateStringTable => "svc_UpdateStringTable",
            SvcMessages::SvcVoiceInit => "svc_VoiceInit",
            SvcMessages::SvcVoiceData => "svc_VoiceData",
            SvcMessages::SvcPrint => "svc_Print",
            SvcMessages::SvcSounds => "svc_Sounds",
            SvcMessages::SvcSetView => "svc_SetView",
            SvcMessages::SvcClearAllStringTables => "svc_ClearAllStringTables",
            SvcMessages::SvcCmdKeyValues => "svc_CmdKeyValues",
            SvcMessages::SvcBspDecal => "svc_BSPDecal",
            SvcMessages::SvcSplitScreen => "svc_SplitScreen",
            SvcMessages::SvcPacketEntities => "svc_PacketEntities",
            SvcMessages::SvcPrefetch => "svc_Prefetch",
            SvcMessages::SvcMenu => "svc_Menu",
            SvcMessages::SvcGetCvarValue => "svc_GetCvarValue",
            SvcMessages::SvcStopSound => "svc_StopSound",
            SvcMessages::SvcPeerList => "svc_PeerList",
            SvcMessages::SvcPacketReliable => "svc_PacketReliable",
            SvcMessages::SvcHltvStatus => "svc_HLTVStatus",
            SvcMessages::SvcServerSteamId => "svc_ServerSteamID",
            SvcMessages::SvcFullFrameSplit => "svc_FullFrameSplit",
            SvcMessages::SvcRconServerDetails => "svc_RconServerDetails",
            SvcMessages::SvcUserMessage => "svc_UserMessage",
            SvcMessages::SvcBroadcastCommand => "svc_Broadcast_Command",
            SvcMessages::SvcHltvFixupOperatorStatus => "svc_HltvFixupOperatorStatus",
            SvcMessages::SvcUserCmds => "svc_UserCmds",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "svc_ServerInfo" => Some(Self::SvcServerInfo),
            "svc_FlattenedSerializer" => Some(Self::SvcFlattenedSerializer),
            "svc_ClassInfo" => Some(Self::SvcClassInfo),
            "svc_SetPause" => Some(Self::SvcSetPause),
            "svc_CreateStringTable" => Some(Self::SvcCreateStringTable),
            "svc_UpdateStringTable" => Some(Self::SvcUpdateStringTable),
            "svc_VoiceInit" => Some(Self::SvcVoiceInit),
            "svc_VoiceData" => Some(Self::SvcVoiceData),
            "svc_Print" => Some(Self::SvcPrint),
            "svc_Sounds" => Some(Self::SvcSounds),
            "svc_SetView" => Some(Self::SvcSetView),
            "svc_ClearAllStringTables" => Some(Self::SvcClearAllStringTables),
            "svc_CmdKeyValues" => Some(Self::SvcCmdKeyValues),
            "svc_BSPDecal" => Some(Self::SvcBspDecal),
            "svc_SplitScreen" => Some(Self::SvcSplitScreen),
            "svc_PacketEntities" => Some(Self::SvcPacketEntities),
            "svc_Prefetch" => Some(Self::SvcPrefetch),
            "svc_Menu" => Some(Self::SvcMenu),
            "svc_GetCvarValue" => Some(Self::SvcGetCvarValue),
            "svc_StopSound" => Some(Self::SvcStopSound),
            "svc_PeerList" => Some(Self::SvcPeerList),
            "svc_PacketReliable" => Some(Self::SvcPacketReliable),
            "svc_HLTVStatus" => Some(Self::SvcHltvStatus),
            "svc_ServerSteamID" => Some(Self::SvcServerSteamId),
            "svc_FullFrameSplit" => Some(Self::SvcFullFrameSplit),
            "svc_RconServerDetails" => Some(Self::SvcRconServerDetails),
            "svc_UserMessage" => Some(Self::SvcUserMessage),
            "svc_Broadcast_Command" => Some(Self::SvcBroadcastCommand),
            "svc_HltvFixupOperatorStatus" => Some(Self::SvcHltvFixupOperatorStatus),
            "svc_UserCmds" => Some(Self::SvcUserCmds),
            _ => None,
        }
    }
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum VoiceDataFormatT {
    VoicedataFormatSteam = 0,
    VoicedataFormatEngine = 1,
    VoicedataFormatOpus = 2,
}
impl VoiceDataFormatT {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic
    /// use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            VoiceDataFormatT::VoicedataFormatSteam => "VOICEDATA_FORMAT_STEAM",
            VoiceDataFormatT::VoicedataFormatEngine => "VOICEDATA_FORMAT_ENGINE",
            VoiceDataFormatT::VoicedataFormatOpus => "VOICEDATA_FORMAT_OPUS",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "VOICEDATA_FORMAT_STEAM" => Some(Self::VoicedataFormatSteam),
            "VOICEDATA_FORMAT_ENGINE" => Some(Self::VoicedataFormatEngine),
            "VOICEDATA_FORMAT_OPUS" => Some(Self::VoicedataFormatOpus),
            _ => None,
        }
    }
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum RequestPauseT {
    RpPause = 0,
    RpUnpause = 1,
    RpTogglepause = 2,
}
impl RequestPauseT {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic
    /// use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            RequestPauseT::RpPause => "RP_PAUSE",
            RequestPauseT::RpUnpause => "RP_UNPAUSE",
            RequestPauseT::RpTogglepause => "RP_TOGGLEPAUSE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "RP_PAUSE" => Some(Self::RpPause),
            "RP_UNPAUSE" => Some(Self::RpUnpause),
            "RP_TOGGLEPAUSE" => Some(Self::RpTogglepause),
            _ => None,
        }
    }
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum PrefetchType {
    PftSound = 0,
}
impl PrefetchType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic
    /// use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            PrefetchType::PftSound => "PFT_SOUND",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PFT_SOUND" => Some(Self::PftSound),
            _ => None,
        }
    }
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum ESplitScreenMessageType {
    MsgSplitscreenAdduser = 0,
    MsgSplitscreenRemoveuser = 1,
}
impl ESplitScreenMessageType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic
    /// use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ESplitScreenMessageType::MsgSplitscreenAdduser => "MSG_SPLITSCREEN_ADDUSER",
            ESplitScreenMessageType::MsgSplitscreenRemoveuser => "MSG_SPLITSCREEN_REMOVEUSER",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "MSG_SPLITSCREEN_ADDUSER" => Some(Self::MsgSplitscreenAdduser),
            "MSG_SPLITSCREEN_REMOVEUSER" => Some(Self::MsgSplitscreenRemoveuser),
            _ => None,
        }
    }
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum EQueryCvarValueStatus {
    ValueIntact = 0,
    CvarNotFound = 1,
    NotACvar = 2,
    CvarProtected = 3,
}
impl EQueryCvarValueStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic
    /// use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            EQueryCvarValueStatus::ValueIntact => "eQueryCvarValueStatus_ValueIntact",
            EQueryCvarValueStatus::CvarNotFound => "eQueryCvarValueStatus_CvarNotFound",
            EQueryCvarValueStatus::NotACvar => "eQueryCvarValueStatus_NotACvar",
            EQueryCvarValueStatus::CvarProtected => "eQueryCvarValueStatus_CvarProtected",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "eQueryCvarValueStatus_ValueIntact" => Some(Self::ValueIntact),
            "eQueryCvarValueStatus_CvarNotFound" => Some(Self::CvarNotFound),
            "eQueryCvarValueStatus_NotACvar" => Some(Self::NotACvar),
            "eQueryCvarValueStatus_CvarProtected" => Some(Self::CvarProtected),
            _ => None,
        }
    }
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum DialogType {
    DialogMsg = 0,
    DialogMenu = 1,
    DialogText = 2,
    DialogEntry = 3,
    DialogAskconnect = 4,
}
impl DialogType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic
    /// use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            DialogType::DialogMsg => "DIALOG_MSG",
            DialogType::DialogMenu => "DIALOG_MENU",
            DialogType::DialogText => "DIALOG_TEXT",
            DialogType::DialogEntry => "DIALOG_ENTRY",
            DialogType::DialogAskconnect => "DIALOG_ASKCONNECT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DIALOG_MSG" => Some(Self::DialogMsg),
            "DIALOG_MENU" => Some(Self::DialogMenu),
            "DIALOG_TEXT" => Some(Self::DialogText),
            "DIALOG_ENTRY" => Some(Self::DialogEntry),
            "DIALOG_ASKCONNECT" => Some(Self::DialogAskconnect),
            _ => None,
        }
    }
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum SvcMessagesLowFrequency {
    SvcDummy = 600,
}
impl SvcMessagesLowFrequency {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic
    /// use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            SvcMessagesLowFrequency::SvcDummy => "svc_dummy",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "svc_dummy" => Some(Self::SvcDummy),
            _ => None,
        }
    }
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum BidirectionalMessages {
    BiRebroadcastGameEvent = 16,
    BiRebroadcastSource = 17,
    BiGameEvent = 18,
}
impl BidirectionalMessages {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic
    /// use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            BidirectionalMessages::BiRebroadcastGameEvent => "bi_RebroadcastGameEvent",
            BidirectionalMessages::BiRebroadcastSource => "bi_RebroadcastSource",
            BidirectionalMessages::BiGameEvent => "bi_GameEvent",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "bi_RebroadcastGameEvent" => Some(Self::BiRebroadcastGameEvent),
            "bi_RebroadcastSource" => Some(Self::BiRebroadcastSource),
            "bi_GameEvent" => Some(Self::BiGameEvent),
            _ => None,
        }
    }
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum BidirectionalMessagesLowFrequency {
    BiRelayInfo = 700,
    BiRelayPacket = 701,
}
impl BidirectionalMessagesLowFrequency {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic
    /// use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            BidirectionalMessagesLowFrequency::BiRelayInfo => "bi_RelayInfo",
            BidirectionalMessagesLowFrequency::BiRelayPacket => "bi_RelayPacket",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "bi_RelayInfo" => Some(Self::BiRelayInfo),
            "bi_RelayPacket" => Some(Self::BiRelayPacket),
            _ => None,
        }
    }
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum ReplayEventTypeT {
    ReplayEventCancel = 0,
    ReplayEventDeath = 1,
    ReplayEventGeneric = 2,
    ReplayEventStuckNeedFullUpdate = 3,
    ReplayEventVictory = 4,
}
impl ReplayEventTypeT {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic
    /// use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ReplayEventTypeT::ReplayEventCancel => "REPLAY_EVENT_CANCEL",
            ReplayEventTypeT::ReplayEventDeath => "REPLAY_EVENT_DEATH",
            ReplayEventTypeT::ReplayEventGeneric => "REPLAY_EVENT_GENERIC",
            ReplayEventTypeT::ReplayEventStuckNeedFullUpdate => {
                "REPLAY_EVENT_STUCK_NEED_FULL_UPDATE"
            }
            ReplayEventTypeT::ReplayEventVictory => "REPLAY_EVENT_VICTORY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "REPLAY_EVENT_CANCEL" => Some(Self::ReplayEventCancel),
            "REPLAY_EVENT_DEATH" => Some(Self::ReplayEventDeath),
            "REPLAY_EVENT_GENERIC" => Some(Self::ReplayEventGeneric),
            "REPLAY_EVENT_STUCK_NEED_FULL_UPDATE" => Some(Self::ReplayEventStuckNeedFullUpdate),
            "REPLAY_EVENT_VICTORY" => Some(Self::ReplayEventVictory),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CUserMessageAchievementEvent {
    #[prost(uint32, optional, tag = "1")]
    pub achievement: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CUserMessageCloseCaption {
    #[prost(fixed32, optional, tag = "1")]
    pub hash: ::core::option::Option<u32>,
    #[prost(float, optional, tag = "2")]
    pub duration: ::core::option::Option<f32>,
    #[prost(bool, optional, tag = "3")]
    pub from_player: ::core::option::Option<bool>,
    #[prost(int32, optional, tag = "4", default = "-1")]
    pub ent_index: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CUserMessageCloseCaptionDirect {
    #[prost(fixed32, optional, tag = "1")]
    pub hash: ::core::option::Option<u32>,
    #[prost(float, optional, tag = "2")]
    pub duration: ::core::option::Option<f32>,
    #[prost(bool, optional, tag = "3")]
    pub from_player: ::core::option::Option<bool>,
    #[prost(int32, optional, tag = "4", default = "-1")]
    pub ent_index: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CUserMessageCloseCaptionPlaceholder {
    #[prost(string, optional, tag = "1")]
    pub string: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(float, optional, tag = "2")]
    pub duration: ::core::option::Option<f32>,
    #[prost(bool, optional, tag = "3")]
    pub from_player: ::core::option::Option<bool>,
    #[prost(int32, optional, tag = "4", default = "-1")]
    pub ent_index: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CUserMessageCurrentTimescale {
    #[prost(float, optional, tag = "1")]
    pub current: ::core::option::Option<f32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CUserMessageDesiredTimescale {
    #[prost(float, optional, tag = "1")]
    pub desired: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "2")]
    pub acceleration: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "3")]
    pub minblendrate: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "4")]
    pub blenddeltamultiplier: ::core::option::Option<f32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CUserMessageFade {
    #[prost(uint32, optional, tag = "1")]
    pub duration: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub hold_time: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub flags: ::core::option::Option<u32>,
    #[prost(fixed32, optional, tag = "4")]
    pub color: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CUserMessageShake {
    #[prost(uint32, optional, tag = "1")]
    pub command: ::core::option::Option<u32>,
    #[prost(float, optional, tag = "2")]
    pub amplitude: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "3")]
    pub frequency: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "4")]
    pub duration: ::core::option::Option<f32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CUserMessageShakeDir {
    #[prost(message, optional, tag = "1")]
    pub shake: ::core::option::Option<CUserMessageShake>,
    #[prost(message, optional, tag = "2")]
    pub direction: ::core::option::Option<CMsgVector>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CUserMessageWaterShake {
    #[prost(uint32, optional, tag = "1")]
    pub command: ::core::option::Option<u32>,
    #[prost(float, optional, tag = "2")]
    pub amplitude: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "3")]
    pub frequency: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "4")]
    pub duration: ::core::option::Option<f32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CUserMessageScreenTilt {
    #[prost(uint32, optional, tag = "1")]
    pub command: ::core::option::Option<u32>,
    #[prost(bool, optional, tag = "2")]
    pub ease_in_out: ::core::option::Option<bool>,
    #[prost(message, optional, tag = "3")]
    pub angle: ::core::option::Option<CMsgVector>,
    #[prost(float, optional, tag = "4")]
    pub duration: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "5")]
    pub time: ::core::option::Option<f32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CUserMessageSayText {
    #[prost(int32, optional, tag = "1", default = "-1")]
    pub playerindex: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "2")]
    pub text: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "3")]
    pub chat: ::core::option::Option<bool>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CUserMessageSayText2 {
    #[prost(int32, optional, tag = "1", default = "-1")]
    pub entityindex: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "2")]
    pub chat: ::core::option::Option<bool>,
    #[prost(string, optional, tag = "3")]
    pub messagename: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "4")]
    pub param1: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "5")]
    pub param2: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "6")]
    pub param3: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "7")]
    pub param4: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CUserMessageHudMsg {
    #[prost(uint32, optional, tag = "1")]
    pub channel: ::core::option::Option<u32>,
    #[prost(float, optional, tag = "2")]
    pub x: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "3")]
    pub y: ::core::option::Option<f32>,
    #[prost(fixed32, optional, tag = "4")]
    pub color1: ::core::option::Option<u32>,
    #[prost(fixed32, optional, tag = "5")]
    pub color2: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "6")]
    pub effect: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "11")]
    pub message: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CUserMessageHudText {
    #[prost(string, optional, tag = "1")]
    pub message: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CUserMessageTextMsg {
    #[prost(uint32, optional, tag = "1")]
    pub dest: ::core::option::Option<u32>,
    #[prost(string, repeated, tag = "2")]
    pub param: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CUserMessageGameTitle {}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CUserMessageResetHud {}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CUserMessageSendAudio {
    #[prost(string, optional, tag = "1")]
    pub soundname: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "2")]
    pub stop: ::core::option::Option<bool>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CUserMessageAudioParameter {
    #[prost(uint32, optional, tag = "1")]
    pub parameter_type: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub name_hash_code: ::core::option::Option<u32>,
    #[prost(float, optional, tag = "3")]
    pub value: ::core::option::Option<f32>,
    #[prost(uint32, optional, tag = "4")]
    pub int_value: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CUserMessageVoiceMask {
    #[prost(uint32, repeated, packed = "false", tag = "1")]
    pub gamerules_masks: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, packed = "false", tag = "2")]
    pub ban_masks: ::prost::alloc::vec::Vec<u32>,
    #[prost(bool, optional, tag = "3")]
    pub mod_enable: ::core::option::Option<bool>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CUserMessageRequestState {}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CUserMessageRumble {
    #[prost(int32, optional, tag = "1")]
    pub index: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub data: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub flags: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CUserMessageSayTextChannel {
    #[prost(int32, optional, tag = "1")]
    pub player: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub channel: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "3")]
    pub text: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CUserMessageColoredText {
    #[prost(uint32, optional, tag = "1")]
    pub color: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "2")]
    pub text: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "3")]
    pub reset: ::core::option::Option<bool>,
    #[prost(int32, optional, tag = "4", default = "-1")]
    pub context_player_slot: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "5")]
    pub context_value: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "6")]
    pub context_team_id: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CUserMessageItemPickup {
    #[prost(string, optional, tag = "1")]
    pub itemname: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CUserMessageAmmoDenied {
    #[prost(uint32, optional, tag = "1")]
    pub ammo_id: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CUserMessageShowMenu {
    #[prost(uint32, optional, tag = "1")]
    pub validslots: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub displaytime: ::core::option::Option<u32>,
    #[prost(bool, optional, tag = "3")]
    pub needmore: ::core::option::Option<bool>,
    #[prost(string, optional, tag = "4")]
    pub menustring: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CUserMessageCreditsMsg {
    #[prost(enumeration = "ERollType", optional, tag = "1", default = "RollNone")]
    pub rolltype: ::core::option::Option<i32>,
    #[prost(float, optional, tag = "2")]
    pub logo_length: ::core::option::Option<f32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CEntityMessagePlayJingle {
    #[prost(message, optional, tag = "1")]
    pub entity_msg: ::core::option::Option<CEntityMsg>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CEntityMessageScreenOverlay {
    #[prost(bool, optional, tag = "1")]
    pub start_effect: ::core::option::Option<bool>,
    #[prost(message, optional, tag = "2")]
    pub entity_msg: ::core::option::Option<CEntityMsg>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CEntityMessageRemoveAllDecals {
    #[prost(bool, optional, tag = "1")]
    pub remove_decals: ::core::option::Option<bool>,
    #[prost(message, optional, tag = "2")]
    pub entity_msg: ::core::option::Option<CEntityMsg>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CEntityMessagePropagateForce {
    #[prost(message, optional, tag = "1")]
    pub impulse: ::core::option::Option<CMsgVector>,
    #[prost(message, optional, tag = "2")]
    pub entity_msg: ::core::option::Option<CEntityMsg>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CEntityMessageDoSpark {
    #[prost(message, optional, tag = "1")]
    pub origin: ::core::option::Option<CMsgVector>,
    #[prost(int32, optional, tag = "2", default = "-1")]
    pub entityindex: ::core::option::Option<i32>,
    #[prost(float, optional, tag = "3")]
    pub radius: ::core::option::Option<f32>,
    #[prost(fixed32, optional, tag = "4")]
    pub color: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "5")]
    pub beams: ::core::option::Option<u32>,
    #[prost(float, optional, tag = "6")]
    pub thick: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "7")]
    pub duration: ::core::option::Option<f32>,
    #[prost(message, optional, tag = "8")]
    pub entity_msg: ::core::option::Option<CEntityMsg>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CEntityMessageFixAngle {
    #[prost(bool, optional, tag = "1")]
    pub relative: ::core::option::Option<bool>,
    #[prost(message, optional, tag = "2")]
    pub angle: ::core::option::Option<CMsgQAngle>,
    #[prost(message, optional, tag = "3")]
    pub entity_msg: ::core::option::Option<CEntityMsg>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CUserMessageCameraTransition {
    #[prost(uint32, optional, tag = "1")]
    pub camera_type: ::core::option::Option<u32>,
    #[prost(float, optional, tag = "2")]
    pub duration: ::core::option::Option<f32>,
    #[prost(message, optional, tag = "3")]
    pub params_data_driven:
        ::core::option::Option<c_user_message_camera_transition::TransitionDataDriven>,
}
/// Nested message and enum types in `CUserMessageCameraTransition`.
pub mod c_user_message_camera_transition {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TransitionDataDriven {
        #[prost(string, optional, tag = "1")]
        pub filename: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(int32, optional, tag = "2", default = "-1")]
        pub attach_ent_index: ::core::option::Option<i32>,
        #[prost(float, optional, tag = "3")]
        pub duration: ::core::option::Option<f32>,
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CUserMsgParticleManager {
    #[prost(
        enumeration = "ParticleMessage",
        required,
        tag = "1",
        default = "GameParticleManagerEventCreate"
    )]
    pub r#type: i32,
    #[prost(uint32, required, tag = "2")]
    pub index: u32,
    #[prost(message, optional, tag = "3")]
    pub release_particle_index:
        ::core::option::Option<c_user_msg_particle_manager::ReleaseParticleIndex>,
    #[prost(message, optional, tag = "4")]
    pub create_particle: ::core::option::Option<c_user_msg_particle_manager::CreateParticle>,
    #[prost(message, optional, tag = "5")]
    pub destroy_particle: ::core::option::Option<c_user_msg_particle_manager::DestroyParticle>,
    #[prost(message, optional, tag = "6")]
    pub destroy_particle_involving:
        ::core::option::Option<c_user_msg_particle_manager::DestroyParticleInvolving>,
    #[prost(message, optional, tag = "7")]
    pub update_particle:
        ::core::option::Option<c_user_msg_particle_manager::UpdateParticleObsolete>,
    #[prost(message, optional, tag = "8")]
    pub update_particle_fwd:
        ::core::option::Option<c_user_msg_particle_manager::UpdateParticleFwdObsolete>,
    #[prost(message, optional, tag = "9")]
    pub update_particle_orient:
        ::core::option::Option<c_user_msg_particle_manager::UpdateParticleOrientObsolete>,
    #[prost(message, optional, tag = "10")]
    pub update_particle_fallback:
        ::core::option::Option<c_user_msg_particle_manager::UpdateParticleFallback>,
    #[prost(message, optional, tag = "11")]
    pub update_particle_offset:
        ::core::option::Option<c_user_msg_particle_manager::UpdateParticleOffset>,
    #[prost(message, optional, tag = "12")]
    pub update_particle_ent: ::core::option::Option<c_user_msg_particle_manager::UpdateParticleEnt>,
    #[prost(message, optional, tag = "14")]
    pub update_particle_should_draw:
        ::core::option::Option<c_user_msg_particle_manager::UpdateParticleShouldDraw>,
    #[prost(message, optional, tag = "15")]
    pub update_particle_set_frozen:
        ::core::option::Option<c_user_msg_particle_manager::UpdateParticleSetFrozen>,
    #[prost(message, optional, tag = "16")]
    pub change_control_point_attachment:
        ::core::option::Option<c_user_msg_particle_manager::ChangeControlPointAttachment>,
    #[prost(message, optional, tag = "17")]
    pub update_entity_position:
        ::core::option::Option<c_user_msg_particle_manager::UpdateEntityPosition>,
    #[prost(message, optional, tag = "18")]
    pub set_particle_fow_properties:
        ::core::option::Option<c_user_msg_particle_manager::SetParticleFoWProperties>,
    #[prost(message, optional, tag = "19")]
    pub set_particle_text: ::core::option::Option<c_user_msg_particle_manager::SetParticleText>,
    #[prost(message, optional, tag = "20")]
    pub set_particle_should_check_fow:
        ::core::option::Option<c_user_msg_particle_manager::SetParticleShouldCheckFoW>,
    #[prost(message, optional, tag = "21")]
    pub set_control_point_model:
        ::core::option::Option<c_user_msg_particle_manager::SetControlPointModel>,
    #[prost(message, optional, tag = "22")]
    pub set_control_point_snapshot:
        ::core::option::Option<c_user_msg_particle_manager::SetControlPointSnapshot>,
    #[prost(message, optional, tag = "23")]
    pub set_texture_attribute:
        ::core::option::Option<c_user_msg_particle_manager::SetTextureAttribute>,
    #[prost(message, optional, tag = "24")]
    pub set_scene_object_generic_flag:
        ::core::option::Option<c_user_msg_particle_manager::SetSceneObjectGenericFlag>,
    #[prost(message, optional, tag = "25")]
    pub set_scene_object_tint_and_desat:
        ::core::option::Option<c_user_msg_particle_manager::SetSceneObjectTintAndDesat>,
    #[prost(message, optional, tag = "26")]
    pub destroy_particle_named:
        ::core::option::Option<c_user_msg_particle_manager::DestroyParticleNamed>,
    #[prost(message, optional, tag = "27")]
    pub particle_skip_to_time:
        ::core::option::Option<c_user_msg_particle_manager::ParticleSkipToTime>,
    #[prost(message, optional, tag = "28")]
    pub particle_can_freeze: ::core::option::Option<c_user_msg_particle_manager::ParticleCanFreeze>,
    #[prost(message, optional, tag = "29")]
    pub set_named_value_context:
        ::core::option::Option<c_user_msg_particle_manager::SetParticleNamedValueContext>,
    #[prost(message, optional, tag = "30")]
    pub update_particle_transform:
        ::core::option::Option<c_user_msg_particle_manager::UpdateParticleTransform>,
    #[prost(message, optional, tag = "31")]
    pub particle_freeze_transition_override:
        ::core::option::Option<c_user_msg_particle_manager::ParticleFreezeTransitionOverride>,
    #[prost(message, optional, tag = "32")]
    pub freeze_particle_involving:
        ::core::option::Option<c_user_msg_particle_manager::FreezeParticleInvolving>,
    #[prost(message, optional, tag = "33")]
    pub add_modellist_override_element:
        ::core::option::Option<c_user_msg_particle_manager::AddModellistOverrideElement>,
    #[prost(message, optional, tag = "34")]
    pub clear_modellist_override:
        ::core::option::Option<c_user_msg_particle_manager::ClearModellistOverride>,
    #[prost(message, optional, tag = "35")]
    pub create_physics_sim: ::core::option::Option<c_user_msg_particle_manager::CreatePhysicsSim>,
    #[prost(message, optional, tag = "36")]
    pub destroy_physics_sim: ::core::option::Option<c_user_msg_particle_manager::DestroyPhysicsSim>,
    #[prost(message, optional, tag = "37")]
    pub set_vdata: ::core::option::Option<c_user_msg_particle_manager::SetVData>,
    #[prost(message, optional, tag = "38")]
    pub set_material_override:
        ::core::option::Option<c_user_msg_particle_manager::SetMaterialOverride>,
}
/// Nested message and enum types in `CUserMsg_ParticleManager`.
pub mod c_user_msg_particle_manager {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct ReleaseParticleIndex {}
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CreateParticle {
        #[prost(fixed64, optional, tag = "1")]
        pub particle_name_index: ::core::option::Option<u64>,
        #[prost(int32, optional, tag = "2")]
        pub attach_type: ::core::option::Option<i32>,
        #[prost(uint32, optional, tag = "3", default = "16777215")]
        pub entity_handle: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "4", default = "16777215")]
        pub entity_handle_for_modifiers: ::core::option::Option<u32>,
        #[prost(bool, optional, tag = "5")]
        pub apply_voice_ban_rules: ::core::option::Option<bool>,
        #[prost(int32, optional, tag = "6")]
        pub team_behavior: ::core::option::Option<i32>,
        #[prost(string, optional, tag = "7")]
        pub control_point_configuration: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(bool, optional, tag = "8")]
        pub cluster: ::core::option::Option<bool>,
        #[prost(float, optional, tag = "9")]
        pub endcap_time: ::core::option::Option<f32>,
        #[prost(message, optional, tag = "10")]
        pub aggregation_position: ::core::option::Option<super::CMsgVector>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct DestroyParticle {
        #[prost(bool, optional, tag = "1")]
        pub destroy_immediately: ::core::option::Option<bool>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct DestroyParticleInvolving {
        #[prost(bool, optional, tag = "1")]
        pub destroy_immediately: ::core::option::Option<bool>,
        #[prost(uint32, optional, tag = "3", default = "16777215")]
        pub entity_handle: ::core::option::Option<u32>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct DestroyParticleNamed {
        #[prost(fixed64, optional, tag = "1")]
        pub particle_name_index: ::core::option::Option<u64>,
        #[prost(uint32, optional, tag = "2", default = "16777215")]
        pub entity_handle: ::core::option::Option<u32>,
        #[prost(bool, optional, tag = "3")]
        pub destroy_immediately: ::core::option::Option<bool>,
        #[prost(bool, optional, tag = "4")]
        pub play_endcap: ::core::option::Option<bool>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct UpdateParticleObsolete {
        #[prost(int32, optional, tag = "1")]
        pub control_point: ::core::option::Option<i32>,
        #[prost(message, optional, tag = "2")]
        pub position: ::core::option::Option<super::CMsgVector>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct UpdateParticleFwdObsolete {
        #[prost(int32, optional, tag = "1")]
        pub control_point: ::core::option::Option<i32>,
        #[prost(message, optional, tag = "2")]
        pub forward: ::core::option::Option<super::CMsgVector>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct UpdateParticleOrientObsolete {
        #[prost(int32, optional, tag = "1")]
        pub control_point: ::core::option::Option<i32>,
        #[prost(message, optional, tag = "2")]
        pub forward: ::core::option::Option<super::CMsgVector>,
        #[prost(message, optional, tag = "3")]
        pub deprecated_right: ::core::option::Option<super::CMsgVector>,
        #[prost(message, optional, tag = "4")]
        pub up: ::core::option::Option<super::CMsgVector>,
        #[prost(message, optional, tag = "5")]
        pub left: ::core::option::Option<super::CMsgVector>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct UpdateParticleTransform {
        #[prost(int32, optional, tag = "1")]
        pub control_point: ::core::option::Option<i32>,
        #[prost(message, optional, tag = "2")]
        pub position: ::core::option::Option<super::CMsgVector>,
        #[prost(message, optional, tag = "3")]
        pub orientation: ::core::option::Option<super::CMsgQuaternion>,
        #[prost(float, optional, tag = "4")]
        pub interpolation_interval: ::core::option::Option<f32>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct UpdateParticleFallback {
        #[prost(int32, optional, tag = "1")]
        pub control_point: ::core::option::Option<i32>,
        #[prost(message, optional, tag = "2")]
        pub position: ::core::option::Option<super::CMsgVector>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct UpdateParticleOffset {
        #[prost(int32, optional, tag = "1")]
        pub control_point: ::core::option::Option<i32>,
        #[prost(message, optional, tag = "2")]
        pub origin_offset: ::core::option::Option<super::CMsgVector>,
        #[prost(message, optional, tag = "3")]
        pub angle_offset: ::core::option::Option<super::CMsgQAngle>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct UpdateParticleEnt {
        #[prost(int32, optional, tag = "1")]
        pub control_point: ::core::option::Option<i32>,
        #[prost(uint32, optional, tag = "2", default = "16777215")]
        pub entity_handle: ::core::option::Option<u32>,
        #[prost(int32, optional, tag = "3")]
        pub attach_type: ::core::option::Option<i32>,
        #[prost(int32, optional, tag = "4")]
        pub attachment: ::core::option::Option<i32>,
        #[prost(message, optional, tag = "5")]
        pub fallback_position: ::core::option::Option<super::CMsgVector>,
        #[prost(bool, optional, tag = "6")]
        pub include_wearables: ::core::option::Option<bool>,
        #[prost(message, optional, tag = "7")]
        pub offset_position: ::core::option::Option<super::CMsgVector>,
        #[prost(message, optional, tag = "8")]
        pub offset_angles: ::core::option::Option<super::CMsgQAngle>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct UpdateParticleSetFrozen {
        #[prost(bool, optional, tag = "1")]
        pub set_frozen: ::core::option::Option<bool>,
        #[prost(float, optional, tag = "2")]
        pub transition_duration: ::core::option::Option<f32>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct UpdateParticleShouldDraw {
        #[prost(bool, optional, tag = "1")]
        pub should_draw: ::core::option::Option<bool>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct ChangeControlPointAttachment {
        #[prost(int32, optional, tag = "1")]
        pub attachment_old: ::core::option::Option<i32>,
        #[prost(int32, optional, tag = "2")]
        pub attachment_new: ::core::option::Option<i32>,
        #[prost(uint32, optional, tag = "3", default = "16777215")]
        pub entity_handle: ::core::option::Option<u32>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct UpdateEntityPosition {
        #[prost(uint32, optional, tag = "1", default = "16777215")]
        pub entity_handle: ::core::option::Option<u32>,
        #[prost(message, optional, tag = "2")]
        pub position: ::core::option::Option<super::CMsgVector>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct SetParticleFoWProperties {
        #[prost(int32, optional, tag = "1")]
        pub fow_control_point: ::core::option::Option<i32>,
        #[prost(int32, optional, tag = "2")]
        pub fow_control_point2: ::core::option::Option<i32>,
        #[prost(float, optional, tag = "3")]
        pub fow_radius: ::core::option::Option<f32>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct SetParticleShouldCheckFoW {
        #[prost(bool, optional, tag = "1")]
        pub check_fow: ::core::option::Option<bool>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SetControlPointModel {
        #[prost(int32, optional, tag = "1")]
        pub control_point: ::core::option::Option<i32>,
        #[prost(string, optional, tag = "2")]
        pub model_name: ::core::option::Option<::prost::alloc::string::String>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SetControlPointSnapshot {
        #[prost(int32, optional, tag = "1")]
        pub control_point: ::core::option::Option<i32>,
        #[prost(string, optional, tag = "2")]
        pub snapshot_name: ::core::option::Option<::prost::alloc::string::String>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SetParticleText {
        #[prost(string, optional, tag = "1")]
        pub text: ::core::option::Option<::prost::alloc::string::String>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SetTextureAttribute {
        #[prost(string, optional, tag = "1")]
        pub attribute_name: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag = "2")]
        pub texture_name: ::core::option::Option<::prost::alloc::string::String>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct SetSceneObjectGenericFlag {
        #[prost(bool, optional, tag = "1")]
        pub flag_value: ::core::option::Option<bool>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct SetSceneObjectTintAndDesat {
        #[prost(fixed32, optional, tag = "1")]
        pub tint: ::core::option::Option<u32>,
        #[prost(float, optional, tag = "2")]
        pub desat: ::core::option::Option<f32>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct ParticleSkipToTime {
        #[prost(float, optional, tag = "1")]
        pub skip_to_time: ::core::option::Option<f32>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct ParticleCanFreeze {
        #[prost(bool, optional, tag = "1")]
        pub can_freeze: ::core::option::Option<bool>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct ParticleFreezeTransitionOverride {
        #[prost(float, optional, tag = "1")]
        pub freeze_transition_override: ::core::option::Option<f32>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct FreezeParticleInvolving {
        #[prost(bool, optional, tag = "1")]
        pub set_frozen: ::core::option::Option<bool>,
        #[prost(float, optional, tag = "2")]
        pub transition_duration: ::core::option::Option<f32>,
        #[prost(uint32, optional, tag = "3", default = "16777215")]
        pub entity_handle: ::core::option::Option<u32>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AddModellistOverrideElement {
        #[prost(string, optional, tag = "1")]
        pub model_name: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(float, optional, tag = "2")]
        pub spawn_probability: ::core::option::Option<f32>,
        #[prost(uint32, optional, tag = "3")]
        pub groupid: ::core::option::Option<u32>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct ClearModellistOverride {
        #[prost(uint32, optional, tag = "1")]
        pub groupid: ::core::option::Option<u32>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SetParticleNamedValueContext {
        #[prost(message, repeated, tag = "1")]
        pub float_values:
            ::prost::alloc::vec::Vec<set_particle_named_value_context::FloatContextValue>,
        #[prost(message, repeated, tag = "2")]
        pub vector_values:
            ::prost::alloc::vec::Vec<set_particle_named_value_context::VectorContextValue>,
        #[prost(message, repeated, tag = "3")]
        pub transform_values:
            ::prost::alloc::vec::Vec<set_particle_named_value_context::TransformContextValue>,
        #[prost(message, repeated, tag = "4")]
        pub ehandle_values:
            ::prost::alloc::vec::Vec<set_particle_named_value_context::EHandleContext>,
    }
    /// Nested message and enum types in `SetParticleNamedValueContext`.
    pub mod set_particle_named_value_context {
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct FloatContextValue {
            #[prost(uint32, optional, tag = "1")]
            pub value_name_hash: ::core::option::Option<u32>,
            #[prost(float, optional, tag = "2")]
            pub value: ::core::option::Option<f32>,
        }
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct VectorContextValue {
            #[prost(uint32, optional, tag = "1")]
            pub value_name_hash: ::core::option::Option<u32>,
            #[prost(message, optional, tag = "2")]
            pub value: ::core::option::Option<super::super::CMsgVector>,
        }
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct TransformContextValue {
            #[prost(uint32, optional, tag = "1")]
            pub value_name_hash: ::core::option::Option<u32>,
            #[prost(message, optional, tag = "2")]
            pub angles: ::core::option::Option<super::super::CMsgQAngle>,
            #[prost(message, optional, tag = "3")]
            pub translation: ::core::option::Option<super::super::CMsgVector>,
        }
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct EHandleContext {
            #[prost(uint32, optional, tag = "1")]
            pub value_name_hash: ::core::option::Option<u32>,
            #[prost(uint32, optional, tag = "2", default = "16777215")]
            pub ent_index: ::core::option::Option<u32>,
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CreatePhysicsSim {
        #[prost(string, optional, tag = "1")]
        pub prop_group_name: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(bool, optional, tag = "2")]
        pub use_high_quality_simulation: ::core::option::Option<bool>,
        #[prost(uint32, optional, tag = "3")]
        pub max_particle_count: ::core::option::Option<u32>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct DestroyPhysicsSim {}
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SetVData {
        #[prost(string, optional, tag = "1")]
        pub vdata_name: ::core::option::Option<::prost::alloc::string::String>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SetMaterialOverride {
        #[prost(string, optional, tag = "1")]
        pub material_name: ::core::option::Option<::prost::alloc::string::String>,
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CUserMsgHudError {
    #[prost(int32, optional, tag = "1")]
    pub order_id: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CUserMsgCustomGameEvent {
    #[prost(string, optional, tag = "1")]
    pub event_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bytes = "vec", optional, tag = "2")]
    pub data: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CUserMessageHapticsManagerPulse {
    #[prost(int32, optional, tag = "1")]
    pub hand_id: ::core::option::Option<i32>,
    #[prost(float, optional, tag = "2")]
    pub effect_amplitude: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "3")]
    pub effect_frequency: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "4")]
    pub effect_duration: ::core::option::Option<f32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CUserMessageHapticsManagerEffect {
    #[prost(int32, optional, tag = "1")]
    pub hand_id: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "2")]
    pub effect_name_hash_code: ::core::option::Option<u32>,
    #[prost(float, optional, tag = "3")]
    pub effect_scale: ::core::option::Option<f32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CUserMessageAnimStateGraphState {
    #[prost(int32, optional, tag = "1")]
    pub entity_index: ::core::option::Option<i32>,
    #[prost(bytes = "vec", optional, tag = "2")]
    pub data: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CUserMessageUpdateCssClasses {
    #[prost(int32, optional, tag = "1")]
    pub target_world_panel: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "2")]
    pub css_classes: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "3")]
    pub is_add: ::core::option::Option<bool>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CUserMessageServerFrameTime {
    #[prost(float, optional, tag = "1")]
    pub frame_time: ::core::option::Option<f32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CUserMessageLagCompensationError {
    #[prost(float, optional, tag = "1")]
    pub distance: ::core::option::Option<f32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CUserMessageRequestDllStatus {
    #[prost(string, optional, tag = "1")]
    pub dll_action: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "2")]
    pub full_report: ::core::option::Option<bool>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CUserMessageRequestUtilAction {
    #[prost(int32, optional, tag = "2")]
    pub util1: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub util2: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "4")]
    pub util3: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "5")]
    pub util4: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "6")]
    pub util5: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CUserMessageUtilMsgResponse {
    #[prost(fixed32, optional, tag = "1")]
    pub crc: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "2")]
    pub item_count: ::core::option::Option<i32>,
    #[prost(fixed32, optional, tag = "3")]
    pub crc2: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "4")]
    pub item_count2: ::core::option::Option<i32>,
    #[prost(int32, repeated, packed = "false", tag = "5")]
    pub crc_part: ::prost::alloc::vec::Vec<i32>,
    #[prost(int32, repeated, packed = "false", tag = "6")]
    pub crc_part2: ::prost::alloc::vec::Vec<i32>,
    #[prost(int32, optional, tag = "7")]
    pub client_timestamp: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "8")]
    pub platform: ::core::option::Option<i32>,
    #[prost(message, repeated, tag = "9")]
    pub itemdetails: ::prost::alloc::vec::Vec<c_user_message_util_msg_response::ItemDetail>,
    #[prost(int32, optional, tag = "10")]
    pub itemgroup: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "11")]
    pub total_count: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "12")]
    pub total_count2: ::core::option::Option<i32>,
}
/// Nested message and enum types in `CUserMessage_UtilMsg_Response`.
pub mod c_user_message_util_msg_response {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ItemDetail {
        #[prost(int32, optional, tag = "1")]
        pub index: ::core::option::Option<i32>,
        #[prost(int32, optional, tag = "2")]
        pub hash: ::core::option::Option<i32>,
        #[prost(int32, optional, tag = "3")]
        pub crc: ::core::option::Option<i32>,
        #[prost(string, optional, tag = "4")]
        pub name: ::core::option::Option<::prost::alloc::string::String>,
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CUserMessageDllStatus {
    #[prost(string, optional, tag = "1")]
    pub file_report: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "2")]
    pub command_line: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "3")]
    pub total_files: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub process_id: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "5")]
    pub osversion: ::core::option::Option<i32>,
    #[prost(uint64, optional, tag = "6")]
    pub client_time: ::core::option::Option<u64>,
    #[prost(message, repeated, tag = "7")]
    pub diagnostics: ::prost::alloc::vec::Vec<c_user_message_dll_status::CvDiagnostic>,
    #[prost(message, repeated, tag = "8")]
    pub modules: ::prost::alloc::vec::Vec<c_user_message_dll_status::CModule>,
}
/// Nested message and enum types in `CUserMessage_DllStatus`.
pub mod c_user_message_dll_status {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CvDiagnostic {
        #[prost(uint32, optional, tag = "1")]
        pub id: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "2")]
        pub extended: ::core::option::Option<u32>,
        #[prost(uint64, optional, tag = "3")]
        pub value: ::core::option::Option<u64>,
        #[prost(string, optional, tag = "4")]
        pub string_value: ::core::option::Option<::prost::alloc::string::String>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CModule {
        #[prost(uint64, optional, tag = "1")]
        pub base_addr: ::core::option::Option<u64>,
        #[prost(string, optional, tag = "2")]
        pub name: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(uint32, optional, tag = "3")]
        pub size: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "4")]
        pub timestamp: ::core::option::Option<u32>,
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CUserMessageRequestInventory {
    #[prost(int32, optional, tag = "1")]
    pub inventory: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub offset: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub options: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CUserMessageInventoryResponse {
    #[prost(fixed32, optional, tag = "1")]
    pub crc: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "2")]
    pub item_count: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "5")]
    pub osversion: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "6")]
    pub perf_time: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "7")]
    pub client_timestamp: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "8")]
    pub platform: ::core::option::Option<i32>,
    #[prost(message, repeated, tag = "9")]
    pub inventories: ::prost::alloc::vec::Vec<c_user_message_inventory_response::InventoryDetail>,
    #[prost(message, repeated, tag = "10")]
    pub inventories2: ::prost::alloc::vec::Vec<c_user_message_inventory_response::InventoryDetail>,
    #[prost(message, repeated, tag = "14")]
    pub inventories3: ::prost::alloc::vec::Vec<c_user_message_inventory_response::InventoryDetail>,
    #[prost(int32, optional, tag = "11")]
    pub inv_type: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "12")]
    pub build_version: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "13")]
    pub instance: ::core::option::Option<i32>,
    #[prost(int64, optional, tag = "15")]
    pub start_time: ::core::option::Option<i64>,
}
/// Nested message and enum types in `CUserMessage_Inventory_Response`.
pub mod c_user_message_inventory_response {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct InventoryDetail {
        #[prost(int32, optional, tag = "1")]
        pub index: ::core::option::Option<i32>,
        #[prost(int64, optional, tag = "2")]
        pub primary: ::core::option::Option<i64>,
        #[prost(int64, optional, tag = "3")]
        pub offset: ::core::option::Option<i64>,
        #[prost(int64, optional, tag = "4")]
        pub first: ::core::option::Option<i64>,
        #[prost(int64, optional, tag = "5")]
        pub base: ::core::option::Option<i64>,
        #[prost(string, optional, tag = "6")]
        pub name: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag = "7")]
        pub base_name: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(int32, optional, tag = "8")]
        pub base_detail: ::core::option::Option<i32>,
        #[prost(int32, optional, tag = "9")]
        pub base_time: ::core::option::Option<i32>,
        #[prost(int32, optional, tag = "10")]
        pub base_hash: ::core::option::Option<i32>,
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CUserMessageRequestDiagnostic {
    #[prost(message, repeated, tag = "1")]
    pub diagnostics: ::prost::alloc::vec::Vec<c_user_message_request_diagnostic::Diagnostic>,
}
/// Nested message and enum types in `CUserMessageRequestDiagnostic`.
pub mod c_user_message_request_diagnostic {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Diagnostic {
        #[prost(int32, optional, tag = "1")]
        pub index: ::core::option::Option<i32>,
        #[prost(int64, optional, tag = "2")]
        pub offset: ::core::option::Option<i64>,
        #[prost(int32, optional, tag = "3")]
        pub param: ::core::option::Option<i32>,
        #[prost(int32, optional, tag = "4")]
        pub length: ::core::option::Option<i32>,
        #[prost(int32, optional, tag = "5")]
        pub r#type: ::core::option::Option<i32>,
        #[prost(int64, optional, tag = "6")]
        pub base: ::core::option::Option<i64>,
        #[prost(int64, optional, tag = "7")]
        pub range: ::core::option::Option<i64>,
        #[prost(int64, optional, tag = "8")]
        pub extent: ::core::option::Option<i64>,
        #[prost(int64, optional, tag = "9")]
        pub detail: ::core::option::Option<i64>,
        #[prost(string, optional, tag = "10")]
        pub name: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag = "11")]
        pub alias: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(bytes = "vec", optional, tag = "12")]
        pub vardetail: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(int32, optional, tag = "13")]
        pub context: ::core::option::Option<i32>,
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CUserMessageDiagnosticResponse {
    #[prost(message, repeated, tag = "1")]
    pub diagnostics: ::prost::alloc::vec::Vec<c_user_message_diagnostic_response::Diagnostic>,
    #[prost(int32, optional, tag = "2")]
    pub build_version: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub instance: ::core::option::Option<i32>,
    #[prost(int64, optional, tag = "4")]
    pub start_time: ::core::option::Option<i64>,
    #[prost(int32, optional, tag = "5")]
    pub osversion: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "6")]
    pub platform: ::core::option::Option<i32>,
}
/// Nested message and enum types in `CUserMessage_Diagnostic_Response`.
pub mod c_user_message_diagnostic_response {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Diagnostic {
        #[prost(int32, optional, tag = "1")]
        pub index: ::core::option::Option<i32>,
        #[prost(int64, optional, tag = "2")]
        pub offset: ::core::option::Option<i64>,
        #[prost(int32, optional, tag = "3")]
        pub param: ::core::option::Option<i32>,
        #[prost(int32, optional, tag = "4")]
        pub length: ::core::option::Option<i32>,
        #[prost(bytes = "vec", optional, tag = "5")]
        pub detail: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(int64, optional, tag = "6")]
        pub base: ::core::option::Option<i64>,
        #[prost(int64, optional, tag = "7")]
        pub range: ::core::option::Option<i64>,
        #[prost(int32, optional, tag = "8")]
        pub r#type: ::core::option::Option<i32>,
        #[prost(string, optional, tag = "10")]
        pub name: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag = "11")]
        pub alias: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(bytes = "vec", optional, tag = "12")]
        pub backup: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(int32, optional, tag = "13")]
        pub context: ::core::option::Option<i32>,
        #[prost(int64, optional, tag = "14")]
        pub control: ::core::option::Option<i64>,
        #[prost(int64, optional, tag = "15")]
        pub augment: ::core::option::Option<i64>,
        #[prost(int64, optional, tag = "16")]
        pub placebo: ::core::option::Option<i64>,
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CUserMessageExtraUserData {
    #[prost(int32, optional, tag = "1")]
    pub item: ::core::option::Option<i32>,
    #[prost(int64, optional, tag = "2")]
    pub value1: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "3")]
    pub value2: ::core::option::Option<i64>,
    #[prost(bytes = "vec", repeated, tag = "4")]
    pub detail1: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes = "vec", repeated, tag = "5")]
    pub detail2: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CUserMessageNotifyResponseFound {
    #[prost(int32, optional, tag = "1", default = "-1")]
    pub ent_index: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "2")]
    pub rule_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3")]
    pub response_value: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "4")]
    pub response_concept: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "5")]
    pub criteria: ::prost::alloc::vec::Vec<c_user_message_notify_response_found::Criteria>,
    #[prost(uint32, repeated, tag = "6")]
    pub int_criteria_names: ::prost::alloc::vec::Vec<u32>,
    #[prost(int32, repeated, tag = "7")]
    pub int_criteria_values: ::prost::alloc::vec::Vec<i32>,
    #[prost(uint32, repeated, tag = "8")]
    pub float_criteria_names: ::prost::alloc::vec::Vec<u32>,
    #[prost(float, repeated, packed = "false", tag = "9")]
    pub float_criteria_values: ::prost::alloc::vec::Vec<f32>,
    #[prost(uint32, repeated, tag = "10")]
    pub symbol_criteria_names: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "11")]
    pub symbol_criteria_values: ::prost::alloc::vec::Vec<u32>,
    #[prost(int32, optional, tag = "12")]
    pub speak_result: ::core::option::Option<i32>,
}
/// Nested message and enum types in `CUserMessage_NotifyResponseFound`.
pub mod c_user_message_notify_response_found {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Criteria {
        #[prost(uint32, optional, tag = "1")]
        pub name_symbol: ::core::option::Option<u32>,
        #[prost(string, optional, tag = "2")]
        pub value: ::core::option::Option<::prost::alloc::string::String>,
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CUserMessagePlayResponseConditional {
    #[prost(int32, optional, tag = "1", default = "-1")]
    pub ent_index: ::core::option::Option<i32>,
    #[prost(int32, repeated, packed = "false", tag = "2")]
    pub player_slots: ::prost::alloc::vec::Vec<i32>,
    #[prost(string, optional, tag = "3")]
    pub response: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "4")]
    pub ent_origin: ::core::option::Option<CMsgVector>,
    #[prost(float, optional, tag = "5")]
    pub pre_delay: ::core::option::Option<f32>,
    #[prost(int32, optional, tag = "6")]
    pub mix_priority: ::core::option::Option<i32>,
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum EBaseUserMessages {
    UmAchievementEvent = 101,
    UmCloseCaption = 102,
    UmCloseCaptionDirect = 103,
    UmCurrentTimescale = 104,
    UmDesiredTimescale = 105,
    UmFade = 106,
    UmGameTitle = 107,
    UmHudMsg = 110,
    UmHudText = 111,
    UmColoredText = 113,
    UmRequestState = 114,
    UmResetHud = 115,
    UmRumble = 116,
    UmSayText = 117,
    UmSayText2 = 118,
    UmSayTextChannel = 119,
    UmShake = 120,
    UmShakeDir = 121,
    UmWaterShake = 122,
    UmTextMsg = 124,
    UmScreenTilt = 125,
    UmVoiceMask = 128,
    UmSendAudio = 130,
    UmItemPickup = 131,
    UmAmmoDenied = 132,
    UmShowMenu = 134,
    UmCreditsMsg = 135,
    UmCloseCaptionPlaceholder = 142,
    UmCameraTransition = 143,
    UmAudioParameter = 144,
    UmParticleManager = 145,
    UmHudError = 146,
    UmCustomGameEvent = 148,
    UmAnimGraphUpdate = 149,
    UmHapticsManagerPulse = 150,
    UmHapticsManagerEffect = 151,
    UmCommandQueueState = 152,
    UmUpdateCssClasses = 153,
    UmServerFrameTime = 154,
    UmLagCompensationError = 155,
    UmRequestDllStatus = 156,
    UmRequestUtilAction = 157,
    UmUtilActionResponse = 158,
    UmDllStatusResponse = 159,
    UmRequestInventory = 160,
    UmInventoryResponse = 161,
    UmRequestDiagnostic = 162,
    UmDiagnosticResponse = 163,
    UmExtraUserData = 164,
    UmNotifyResponseFound = 165,
    UmPlayResponseConditional = 166,
    UmMaxBase = 200,
}
impl EBaseUserMessages {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic
    /// use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            EBaseUserMessages::UmAchievementEvent => "UM_AchievementEvent",
            EBaseUserMessages::UmCloseCaption => "UM_CloseCaption",
            EBaseUserMessages::UmCloseCaptionDirect => "UM_CloseCaptionDirect",
            EBaseUserMessages::UmCurrentTimescale => "UM_CurrentTimescale",
            EBaseUserMessages::UmDesiredTimescale => "UM_DesiredTimescale",
            EBaseUserMessages::UmFade => "UM_Fade",
            EBaseUserMessages::UmGameTitle => "UM_GameTitle",
            EBaseUserMessages::UmHudMsg => "UM_HudMsg",
            EBaseUserMessages::UmHudText => "UM_HudText",
            EBaseUserMessages::UmColoredText => "UM_ColoredText",
            EBaseUserMessages::UmRequestState => "UM_RequestState",
            EBaseUserMessages::UmResetHud => "UM_ResetHUD",
            EBaseUserMessages::UmRumble => "UM_Rumble",
            EBaseUserMessages::UmSayText => "UM_SayText",
            EBaseUserMessages::UmSayText2 => "UM_SayText2",
            EBaseUserMessages::UmSayTextChannel => "UM_SayTextChannel",
            EBaseUserMessages::UmShake => "UM_Shake",
            EBaseUserMessages::UmShakeDir => "UM_ShakeDir",
            EBaseUserMessages::UmWaterShake => "UM_WaterShake",
            EBaseUserMessages::UmTextMsg => "UM_TextMsg",
            EBaseUserMessages::UmScreenTilt => "UM_ScreenTilt",
            EBaseUserMessages::UmVoiceMask => "UM_VoiceMask",
            EBaseUserMessages::UmSendAudio => "UM_SendAudio",
            EBaseUserMessages::UmItemPickup => "UM_ItemPickup",
            EBaseUserMessages::UmAmmoDenied => "UM_AmmoDenied",
            EBaseUserMessages::UmShowMenu => "UM_ShowMenu",
            EBaseUserMessages::UmCreditsMsg => "UM_CreditsMsg",
            EBaseUserMessages::UmCloseCaptionPlaceholder => "UM_CloseCaptionPlaceholder",
            EBaseUserMessages::UmCameraTransition => "UM_CameraTransition",
            EBaseUserMessages::UmAudioParameter => "UM_AudioParameter",
            EBaseUserMessages::UmParticleManager => "UM_ParticleManager",
            EBaseUserMessages::UmHudError => "UM_HudError",
            EBaseUserMessages::UmCustomGameEvent => "UM_CustomGameEvent",
            EBaseUserMessages::UmAnimGraphUpdate => "UM_AnimGraphUpdate",
            EBaseUserMessages::UmHapticsManagerPulse => "UM_HapticsManagerPulse",
            EBaseUserMessages::UmHapticsManagerEffect => "UM_HapticsManagerEffect",
            EBaseUserMessages::UmCommandQueueState => "UM_CommandQueueState",
            EBaseUserMessages::UmUpdateCssClasses => "UM_UpdateCssClasses",
            EBaseUserMessages::UmServerFrameTime => "UM_ServerFrameTime",
            EBaseUserMessages::UmLagCompensationError => "UM_LagCompensationError",
            EBaseUserMessages::UmRequestDllStatus => "UM_RequestDllStatus",
            EBaseUserMessages::UmRequestUtilAction => "UM_RequestUtilAction",
            EBaseUserMessages::UmUtilActionResponse => "UM_UtilActionResponse",
            EBaseUserMessages::UmDllStatusResponse => "UM_DllStatusResponse",
            EBaseUserMessages::UmRequestInventory => "UM_RequestInventory",
            EBaseUserMessages::UmInventoryResponse => "UM_InventoryResponse",
            EBaseUserMessages::UmRequestDiagnostic => "UM_RequestDiagnostic",
            EBaseUserMessages::UmDiagnosticResponse => "UM_DiagnosticResponse",
            EBaseUserMessages::UmExtraUserData => "UM_ExtraUserData",
            EBaseUserMessages::UmNotifyResponseFound => "UM_NotifyResponseFound",
            EBaseUserMessages::UmPlayResponseConditional => "UM_PlayResponseConditional",
            EBaseUserMessages::UmMaxBase => "UM_MAX_BASE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UM_AchievementEvent" => Some(Self::UmAchievementEvent),
            "UM_CloseCaption" => Some(Self::UmCloseCaption),
            "UM_CloseCaptionDirect" => Some(Self::UmCloseCaptionDirect),
            "UM_CurrentTimescale" => Some(Self::UmCurrentTimescale),
            "UM_DesiredTimescale" => Some(Self::UmDesiredTimescale),
            "UM_Fade" => Some(Self::UmFade),
            "UM_GameTitle" => Some(Self::UmGameTitle),
            "UM_HudMsg" => Some(Self::UmHudMsg),
            "UM_HudText" => Some(Self::UmHudText),
            "UM_ColoredText" => Some(Self::UmColoredText),
            "UM_RequestState" => Some(Self::UmRequestState),
            "UM_ResetHUD" => Some(Self::UmResetHud),
            "UM_Rumble" => Some(Self::UmRumble),
            "UM_SayText" => Some(Self::UmSayText),
            "UM_SayText2" => Some(Self::UmSayText2),
            "UM_SayTextChannel" => Some(Self::UmSayTextChannel),
            "UM_Shake" => Some(Self::UmShake),
            "UM_ShakeDir" => Some(Self::UmShakeDir),
            "UM_WaterShake" => Some(Self::UmWaterShake),
            "UM_TextMsg" => Some(Self::UmTextMsg),
            "UM_ScreenTilt" => Some(Self::UmScreenTilt),
            "UM_VoiceMask" => Some(Self::UmVoiceMask),
            "UM_SendAudio" => Some(Self::UmSendAudio),
            "UM_ItemPickup" => Some(Self::UmItemPickup),
            "UM_AmmoDenied" => Some(Self::UmAmmoDenied),
            "UM_ShowMenu" => Some(Self::UmShowMenu),
            "UM_CreditsMsg" => Some(Self::UmCreditsMsg),
            "UM_CloseCaptionPlaceholder" => Some(Self::UmCloseCaptionPlaceholder),
            "UM_CameraTransition" => Some(Self::UmCameraTransition),
            "UM_AudioParameter" => Some(Self::UmAudioParameter),
            "UM_ParticleManager" => Some(Self::UmParticleManager),
            "UM_HudError" => Some(Self::UmHudError),
            "UM_CustomGameEvent" => Some(Self::UmCustomGameEvent),
            "UM_AnimGraphUpdate" => Some(Self::UmAnimGraphUpdate),
            "UM_HapticsManagerPulse" => Some(Self::UmHapticsManagerPulse),
            "UM_HapticsManagerEffect" => Some(Self::UmHapticsManagerEffect),
            "UM_CommandQueueState" => Some(Self::UmCommandQueueState),
            "UM_UpdateCssClasses" => Some(Self::UmUpdateCssClasses),
            "UM_ServerFrameTime" => Some(Self::UmServerFrameTime),
            "UM_LagCompensationError" => Some(Self::UmLagCompensationError),
            "UM_RequestDllStatus" => Some(Self::UmRequestDllStatus),
            "UM_RequestUtilAction" => Some(Self::UmRequestUtilAction),
            "UM_UtilActionResponse" => Some(Self::UmUtilActionResponse),
            "UM_DllStatusResponse" => Some(Self::UmDllStatusResponse),
            "UM_RequestInventory" => Some(Self::UmRequestInventory),
            "UM_InventoryResponse" => Some(Self::UmInventoryResponse),
            "UM_RequestDiagnostic" => Some(Self::UmRequestDiagnostic),
            "UM_DiagnosticResponse" => Some(Self::UmDiagnosticResponse),
            "UM_ExtraUserData" => Some(Self::UmExtraUserData),
            "UM_NotifyResponseFound" => Some(Self::UmNotifyResponseFound),
            "UM_PlayResponseConditional" => Some(Self::UmPlayResponseConditional),
            "UM_MAX_BASE" => Some(Self::UmMaxBase),
            _ => None,
        }
    }
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum EBaseEntityMessages {
    EmPlayJingle = 136,
    EmScreenOverlay = 137,
    EmRemoveAllDecals = 138,
    EmPropagateForce = 139,
    EmDoSpark = 140,
    EmFixAngle = 141,
}
impl EBaseEntityMessages {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic
    /// use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            EBaseEntityMessages::EmPlayJingle => "EM_PlayJingle",
            EBaseEntityMessages::EmScreenOverlay => "EM_ScreenOverlay",
            EBaseEntityMessages::EmRemoveAllDecals => "EM_RemoveAllDecals",
            EBaseEntityMessages::EmPropagateForce => "EM_PropagateForce",
            EBaseEntityMessages::EmDoSpark => "EM_DoSpark",
            EBaseEntityMessages::EmFixAngle => "EM_FixAngle",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "EM_PlayJingle" => Some(Self::EmPlayJingle),
            "EM_ScreenOverlay" => Some(Self::EmScreenOverlay),
            "EM_RemoveAllDecals" => Some(Self::EmRemoveAllDecals),
            "EM_PropagateForce" => Some(Self::EmPropagateForce),
            "EM_DoSpark" => Some(Self::EmDoSpark),
            "EM_FixAngle" => Some(Self::EmFixAngle),
            _ => None,
        }
    }
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum ERollType {
    RollNone = -1,
    RollStats = 0,
    RollCredits = 1,
    RollLateJoinLogo = 2,
    RollOuttro = 3,
}
impl ERollType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic
    /// use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ERollType::RollNone => "ROLL_NONE",
            ERollType::RollStats => "ROLL_STATS",
            ERollType::RollCredits => "ROLL_CREDITS",
            ERollType::RollLateJoinLogo => "ROLL_LATE_JOIN_LOGO",
            ERollType::RollOuttro => "ROLL_OUTTRO",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ROLL_NONE" => Some(Self::RollNone),
            "ROLL_STATS" => Some(Self::RollStats),
            "ROLL_CREDITS" => Some(Self::RollCredits),
            "ROLL_LATE_JOIN_LOGO" => Some(Self::RollLateJoinLogo),
            "ROLL_OUTTRO" => Some(Self::RollOuttro),
            _ => None,
        }
    }
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum ParticleMessage {
    GameParticleManagerEventCreate = 0,
    GameParticleManagerEventUpdate = 1,
    GameParticleManagerEventUpdateForward = 2,
    GameParticleManagerEventUpdateOrientation = 3,
    GameParticleManagerEventUpdateFallback = 4,
    GameParticleManagerEventUpdateEnt = 5,
    GameParticleManagerEventUpdateOffset = 6,
    GameParticleManagerEventDestroy = 7,
    GameParticleManagerEventDestroyInvolving = 8,
    GameParticleManagerEventRelease = 9,
    GameParticleManagerEventLatency = 10,
    GameParticleManagerEventShouldDraw = 11,
    GameParticleManagerEventFrozen = 12,
    GameParticleManagerEventChangeControlPointAttachment = 13,
    GameParticleManagerEventUpdateEntityPosition = 14,
    GameParticleManagerEventSetFowProperties = 15,
    GameParticleManagerEventSetText = 16,
    GameParticleManagerEventSetShouldCheckFow = 17,
    GameParticleManagerEventSetControlPointModel = 18,
    GameParticleManagerEventSetControlPointSnapshot = 19,
    GameParticleManagerEventSetTextureAttribute = 20,
    GameParticleManagerEventSetSceneObjectGenericFlag = 21,
    GameParticleManagerEventSetSceneObjectTintAndDesat = 22,
    GameParticleManagerEventDestroyNamed = 23,
    GameParticleManagerEventSkipToTime = 24,
    GameParticleManagerEventCanFreeze = 25,
    GameParticleManagerEventSetNamedValueContext = 26,
    GameParticleManagerEventUpdateTransform = 27,
    GameParticleManagerEventFreezeTransitionOverride = 28,
    GameParticleManagerEventFreezeInvolving = 29,
    GameParticleManagerEventAddModellistOverrideElement = 30,
    GameParticleManagerEventClearModellistOverride = 31,
    GameParticleManagerEventCreatePhysicsSim = 32,
    GameParticleManagerEventDestroyPhysicsSim = 33,
    GameParticleManagerEventSetVdata = 34,
    GameParticleManagerEventSetMaterialOverride = 35,
}
impl ParticleMessage {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic
    /// use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ParticleMessage::GameParticleManagerEventCreate => "GAME_PARTICLE_MANAGER_EVENT_CREATE",
            ParticleMessage::GameParticleManagerEventUpdate => "GAME_PARTICLE_MANAGER_EVENT_UPDATE",
            ParticleMessage::GameParticleManagerEventUpdateForward => {
                "GAME_PARTICLE_MANAGER_EVENT_UPDATE_FORWARD"
            }
            ParticleMessage::GameParticleManagerEventUpdateOrientation => {
                "GAME_PARTICLE_MANAGER_EVENT_UPDATE_ORIENTATION"
            }
            ParticleMessage::GameParticleManagerEventUpdateFallback => {
                "GAME_PARTICLE_MANAGER_EVENT_UPDATE_FALLBACK"
            }
            ParticleMessage::GameParticleManagerEventUpdateEnt => {
                "GAME_PARTICLE_MANAGER_EVENT_UPDATE_ENT"
            }
            ParticleMessage::GameParticleManagerEventUpdateOffset => {
                "GAME_PARTICLE_MANAGER_EVENT_UPDATE_OFFSET"
            }
            ParticleMessage::GameParticleManagerEventDestroy => {
                "GAME_PARTICLE_MANAGER_EVENT_DESTROY"
            }
            ParticleMessage::GameParticleManagerEventDestroyInvolving => {
                "GAME_PARTICLE_MANAGER_EVENT_DESTROY_INVOLVING"
            }
            ParticleMessage::GameParticleManagerEventRelease => {
                "GAME_PARTICLE_MANAGER_EVENT_RELEASE"
            }
            ParticleMessage::GameParticleManagerEventLatency => {
                "GAME_PARTICLE_MANAGER_EVENT_LATENCY"
            }
            ParticleMessage::GameParticleManagerEventShouldDraw => {
                "GAME_PARTICLE_MANAGER_EVENT_SHOULD_DRAW"
            }
            ParticleMessage::GameParticleManagerEventFrozen => "GAME_PARTICLE_MANAGER_EVENT_FROZEN",
            ParticleMessage::GameParticleManagerEventChangeControlPointAttachment => {
                "GAME_PARTICLE_MANAGER_EVENT_CHANGE_CONTROL_POINT_ATTACHMENT"
            }
            ParticleMessage::GameParticleManagerEventUpdateEntityPosition => {
                "GAME_PARTICLE_MANAGER_EVENT_UPDATE_ENTITY_POSITION"
            }
            ParticleMessage::GameParticleManagerEventSetFowProperties => {
                "GAME_PARTICLE_MANAGER_EVENT_SET_FOW_PROPERTIES"
            }
            ParticleMessage::GameParticleManagerEventSetText => {
                "GAME_PARTICLE_MANAGER_EVENT_SET_TEXT"
            }
            ParticleMessage::GameParticleManagerEventSetShouldCheckFow => {
                "GAME_PARTICLE_MANAGER_EVENT_SET_SHOULD_CHECK_FOW"
            }
            ParticleMessage::GameParticleManagerEventSetControlPointModel => {
                "GAME_PARTICLE_MANAGER_EVENT_SET_CONTROL_POINT_MODEL"
            }
            ParticleMessage::GameParticleManagerEventSetControlPointSnapshot => {
                "GAME_PARTICLE_MANAGER_EVENT_SET_CONTROL_POINT_SNAPSHOT"
            }
            ParticleMessage::GameParticleManagerEventSetTextureAttribute => {
                "GAME_PARTICLE_MANAGER_EVENT_SET_TEXTURE_ATTRIBUTE"
            }
            ParticleMessage::GameParticleManagerEventSetSceneObjectGenericFlag => {
                "GAME_PARTICLE_MANAGER_EVENT_SET_SCENE_OBJECT_GENERIC_FLAG"
            }
            ParticleMessage::GameParticleManagerEventSetSceneObjectTintAndDesat => {
                "GAME_PARTICLE_MANAGER_EVENT_SET_SCENE_OBJECT_TINT_AND_DESAT"
            }
            ParticleMessage::GameParticleManagerEventDestroyNamed => {
                "GAME_PARTICLE_MANAGER_EVENT_DESTROY_NAMED"
            }
            ParticleMessage::GameParticleManagerEventSkipToTime => {
                "GAME_PARTICLE_MANAGER_EVENT_SKIP_TO_TIME"
            }
            ParticleMessage::GameParticleManagerEventCanFreeze => {
                "GAME_PARTICLE_MANAGER_EVENT_CAN_FREEZE"
            }
            ParticleMessage::GameParticleManagerEventSetNamedValueContext => {
                "GAME_PARTICLE_MANAGER_EVENT_SET_NAMED_VALUE_CONTEXT"
            }
            ParticleMessage::GameParticleManagerEventUpdateTransform => {
                "GAME_PARTICLE_MANAGER_EVENT_UPDATE_TRANSFORM"
            }
            ParticleMessage::GameParticleManagerEventFreezeTransitionOverride => {
                "GAME_PARTICLE_MANAGER_EVENT_FREEZE_TRANSITION_OVERRIDE"
            }
            ParticleMessage::GameParticleManagerEventFreezeInvolving => {
                "GAME_PARTICLE_MANAGER_EVENT_FREEZE_INVOLVING"
            }
            ParticleMessage::GameParticleManagerEventAddModellistOverrideElement => {
                "GAME_PARTICLE_MANAGER_EVENT_ADD_MODELLIST_OVERRIDE_ELEMENT"
            }
            ParticleMessage::GameParticleManagerEventClearModellistOverride => {
                "GAME_PARTICLE_MANAGER_EVENT_CLEAR_MODELLIST_OVERRIDE"
            }
            ParticleMessage::GameParticleManagerEventCreatePhysicsSim => {
                "GAME_PARTICLE_MANAGER_EVENT_CREATE_PHYSICS_SIM"
            }
            ParticleMessage::GameParticleManagerEventDestroyPhysicsSim => {
                "GAME_PARTICLE_MANAGER_EVENT_DESTROY_PHYSICS_SIM"
            }
            ParticleMessage::GameParticleManagerEventSetVdata => {
                "GAME_PARTICLE_MANAGER_EVENT_SET_VDATA"
            }
            ParticleMessage::GameParticleManagerEventSetMaterialOverride => {
                "GAME_PARTICLE_MANAGER_EVENT_SET_MATERIAL_OVERRIDE"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "GAME_PARTICLE_MANAGER_EVENT_CREATE" => Some(Self::GameParticleManagerEventCreate),
            "GAME_PARTICLE_MANAGER_EVENT_UPDATE" => Some(Self::GameParticleManagerEventUpdate),
            "GAME_PARTICLE_MANAGER_EVENT_UPDATE_FORWARD" => {
                Some(Self::GameParticleManagerEventUpdateForward)
            }
            "GAME_PARTICLE_MANAGER_EVENT_UPDATE_ORIENTATION" => {
                Some(Self::GameParticleManagerEventUpdateOrientation)
            }
            "GAME_PARTICLE_MANAGER_EVENT_UPDATE_FALLBACK" => {
                Some(Self::GameParticleManagerEventUpdateFallback)
            }
            "GAME_PARTICLE_MANAGER_EVENT_UPDATE_ENT" => {
                Some(Self::GameParticleManagerEventUpdateEnt)
            }
            "GAME_PARTICLE_MANAGER_EVENT_UPDATE_OFFSET" => {
                Some(Self::GameParticleManagerEventUpdateOffset)
            }
            "GAME_PARTICLE_MANAGER_EVENT_DESTROY" => Some(Self::GameParticleManagerEventDestroy),
            "GAME_PARTICLE_MANAGER_EVENT_DESTROY_INVOLVING" => {
                Some(Self::GameParticleManagerEventDestroyInvolving)
            }
            "GAME_PARTICLE_MANAGER_EVENT_RELEASE" => Some(Self::GameParticleManagerEventRelease),
            "GAME_PARTICLE_MANAGER_EVENT_LATENCY" => Some(Self::GameParticleManagerEventLatency),
            "GAME_PARTICLE_MANAGER_EVENT_SHOULD_DRAW" => {
                Some(Self::GameParticleManagerEventShouldDraw)
            }
            "GAME_PARTICLE_MANAGER_EVENT_FROZEN" => Some(Self::GameParticleManagerEventFrozen),
            "GAME_PARTICLE_MANAGER_EVENT_CHANGE_CONTROL_POINT_ATTACHMENT" => {
                Some(Self::GameParticleManagerEventChangeControlPointAttachment)
            }
            "GAME_PARTICLE_MANAGER_EVENT_UPDATE_ENTITY_POSITION" => {
                Some(Self::GameParticleManagerEventUpdateEntityPosition)
            }
            "GAME_PARTICLE_MANAGER_EVENT_SET_FOW_PROPERTIES" => {
                Some(Self::GameParticleManagerEventSetFowProperties)
            }
            "GAME_PARTICLE_MANAGER_EVENT_SET_TEXT" => Some(Self::GameParticleManagerEventSetText),
            "GAME_PARTICLE_MANAGER_EVENT_SET_SHOULD_CHECK_FOW" => {
                Some(Self::GameParticleManagerEventSetShouldCheckFow)
            }
            "GAME_PARTICLE_MANAGER_EVENT_SET_CONTROL_POINT_MODEL" => {
                Some(Self::GameParticleManagerEventSetControlPointModel)
            }
            "GAME_PARTICLE_MANAGER_EVENT_SET_CONTROL_POINT_SNAPSHOT" => {
                Some(Self::GameParticleManagerEventSetControlPointSnapshot)
            }
            "GAME_PARTICLE_MANAGER_EVENT_SET_TEXTURE_ATTRIBUTE" => {
                Some(Self::GameParticleManagerEventSetTextureAttribute)
            }
            "GAME_PARTICLE_MANAGER_EVENT_SET_SCENE_OBJECT_GENERIC_FLAG" => {
                Some(Self::GameParticleManagerEventSetSceneObjectGenericFlag)
            }
            "GAME_PARTICLE_MANAGER_EVENT_SET_SCENE_OBJECT_TINT_AND_DESAT" => {
                Some(Self::GameParticleManagerEventSetSceneObjectTintAndDesat)
            }
            "GAME_PARTICLE_MANAGER_EVENT_DESTROY_NAMED" => {
                Some(Self::GameParticleManagerEventDestroyNamed)
            }
            "GAME_PARTICLE_MANAGER_EVENT_SKIP_TO_TIME" => {
                Some(Self::GameParticleManagerEventSkipToTime)
            }
            "GAME_PARTICLE_MANAGER_EVENT_CAN_FREEZE" => {
                Some(Self::GameParticleManagerEventCanFreeze)
            }
            "GAME_PARTICLE_MANAGER_EVENT_SET_NAMED_VALUE_CONTEXT" => {
                Some(Self::GameParticleManagerEventSetNamedValueContext)
            }
            "GAME_PARTICLE_MANAGER_EVENT_UPDATE_TRANSFORM" => {
                Some(Self::GameParticleManagerEventUpdateTransform)
            }
            "GAME_PARTICLE_MANAGER_EVENT_FREEZE_TRANSITION_OVERRIDE" => {
                Some(Self::GameParticleManagerEventFreezeTransitionOverride)
            }
            "GAME_PARTICLE_MANAGER_EVENT_FREEZE_INVOLVING" => {
                Some(Self::GameParticleManagerEventFreezeInvolving)
            }
            "GAME_PARTICLE_MANAGER_EVENT_ADD_MODELLIST_OVERRIDE_ELEMENT" => {
                Some(Self::GameParticleManagerEventAddModellistOverrideElement)
            }
            "GAME_PARTICLE_MANAGER_EVENT_CLEAR_MODELLIST_OVERRIDE" => {
                Some(Self::GameParticleManagerEventClearModellistOverride)
            }
            "GAME_PARTICLE_MANAGER_EVENT_CREATE_PHYSICS_SIM" => {
                Some(Self::GameParticleManagerEventCreatePhysicsSim)
            }
            "GAME_PARTICLE_MANAGER_EVENT_DESTROY_PHYSICS_SIM" => {
                Some(Self::GameParticleManagerEventDestroyPhysicsSim)
            }
            "GAME_PARTICLE_MANAGER_EVENT_SET_VDATA" => Some(Self::GameParticleManagerEventSetVdata),
            "GAME_PARTICLE_MANAGER_EVENT_SET_MATERIAL_OVERRIDE" => {
                Some(Self::GameParticleManagerEventSetMaterialOverride)
            }
            _ => None,
        }
    }
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum EHapticPulseType {
    VrHandHapticPulseLight = 0,
    VrHandHapticPulseMedium = 1,
    VrHandHapticPulseStrong = 2,
}
impl EHapticPulseType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic
    /// use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            EHapticPulseType::VrHandHapticPulseLight => "VR_HAND_HAPTIC_PULSE_LIGHT",
            EHapticPulseType::VrHandHapticPulseMedium => "VR_HAND_HAPTIC_PULSE_MEDIUM",
            EHapticPulseType::VrHandHapticPulseStrong => "VR_HAND_HAPTIC_PULSE_STRONG",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "VR_HAND_HAPTIC_PULSE_LIGHT" => Some(Self::VrHandHapticPulseLight),
            "VR_HAND_HAPTIC_PULSE_MEDIUM" => Some(Self::VrHandHapticPulseMedium),
            "VR_HAND_HAPTIC_PULSE_STRONG" => Some(Self::VrHandHapticPulseStrong),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgFireBullets {
    #[prost(message, optional, tag = "1")]
    pub origin: ::core::option::Option<CMsgVector>,
    #[prost(message, optional, tag = "2")]
    pub angles: ::core::option::Option<CMsgQAngle>,
    #[prost(uint32, optional, tag = "4")]
    pub seed: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "5", default = "-1")]
    pub shooter_entity: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "7", default = "-1")]
    pub ability: ::core::option::Option<i32>,
    #[prost(float, optional, tag = "8")]
    pub penetration_percent: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "9")]
    pub spread: ::core::option::Option<f32>,
    #[prost(bool, optional, tag = "10", default = "true")]
    pub fired_from_gun: ::core::option::Option<bool>,
    #[prost(uint32, optional, tag = "11")]
    pub bullets_override: ::core::option::Option<u32>,
    #[prost(message, optional, tag = "12")]
    pub tracer_replacement: ::core::option::Option<c_msg_fire_bullets::TracerAssignment>,
    #[prost(message, repeated, tag = "13")]
    pub tracer_additional: ::prost::alloc::vec::Vec<c_msg_fire_bullets::TracerAssignment>,
    #[prost(message, optional, tag = "14")]
    pub angles_original: ::core::option::Option<CMsgQAngle>,
    #[prost(uint32, optional, tag = "15")]
    pub weapon_subclass_id: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "16")]
    pub shot_number: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "17", default = "-1")]
    pub ignore_entity: ::core::option::Option<i32>,
    #[prost(float, optional, tag = "18")]
    pub max_range: ::core::option::Option<f32>,
}
/// Nested message and enum types in `CMsgFireBullets`.
pub mod c_msg_fire_bullets {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct TracerAssignment {
        #[prost(uint64, optional, tag = "1")]
        pub tracer_resource_id: ::core::option::Option<u64>,
        #[prost(uint32, optional, tag = "2")]
        pub bullet_indicies: ::core::option::Option<u32>,
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgBulletImpact {
    #[prost(message, optional, tag = "1")]
    pub trace_start: ::core::option::Option<CMsgVector>,
    #[prost(message, optional, tag = "2")]
    pub impact_origin: ::core::option::Option<CMsgVector>,
    #[prost(message, optional, tag = "3")]
    pub surface_normal: ::core::option::Option<CMsgVector>,
    #[prost(uint32, optional, tag = "4")]
    pub damage: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "5")]
    pub surface_type: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "7", default = "-1")]
    pub ability_entindex: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "8", default = "-1")]
    pub impacted_entindex: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "9")]
    pub impacted_hitbox: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "10")]
    pub weapon_subclass_id: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "11", default = "-1")]
    pub shooter_entindex: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgPlayerAnimEvent {
    #[prost(fixed32, optional, tag = "1", default = "16777215")]
    pub player: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub event: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "3")]
    pub data: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgParticleSystemManager {
    #[prost(
        enumeration = "ParticleSystemManagerMessage",
        required,
        tag = "1",
        default = "ParticleSystemManagerEventCreate"
    )]
    pub r#type: i32,
    #[prost(uint32, required, tag = "2")]
    pub index: u32,
    #[prost(message, optional, tag = "3")]
    pub create_particle: ::core::option::Option<c_msg_particle_system_manager::CreateParticle>,
    #[prost(message, optional, tag = "4")]
    pub destroy_particle: ::core::option::Option<c_msg_particle_system_manager::DestroyParticle>,
    #[prost(message, optional, tag = "5")]
    pub destroy_particle_involving:
        ::core::option::Option<c_msg_particle_system_manager::DestroyParticleInvolving>,
    #[prost(message, optional, tag = "6")]
    pub release_particle_index:
        ::core::option::Option<c_msg_particle_system_manager::ReleaseParticleIndex>,
    #[prost(message, optional, tag = "7")]
    pub update_particle: ::core::option::Option<c_msg_particle_system_manager::UpdateParticle>,
    #[prost(message, optional, tag = "8")]
    pub update_particle_fwd:
        ::core::option::Option<c_msg_particle_system_manager::UpdateParticleFwd>,
    #[prost(message, optional, tag = "9")]
    pub update_particle_orient:
        ::core::option::Option<c_msg_particle_system_manager::UpdateParticleOrient>,
    #[prost(message, optional, tag = "10")]
    pub update_particle_fallback:
        ::core::option::Option<c_msg_particle_system_manager::UpdateParticleFallback>,
    #[prost(message, optional, tag = "11")]
    pub update_particle_offset:
        ::core::option::Option<c_msg_particle_system_manager::UpdateParticleOffset>,
    #[prost(message, optional, tag = "12")]
    pub update_particle_ent:
        ::core::option::Option<c_msg_particle_system_manager::UpdateParticleEnt>,
    #[prost(message, optional, tag = "13")]
    pub update_particle_frozen:
        ::core::option::Option<c_msg_particle_system_manager::UpdateParticleFrozen>,
    #[prost(message, optional, tag = "14")]
    pub update_particle_should_draw:
        ::core::option::Option<c_msg_particle_system_manager::UpdateParticleShouldDraw>,
}
/// Nested message and enum types in `CMsgParticleSystemManager`.
pub mod c_msg_particle_system_manager {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct CreateParticle {
        #[prost(fixed64, optional, tag = "1")]
        pub particle_name_index: ::core::option::Option<u64>,
        #[prost(int32, optional, tag = "2")]
        pub attach_type: ::core::option::Option<i32>,
        #[prost(uint32, optional, tag = "3", default = "16777215")]
        pub entity_handle: ::core::option::Option<u32>,
        #[prost(message, optional, tag = "4")]
        pub position: ::core::option::Option<super::CMsgVector>,
        #[prost(message, optional, tag = "5")]
        pub angles: ::core::option::Option<super::CMsgQAngle>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct DestroyParticle {
        #[prost(bool, optional, tag = "1")]
        pub destroy_immediately: ::core::option::Option<bool>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct DestroyParticleInvolving {
        #[prost(bool, optional, tag = "1")]
        pub destroy_immediately: ::core::option::Option<bool>,
        #[prost(uint32, optional, tag = "3", default = "16777215")]
        pub entity_handle: ::core::option::Option<u32>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct ReleaseParticleIndex {}
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct UpdateParticle {
        #[prost(int32, optional, tag = "1")]
        pub control_point: ::core::option::Option<i32>,
        #[prost(message, optional, tag = "2")]
        pub position: ::core::option::Option<super::CMsgVector>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct UpdateParticleFwd {
        #[prost(int32, optional, tag = "1")]
        pub control_point: ::core::option::Option<i32>,
        #[prost(message, optional, tag = "2")]
        pub forward: ::core::option::Option<super::CMsgVector>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct UpdateParticleOrient {
        #[prost(int32, optional, tag = "1")]
        pub control_point: ::core::option::Option<i32>,
        #[prost(message, optional, tag = "2")]
        pub forward: ::core::option::Option<super::CMsgVector>,
        #[prost(message, optional, tag = "3")]
        pub left: ::core::option::Option<super::CMsgVector>,
        #[prost(message, optional, tag = "4")]
        pub up: ::core::option::Option<super::CMsgVector>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct UpdateParticleFallback {
        #[prost(int32, optional, tag = "1")]
        pub control_point: ::core::option::Option<i32>,
        #[prost(message, optional, tag = "2")]
        pub position: ::core::option::Option<super::CMsgVector>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct UpdateParticleEnt {
        #[prost(int32, optional, tag = "1")]
        pub control_point: ::core::option::Option<i32>,
        #[prost(uint32, optional, tag = "2", default = "16777215")]
        pub entity_handle: ::core::option::Option<u32>,
        #[prost(int32, optional, tag = "3")]
        pub attach_type: ::core::option::Option<i32>,
        #[prost(int32, optional, tag = "4")]
        pub attachment: ::core::option::Option<i32>,
        #[prost(message, optional, tag = "5")]
        pub fallback_position: ::core::option::Option<super::CMsgVector>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct UpdateParticleOffset {
        #[prost(int32, optional, tag = "1")]
        pub control_point: ::core::option::Option<i32>,
        #[prost(message, optional, tag = "2")]
        pub origin_offset: ::core::option::Option<super::CMsgVector>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct UpdateParticleFrozen {
        #[prost(bool, optional, tag = "1")]
        pub set_frozen: ::core::option::Option<bool>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct UpdateParticleShouldDraw {
        #[prost(bool, optional, tag = "1")]
        pub should_draw: ::core::option::Option<bool>,
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgScreenTextPretty {
    #[prost(float, optional, tag = "1")]
    pub x_pos: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "2")]
    pub y_pos: ::core::option::Option<f32>,
    #[prost(int32, optional, tag = "3")]
    pub line: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "4")]
    pub text: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "5")]
    pub r: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "6")]
    pub g: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "7")]
    pub b: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "8")]
    pub a: ::core::option::Option<i32>,
    #[prost(float, optional, tag = "9")]
    pub duration: ::core::option::Option<f32>,
    #[prost(string, optional, tag = "10")]
    pub font_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "11")]
    pub font_size: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "12")]
    pub bold_font: ::core::option::Option<bool>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgServerRequestedTracer {
    #[prost(message, optional, tag = "1")]
    pub origin: ::core::option::Option<CMsgVector>,
    #[prost(message, optional, tag = "2")]
    pub end: ::core::option::Option<CMsgVector>,
    #[prost(int32, optional, tag = "3", default = "-1")]
    pub weaponid: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "4", default = "16777215")]
    pub entity_handle: ::core::option::Option<u32>,
    #[prost(float, optional, tag = "5")]
    pub dps: ::core::option::Option<f32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgEnableSatVolumesEvent {
    #[prost(uint32, optional, tag = "1")]
    pub mode: ::core::option::Option<u32>,
    #[prost(float, optional, tag = "2")]
    pub desat_amount: ::core::option::Option<f32>,
    #[prost(fixed32, optional, tag = "3")]
    pub sat_tint: ::core::option::Option<u32>,
    #[prost(fixed32, optional, tag = "4")]
    pub desat_tint: ::core::option::Option<u32>,
    #[prost(fixed32, optional, tag = "5")]
    pub outline_color: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgPlaceSatVolumeEvent {
    #[prost(message, optional, tag = "1")]
    pub position: ::core::option::Option<CMsgVector>,
    #[prost(message, optional, tag = "2")]
    pub direction: ::core::option::Option<CMsgVector>,
    #[prost(float, optional, tag = "3")]
    pub radius: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "4")]
    pub falloff_distance: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "5")]
    pub theta_dot: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "6")]
    pub phi_dot: ::core::option::Option<f32>,
    #[prost(uint32, optional, tag = "7", default = "16777215")]
    pub entity_handle: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "8")]
    pub attachment_handle: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "9")]
    pub r#type: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "10")]
    pub volume_id: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgRemoveSatVolumeEvent {
    #[prost(int32, optional, tag = "1")]
    pub volume_id: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgDisableSatVolumesEvent {}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum ECitadelGameEvents {
    GeFireBullets = 450,
    GePlayerAnimEvent = 451,
    GeParticleSystemManager = 458,
    GeScreenTextPretty = 459,
    GeServerRequestedTracer = 460,
    GeBulletImpact = 461,
    GeEnableSatVolumesEvent = 462,
    GePlaceSatVolumeEvent = 463,
    GeDisableSatVolumesEvent = 464,
    GeRemoveSatVolumeEvent = 465,
}
impl ECitadelGameEvents {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic
    /// use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ECitadelGameEvents::GeFireBullets => "GE_FireBullets",
            ECitadelGameEvents::GePlayerAnimEvent => "GE_PlayerAnimEvent",
            ECitadelGameEvents::GeParticleSystemManager => "GE_ParticleSystemManager",
            ECitadelGameEvents::GeScreenTextPretty => "GE_ScreenTextPretty",
            ECitadelGameEvents::GeServerRequestedTracer => "GE_ServerRequestedTracer",
            ECitadelGameEvents::GeBulletImpact => "GE_BulletImpact",
            ECitadelGameEvents::GeEnableSatVolumesEvent => "GE_EnableSatVolumesEvent",
            ECitadelGameEvents::GePlaceSatVolumeEvent => "GE_PlaceSatVolumeEvent",
            ECitadelGameEvents::GeDisableSatVolumesEvent => "GE_DisableSatVolumesEvent",
            ECitadelGameEvents::GeRemoveSatVolumeEvent => "GE_RemoveSatVolumeEvent",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "GE_FireBullets" => Some(Self::GeFireBullets),
            "GE_PlayerAnimEvent" => Some(Self::GePlayerAnimEvent),
            "GE_ParticleSystemManager" => Some(Self::GeParticleSystemManager),
            "GE_ScreenTextPretty" => Some(Self::GeScreenTextPretty),
            "GE_ServerRequestedTracer" => Some(Self::GeServerRequestedTracer),
            "GE_BulletImpact" => Some(Self::GeBulletImpact),
            "GE_EnableSatVolumesEvent" => Some(Self::GeEnableSatVolumesEvent),
            "GE_PlaceSatVolumeEvent" => Some(Self::GePlaceSatVolumeEvent),
            "GE_DisableSatVolumesEvent" => Some(Self::GeDisableSatVolumesEvent),
            "GE_RemoveSatVolumeEvent" => Some(Self::GeRemoveSatVolumeEvent),
            _ => None,
        }
    }
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum ParticleSystemManagerMessage {
    ParticleSystemManagerEventCreate = 0,
    ParticleSystemManagerEventDestroy = 1,
    ParticleSystemManagerEventDestroyInvolving = 2,
    ParticleSystemManagerEventRelease = 3,
    ParticleSystemManagerEventUpdate = 4,
    ParticleSystemManagerEventUpdateForward = 5,
    ParticleSystemManagerEventUpdateOrientation = 6,
    ParticleSystemManagerEventUpdateFallback = 7,
    ParticleSystemManagerEventUpdateEnt = 8,
    ParticleSystemManagerEventUpdateOffset = 9,
    ParticleSystemManagerEventUpdateFrozen = 10,
    ParticleSystemManagerEventUpdateShouldDraw = 11,
}
impl ParticleSystemManagerMessage {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic
    /// use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ParticleSystemManagerMessage::ParticleSystemManagerEventCreate => {
                "PARTICLE_SYSTEM_MANAGER_EVENT_CREATE"
            }
            ParticleSystemManagerMessage::ParticleSystemManagerEventDestroy => {
                "PARTICLE_SYSTEM_MANAGER_EVENT_DESTROY"
            }
            ParticleSystemManagerMessage::ParticleSystemManagerEventDestroyInvolving => {
                "PARTICLE_SYSTEM_MANAGER_EVENT_DESTROY_INVOLVING"
            }
            ParticleSystemManagerMessage::ParticleSystemManagerEventRelease => {
                "PARTICLE_SYSTEM_MANAGER_EVENT_RELEASE"
            }
            ParticleSystemManagerMessage::ParticleSystemManagerEventUpdate => {
                "PARTICLE_SYSTEM_MANAGER_EVENT_UPDATE"
            }
            ParticleSystemManagerMessage::ParticleSystemManagerEventUpdateForward => {
                "PARTICLE_SYSTEM_MANAGER_EVENT_UPDATE_FORWARD"
            }
            ParticleSystemManagerMessage::ParticleSystemManagerEventUpdateOrientation => {
                "PARTICLE_SYSTEM_MANAGER_EVENT_UPDATE_ORIENTATION"
            }
            ParticleSystemManagerMessage::ParticleSystemManagerEventUpdateFallback => {
                "PARTICLE_SYSTEM_MANAGER_EVENT_UPDATE_FALLBACK"
            }
            ParticleSystemManagerMessage::ParticleSystemManagerEventUpdateEnt => {
                "PARTICLE_SYSTEM_MANAGER_EVENT_UPDATE_ENT"
            }
            ParticleSystemManagerMessage::ParticleSystemManagerEventUpdateOffset => {
                "PARTICLE_SYSTEM_MANAGER_EVENT_UPDATE_OFFSET"
            }
            ParticleSystemManagerMessage::ParticleSystemManagerEventUpdateFrozen => {
                "PARTICLE_SYSTEM_MANAGER_EVENT_UPDATE_FROZEN"
            }
            ParticleSystemManagerMessage::ParticleSystemManagerEventUpdateShouldDraw => {
                "PARTICLE_SYSTEM_MANAGER_EVENT_UPDATE_SHOULD_DRAW"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PARTICLE_SYSTEM_MANAGER_EVENT_CREATE" => Some(Self::ParticleSystemManagerEventCreate),
            "PARTICLE_SYSTEM_MANAGER_EVENT_DESTROY" => {
                Some(Self::ParticleSystemManagerEventDestroy)
            }
            "PARTICLE_SYSTEM_MANAGER_EVENT_DESTROY_INVOLVING" => {
                Some(Self::ParticleSystemManagerEventDestroyInvolving)
            }
            "PARTICLE_SYSTEM_MANAGER_EVENT_RELEASE" => {
                Some(Self::ParticleSystemManagerEventRelease)
            }
            "PARTICLE_SYSTEM_MANAGER_EVENT_UPDATE" => Some(Self::ParticleSystemManagerEventUpdate),
            "PARTICLE_SYSTEM_MANAGER_EVENT_UPDATE_FORWARD" => {
                Some(Self::ParticleSystemManagerEventUpdateForward)
            }
            "PARTICLE_SYSTEM_MANAGER_EVENT_UPDATE_ORIENTATION" => {
                Some(Self::ParticleSystemManagerEventUpdateOrientation)
            }
            "PARTICLE_SYSTEM_MANAGER_EVENT_UPDATE_FALLBACK" => {
                Some(Self::ParticleSystemManagerEventUpdateFallback)
            }
            "PARTICLE_SYSTEM_MANAGER_EVENT_UPDATE_ENT" => {
                Some(Self::ParticleSystemManagerEventUpdateEnt)
            }
            "PARTICLE_SYSTEM_MANAGER_EVENT_UPDATE_OFFSET" => {
                Some(Self::ParticleSystemManagerEventUpdateOffset)
            }
            "PARTICLE_SYSTEM_MANAGER_EVENT_UPDATE_FROZEN" => {
                Some(Self::ParticleSystemManagerEventUpdateFrozen)
            }
            "PARTICLE_SYSTEM_MANAGER_EVENT_UPDATE_SHOULD_DRAW" => {
                Some(Self::ParticleSystemManagerEventUpdateShouldDraw)
            }
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgProtoBufHeader {
    #[prost(fixed64, optional, tag = "1")]
    pub client_steam_id: ::core::option::Option<u64>,
    #[prost(int32, optional, tag = "2")]
    pub client_session_id: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "3")]
    pub source_app_id: ::core::option::Option<u32>,
    #[prost(fixed64, optional, tag = "10", default = "18446744073709551615")]
    pub job_id_source: ::core::option::Option<u64>,
    #[prost(fixed64, optional, tag = "11", default = "18446744073709551615")]
    pub job_id_target: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "12")]
    pub target_job_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "13", default = "2")]
    pub eresult: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "14")]
    pub error_message: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(
        enumeration = "GcProtoBufMsgSrc",
        optional,
        tag = "200",
        default = "Unspecified"
    )]
    pub gc_msg_src: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "201", default = "-1")]
    pub gc_dir_index_source: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CgcSystemMsgGetAccountDetails {
    #[prost(fixed64, optional, tag = "1")]
    pub steamid: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "2")]
    pub appid: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CgcSystemMsgGetAccountDetailsResponse {
    #[prost(uint32, optional, tag = "1", default = "2")]
    pub eresult_deprecated: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "2")]
    pub account_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3")]
    pub persona_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "26")]
    pub is_profile_created: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "4")]
    pub is_profile_public: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "5")]
    pub is_inventory_public: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "7")]
    pub is_vac_banned: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "8")]
    pub is_cyber_cafe: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "9")]
    pub is_school_account: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "10")]
    pub is_limited: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "11")]
    pub is_subscribed: ::core::option::Option<bool>,
    #[prost(uint32, optional, tag = "12")]
    pub package: ::core::option::Option<u32>,
    #[prost(bool, optional, tag = "13")]
    pub is_free_trial_account: ::core::option::Option<bool>,
    #[prost(uint32, optional, tag = "14")]
    pub free_trial_expiration: ::core::option::Option<u32>,
    #[prost(bool, optional, tag = "15")]
    pub is_low_violence: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "16")]
    pub is_account_locked_down: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "17")]
    pub is_community_banned: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "18")]
    pub is_trade_banned: ::core::option::Option<bool>,
    #[prost(uint32, optional, tag = "19")]
    pub trade_ban_expiration: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "20")]
    pub accountid: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "21")]
    pub suspension_end_time: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "22")]
    pub currency: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "23")]
    pub steam_level: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "24")]
    pub friend_count: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "25")]
    pub account_creation_time: ::core::option::Option<u32>,
    #[prost(bool, optional, tag = "27")]
    pub is_steamguard_enabled: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "28")]
    pub is_phone_verified: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "29")]
    pub is_two_factor_auth_enabled: ::core::option::Option<bool>,
    #[prost(uint32, optional, tag = "30")]
    pub two_factor_enabled_time: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "31")]
    pub phone_verification_time: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "33")]
    pub phone_id: ::core::option::Option<u64>,
    #[prost(bool, optional, tag = "34")]
    pub is_phone_identifying: ::core::option::Option<bool>,
    #[prost(uint32, optional, tag = "35")]
    pub rt_identity_linked: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "36")]
    pub rt_birth_date: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "37")]
    pub txn_country_code: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "38")]
    pub has_accepted_china_ssa: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "39")]
    pub is_banned_steam_china: ::core::option::Option<bool>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CipLocationInfo {
    #[prost(uint32, optional, tag = "1")]
    pub ip: ::core::option::Option<u32>,
    #[prost(float, optional, tag = "2")]
    pub latitude: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "3")]
    pub longitude: ::core::option::Option<f32>,
    #[prost(string, optional, tag = "4")]
    pub country: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "5")]
    pub state: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "6")]
    pub city: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CgcMsgGetIpLocationResponse {
    #[prost(message, repeated, tag = "1")]
    pub infos: ::prost::alloc::vec::Vec<CipLocationInfo>,
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum EgcPlatform {
    KEGcPlatformNone = 0,
    KEGcPlatformPc = 1,
    KEGcPlatformMac = 2,
    KEGcPlatformLinux = 3,
    KEGcPlatformAndroid = 4,
    KEGcPlatformIOs = 5,
}
impl EgcPlatform {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic
    /// use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            EgcPlatform::KEGcPlatformNone => "k_eGCPlatform_None",
            EgcPlatform::KEGcPlatformPc => "k_eGCPlatform_PC",
            EgcPlatform::KEGcPlatformMac => "k_eGCPlatform_Mac",
            EgcPlatform::KEGcPlatformLinux => "k_eGCPlatform_Linux",
            EgcPlatform::KEGcPlatformAndroid => "k_eGCPlatform_Android",
            EgcPlatform::KEGcPlatformIOs => "k_eGCPlatform_iOS",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "k_eGCPlatform_None" => Some(Self::KEGcPlatformNone),
            "k_eGCPlatform_PC" => Some(Self::KEGcPlatformPc),
            "k_eGCPlatform_Mac" => Some(Self::KEGcPlatformMac),
            "k_eGCPlatform_Linux" => Some(Self::KEGcPlatformLinux),
            "k_eGCPlatform_Android" => Some(Self::KEGcPlatformAndroid),
            "k_eGCPlatform_iOS" => Some(Self::KEGcPlatformIOs),
            _ => None,
        }
    }
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum GcProtoBufMsgSrc {
    Unspecified = 0,
    FromSystem = 1,
    FromSteamId = 2,
    FromGc = 3,
    ReplySystem = 4,
    SpoofedSteamId = 5,
}
impl GcProtoBufMsgSrc {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic
    /// use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            GcProtoBufMsgSrc::Unspecified => "GCProtoBufMsgSrc_Unspecified",
            GcProtoBufMsgSrc::FromSystem => "GCProtoBufMsgSrc_FromSystem",
            GcProtoBufMsgSrc::FromSteamId => "GCProtoBufMsgSrc_FromSteamID",
            GcProtoBufMsgSrc::FromGc => "GCProtoBufMsgSrc_FromGC",
            GcProtoBufMsgSrc::ReplySystem => "GCProtoBufMsgSrc_ReplySystem",
            GcProtoBufMsgSrc::SpoofedSteamId => "GCProtoBufMsgSrc_SpoofedSteamID",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "GCProtoBufMsgSrc_Unspecified" => Some(Self::Unspecified),
            "GCProtoBufMsgSrc_FromSystem" => Some(Self::FromSystem),
            "GCProtoBufMsgSrc_FromSteamID" => Some(Self::FromSteamId),
            "GCProtoBufMsgSrc_FromGC" => Some(Self::FromGc),
            "GCProtoBufMsgSrc_ReplySystem" => Some(Self::ReplySystem),
            "GCProtoBufMsgSrc_SpoofedSteamID" => Some(Self::SpoofedSteamId),
            _ => None,
        }
    }
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum EProtoExecutionSite {
    KEProtoExecutionSiteUnknown = 0,
    KEProtoExecutionSiteSteamClient = 3,
}
impl EProtoExecutionSite {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic
    /// use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            EProtoExecutionSite::KEProtoExecutionSiteUnknown => "k_EProtoExecutionSiteUnknown",
            EProtoExecutionSite::KEProtoExecutionSiteSteamClient => {
                "k_EProtoExecutionSiteSteamClient"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "k_EProtoExecutionSiteUnknown" => Some(Self::KEProtoExecutionSiteUnknown),
            "k_EProtoExecutionSiteSteamClient" => Some(Self::KEProtoExecutionSiteSteamClient),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgSteamLearnDataSourceDescObject {
    #[prost(message, repeated, tag = "1")]
    pub elements: ::prost::alloc::vec::Vec<CMsgSteamLearnDataSourceDescElement>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgSteamLearnDataSourceDescElement {
    #[prost(string, optional, tag = "1")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(
        enumeration = "ESteamLearnDataType",
        optional,
        tag = "2",
        default = "SteamlearnDatatypeInvalid"
    )]
    pub data_type: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "3")]
    pub object: ::core::option::Option<CMsgSteamLearnDataSourceDescObject>,
    #[prost(uint32, optional, tag = "4")]
    pub count: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgSteamLearnDataSource {
    #[prost(uint32, optional, tag = "1")]
    pub id: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "2")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "3")]
    pub version: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "4")]
    pub source_description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "5")]
    pub structure: ::core::option::Option<CMsgSteamLearnDataSourceDescObject>,
    #[prost(uint32, optional, tag = "6")]
    pub structure_crc: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "7")]
    pub cache_duration_seconds: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgSteamLearnDataObject {
    #[prost(message, repeated, tag = "1")]
    pub elements: ::prost::alloc::vec::Vec<CMsgSteamLearnDataElement>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgSteamLearnDataElement {
    #[prost(string, optional, tag = "1")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, repeated, packed = "false", tag = "20")]
    pub data_int32s: ::prost::alloc::vec::Vec<i32>,
    #[prost(float, repeated, packed = "false", tag = "21")]
    pub data_floats: ::prost::alloc::vec::Vec<f32>,
    #[prost(bool, repeated, packed = "false", tag = "22")]
    pub data_bools: ::prost::alloc::vec::Vec<bool>,
    #[prost(string, repeated, tag = "23")]
    pub data_strings: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "24")]
    pub data_objects: ::prost::alloc::vec::Vec<CMsgSteamLearnDataObject>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgSteamLearnData {
    #[prost(uint32, optional, tag = "1")]
    pub data_source_id: ::core::option::Option<u32>,
    #[prost(uint64, repeated, packed = "false", tag = "2")]
    pub keys: ::prost::alloc::vec::Vec<u64>,
    #[prost(message, optional, tag = "3")]
    pub data_object: ::core::option::Option<CMsgSteamLearnDataObject>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgSteamLearnDataList {
    #[prost(message, repeated, tag = "1")]
    pub data: ::prost::alloc::vec::Vec<CMsgSteamLearnData>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgSteamLearnRegisterDataSourceRequest {
    #[prost(string, optional, tag = "1")]
    pub access_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "3")]
    pub data_source: ::core::option::Option<CMsgSteamLearnDataSource>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgSteamLearnRegisterDataSourceResponse {
    #[prost(
        enumeration = "ESteammLearnRegisterDataSourceResult",
        optional,
        tag = "1",
        default = "SteamlearnRegisterDataSourceResultError"
    )]
    pub result: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "2")]
    pub data_source: ::core::option::Option<CMsgSteamLearnDataSource>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgSteamLearnCacheDataRequest {
    #[prost(string, optional, tag = "1")]
    pub access_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "3")]
    pub data: ::core::option::Option<CMsgSteamLearnData>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgSteamLearnCacheDataResponse {
    #[prost(
        enumeration = "ESteamLearnCacheDataResult",
        optional,
        tag = "1",
        default = "SteamlearnCacheDataError"
    )]
    pub cache_data_result: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgSteamLearnSnapshotProjectRequest {
    #[prost(string, optional, tag = "1")]
    pub access_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "3")]
    pub project_id: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "7")]
    pub published_version: ::core::option::Option<u32>,
    #[prost(uint64, repeated, packed = "false", tag = "4")]
    pub keys: ::prost::alloc::vec::Vec<u64>,
    #[prost(message, repeated, tag = "5")]
    pub data: ::prost::alloc::vec::Vec<CMsgSteamLearnData>,
    #[prost(uint32, optional, tag = "6")]
    pub pending_data_limit_seconds: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgSteamLearnSnapshotProjectResponse {
    #[prost(
        enumeration = "ESteamLearnSnapshotProjectResult",
        optional,
        tag = "1",
        default = "SteamlearnSnapshotProjectError"
    )]
    pub snapshot_result: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgSteamLearnBatchOperationRequest {
    #[prost(message, repeated, tag = "1")]
    pub cache_data_requests: ::prost::alloc::vec::Vec<CMsgSteamLearnCacheDataRequest>,
    #[prost(message, repeated, tag = "2")]
    pub snapshot_requests: ::prost::alloc::vec::Vec<CMsgSteamLearnSnapshotProjectRequest>,
    #[prost(message, repeated, tag = "3")]
    pub inference_requests: ::prost::alloc::vec::Vec<CMsgSteamLearnInferenceRequest>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgSteamLearnBatchOperationResponse {
    #[prost(message, repeated, tag = "1")]
    pub cache_data_responses: ::prost::alloc::vec::Vec<CMsgSteamLearnCacheDataResponse>,
    #[prost(message, repeated, tag = "2")]
    pub snapshot_responses: ::prost::alloc::vec::Vec<CMsgSteamLearnSnapshotProjectResponse>,
    #[prost(message, repeated, tag = "3")]
    pub inference_responses: ::prost::alloc::vec::Vec<CMsgSteamLearnInferenceResponse>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgSteamLearnAccessTokens {
    #[prost(string, optional, tag = "1")]
    pub register_data_source_access_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "2")]
    pub cache_data_access_tokens:
        ::prost::alloc::vec::Vec<c_msg_steam_learn_access_tokens::CacheDataAccessToken>,
    #[prost(message, repeated, tag = "3")]
    pub snapshot_project_access_tokens:
        ::prost::alloc::vec::Vec<c_msg_steam_learn_access_tokens::SnapshotProjectAccessToken>,
    #[prost(message, repeated, tag = "4")]
    pub inference_access_tokens:
        ::prost::alloc::vec::Vec<c_msg_steam_learn_access_tokens::InferenceAccessToken>,
}
/// Nested message and enum types in `CMsgSteamLearnAccessTokens`.
pub mod c_msg_steam_learn_access_tokens {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CacheDataAccessToken {
        #[prost(uint32, optional, tag = "1")]
        pub data_source_id: ::core::option::Option<u32>,
        #[prost(string, optional, tag = "2")]
        pub access_token: ::core::option::Option<::prost::alloc::string::String>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SnapshotProjectAccessToken {
        #[prost(uint32, optional, tag = "1")]
        pub project_id: ::core::option::Option<u32>,
        #[prost(string, optional, tag = "2")]
        pub access_token: ::core::option::Option<::prost::alloc::string::String>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct InferenceAccessToken {
        #[prost(uint32, optional, tag = "1")]
        pub project_id: ::core::option::Option<u32>,
        #[prost(string, optional, tag = "2")]
        pub access_token: ::core::option::Option<::prost::alloc::string::String>,
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgSteamLearnGetAccessTokensRequest {
    #[prost(uint32, optional, tag = "1")]
    pub appid: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgSteamLearnGetAccessTokensResponse {
    #[prost(
        enumeration = "ESteamLearnGetAccessTokensResult",
        optional,
        tag = "1",
        default = "SteamlearnGetAccessTokensError"
    )]
    pub result: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "2")]
    pub access_tokens: ::core::option::Option<CMsgSteamLearnAccessTokens>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgSteamLearnInferenceRequest {
    #[prost(string, optional, tag = "1")]
    pub access_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "3")]
    pub project_id: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub published_version: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "5")]
    pub override_train_id: ::core::option::Option<u32>,
    #[prost(message, optional, tag = "6")]
    pub data: ::core::option::Option<CMsgSteamLearnDataList>,
    #[prost(float, repeated, packed = "false", tag = "7")]
    pub additional_data: ::prost::alloc::vec::Vec<f32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgSteamLearnInferenceMetadataRequest {
    #[prost(string, optional, tag = "1")]
    pub access_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "3")]
    pub project_id: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub published_version: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "5")]
    pub override_train_id: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgSteamLearnInferenceMetadataBackendRequest {
    #[prost(uint32, optional, tag = "1")]
    pub project_id: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub fetch_id: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgSteamLearnInferenceMetadataResponse {
    #[prost(
        enumeration = "ESteamLearnInferenceMetadataResult",
        optional,
        tag = "1",
        default = "SteamlearnInferenceMetadataError"
    )]
    pub inference_metadata_result: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "2")]
    pub row_range: ::core::option::Option<c_msg_steam_learn_inference_metadata_response::RowRange>,
    #[prost(message, repeated, tag = "3")]
    pub ranges: ::prost::alloc::vec::Vec<c_msg_steam_learn_inference_metadata_response::Range>,
    #[prost(message, repeated, tag = "4")]
    pub std_devs: ::prost::alloc::vec::Vec<c_msg_steam_learn_inference_metadata_response::StdDev>,
    #[prost(message, repeated, tag = "5")]
    pub compact_tables:
        ::prost::alloc::vec::Vec<c_msg_steam_learn_inference_metadata_response::CompactTable>,
    #[prost(message, repeated, tag = "6")]
    pub kmeans: ::prost::alloc::vec::Vec<c_msg_steam_learn_inference_metadata_response::KMeans>,
    #[prost(message, optional, tag = "7")]
    pub snapshot_histogram:
        ::core::option::Option<c_msg_steam_learn_inference_metadata_response::SnapshotHistogram>,
}
/// Nested message and enum types in
/// `CMsgSteamLearn_InferenceMetadata_Response`.
pub mod c_msg_steam_learn_inference_metadata_response {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct RowRange {
        #[prost(uint64, optional, tag = "1")]
        pub min_row: ::core::option::Option<u64>,
        #[prost(uint64, optional, tag = "2")]
        pub max_row: ::core::option::Option<u64>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Range {
        #[prost(string, optional, tag = "1")]
        pub data_element_path: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(float, optional, tag = "2")]
        pub min_value: ::core::option::Option<f32>,
        #[prost(float, optional, tag = "3")]
        pub max_value: ::core::option::Option<f32>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct StdDev {
        #[prost(string, optional, tag = "1")]
        pub data_element_path: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(float, optional, tag = "2")]
        pub mean: ::core::option::Option<f32>,
        #[prost(float, optional, tag = "3")]
        pub std_dev: ::core::option::Option<f32>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CompactTable {
        #[prost(string, optional, tag = "1")]
        pub name: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(message, repeated, tag = "2")]
        pub map_values: ::prost::alloc::vec::Vec<compact_table::MapValuesEntry>,
        #[prost(message, repeated, tag = "3")]
        pub map_mappings: ::prost::alloc::vec::Vec<compact_table::MapMappingsEntry>,
    }
    /// Nested message and enum types in `CompactTable`.
    pub mod compact_table {
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct Entry {
            #[prost(uint32, optional, tag = "1")]
            pub value: ::core::option::Option<u32>,
            #[prost(uint32, optional, tag = "2")]
            pub mapping: ::core::option::Option<u32>,
            #[prost(uint64, optional, tag = "3")]
            pub count: ::core::option::Option<u64>,
        }
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct MapValuesEntry {
            #[prost(uint32, optional, tag = "1")]
            pub key: ::core::option::Option<u32>,
            #[prost(message, optional, tag = "2")]
            pub value: ::core::option::Option<Entry>,
        }
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct MapMappingsEntry {
            #[prost(uint32, optional, tag = "1")]
            pub key: ::core::option::Option<u32>,
            #[prost(message, optional, tag = "2")]
            pub value: ::core::option::Option<Entry>,
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct KMeans {
        #[prost(string, optional, tag = "1")]
        pub name: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(message, repeated, tag = "2")]
        pub clusters: ::prost::alloc::vec::Vec<k_means::Cluster>,
    }
    /// Nested message and enum types in `KMeans`.
    pub mod k_means {
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct Cluster {
            #[prost(float, optional, tag = "1")]
            pub x: ::core::option::Option<f32>,
            #[prost(float, optional, tag = "2")]
            pub y: ::core::option::Option<f32>,
            #[prost(float, optional, tag = "3")]
            pub radius: ::core::option::Option<f32>,
            #[prost(float, optional, tag = "4")]
            pub radius_75pct: ::core::option::Option<f32>,
            #[prost(float, optional, tag = "5")]
            pub radius_50pct: ::core::option::Option<f32>,
            #[prost(float, optional, tag = "6")]
            pub radius_25pct: ::core::option::Option<f32>,
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SnapshotHistogram {
        #[prost(float, optional, tag = "1")]
        pub min_value: ::core::option::Option<f32>,
        #[prost(float, optional, tag = "2")]
        pub max_value: ::core::option::Option<f32>,
        #[prost(uint32, optional, tag = "3")]
        pub num_buckets: ::core::option::Option<u32>,
        #[prost(uint32, repeated, packed = "false", tag = "4")]
        pub bucket_counts: ::prost::alloc::vec::Vec<u32>,
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgSteamLearnInferenceBackendResponse {
    #[prost(message, repeated, tag = "1")]
    pub outputs: ::prost::alloc::vec::Vec<c_msg_steam_learn_inference_backend_response::Output>,
}
/// Nested message and enum types in `CMsgSteamLearn_InferenceBackend_Response`.
pub mod c_msg_steam_learn_inference_backend_response {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct RegressionOutput {
        #[prost(float, optional, tag = "1")]
        pub value: ::core::option::Option<f32>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct BinaryCrossEntropyOutput {
        #[prost(float, optional, tag = "1")]
        pub value: ::core::option::Option<f32>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct MutliBinaryCrossEntropyOutput {
        #[prost(float, repeated, packed = "false", tag = "1")]
        pub weight: ::prost::alloc::vec::Vec<f32>,
        #[prost(float, repeated, packed = "false", tag = "2")]
        pub value: ::prost::alloc::vec::Vec<f32>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CategoricalCrossEntropyOutput {
        #[prost(float, repeated, packed = "false", tag = "1")]
        pub weight: ::prost::alloc::vec::Vec<f32>,
        #[prost(float, repeated, packed = "false", tag = "2")]
        pub value: ::prost::alloc::vec::Vec<f32>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Output {
        #[prost(oneof = "output::ResponseType", tags = "1, 2, 3, 4")]
        pub response_type: ::core::option::Option<output::ResponseType>,
    }
    /// Nested message and enum types in `Output`.
    pub mod output {
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum ResponseType {
            #[prost(message, tag = "1")]
            BinaryCrossentropy(super::BinaryCrossEntropyOutput),
            #[prost(message, tag = "2")]
            CategoricalCrossentropy(super::CategoricalCrossEntropyOutput),
            #[prost(message, tag = "3")]
            MultiBinaryCrossentropy(super::MutliBinaryCrossEntropyOutput),
            #[prost(message, tag = "4")]
            Regression(super::RegressionOutput),
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgSteamLearnInferenceResponse {
    #[prost(
        enumeration = "ESteamLearnInferenceResult",
        optional,
        tag = "1",
        default = "SteamlearnInferenceError"
    )]
    pub inference_result: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "2")]
    pub backend_response: ::core::option::Option<CMsgSteamLearnInferenceBackendResponse>,
    #[prost(uint64, repeated, packed = "false", tag = "3")]
    pub keys: ::prost::alloc::vec::Vec<u64>,
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum ESteamLearnDataType {
    SteamlearnDatatypeInvalid = 0,
    SteamlearnDatatypeInt32 = 1,
    SteamlearnDatatypeFloat32 = 2,
    SteamlearnDatatypeBool = 3,
    SteamlearnDatatypeString = 4,
    SteamlearnDatatypeObject = 5,
}
impl ESteamLearnDataType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic
    /// use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ESteamLearnDataType::SteamlearnDatatypeInvalid => "STEAMLEARN_DATATYPE_INVALID",
            ESteamLearnDataType::SteamlearnDatatypeInt32 => "STEAMLEARN_DATATYPE_INT32",
            ESteamLearnDataType::SteamlearnDatatypeFloat32 => "STEAMLEARN_DATATYPE_FLOAT32",
            ESteamLearnDataType::SteamlearnDatatypeBool => "STEAMLEARN_DATATYPE_BOOL",
            ESteamLearnDataType::SteamlearnDatatypeString => "STEAMLEARN_DATATYPE_STRING",
            ESteamLearnDataType::SteamlearnDatatypeObject => "STEAMLEARN_DATATYPE_OBJECT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "STEAMLEARN_DATATYPE_INVALID" => Some(Self::SteamlearnDatatypeInvalid),
            "STEAMLEARN_DATATYPE_INT32" => Some(Self::SteamlearnDatatypeInt32),
            "STEAMLEARN_DATATYPE_FLOAT32" => Some(Self::SteamlearnDatatypeFloat32),
            "STEAMLEARN_DATATYPE_BOOL" => Some(Self::SteamlearnDatatypeBool),
            "STEAMLEARN_DATATYPE_STRING" => Some(Self::SteamlearnDatatypeString),
            "STEAMLEARN_DATATYPE_OBJECT" => Some(Self::SteamlearnDatatypeObject),
            _ => None,
        }
    }
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum ESteammLearnRegisterDataSourceResult {
    SteamlearnRegisterDataSourceResultError = 0,
    SteamlearnRegisterDataSourceResultSuccessCreated = 1,
    SteamlearnRegisterDataSourceResultSuccessFound = 2,
    SteamlearnRegisterDataSourceResultErrorGeneric = 3,
    SteamlearnRegisterDataSourceResultErrorInvalidName = 4,
    SteamlearnRegisterDataSourceResultErrorInvalidVersion = 5,
    SteamlearnRegisterDataSourceResultErrorDataChanged = 6,
    SteamlearnRegisterDataSourceResultErrorDataInvalid = 7,
    SteamlearnRegisterDataSourceResultErrorForbidden = 8,
    SteamlearnRegisterDataSourceResultErrorInvalidTimestamp = 9,
    SteamlearnRegisterDataSourceResultDisabled = 10,
}
impl ESteammLearnRegisterDataSourceResult {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic
    /// use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ESteammLearnRegisterDataSourceResult::SteamlearnRegisterDataSourceResultError => {
                "STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR"
            }
            ESteammLearnRegisterDataSourceResult::SteamlearnRegisterDataSourceResultSuccessCreated => {
                "STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_SUCCESS_CREATED"
            }
            ESteammLearnRegisterDataSourceResult::SteamlearnRegisterDataSourceResultSuccessFound => {
                "STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_SUCCESS_FOUND"
            }
            ESteammLearnRegisterDataSourceResult::SteamlearnRegisterDataSourceResultErrorGeneric => {
                "STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_GENERIC"
            }
            ESteammLearnRegisterDataSourceResult::SteamlearnRegisterDataSourceResultErrorInvalidName => {
                "STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_INVALID_NAME"
            }
            ESteammLearnRegisterDataSourceResult::SteamlearnRegisterDataSourceResultErrorInvalidVersion => {
                "STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_INVALID_VERSION"
            }
            ESteammLearnRegisterDataSourceResult::SteamlearnRegisterDataSourceResultErrorDataChanged => {
                "STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_DATA_CHANGED"
            }
            ESteammLearnRegisterDataSourceResult::SteamlearnRegisterDataSourceResultErrorDataInvalid => {
                "STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_DATA_INVALID"
            }
            ESteammLearnRegisterDataSourceResult::SteamlearnRegisterDataSourceResultErrorForbidden => {
                "STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_FORBIDDEN"
            }
            ESteammLearnRegisterDataSourceResult::SteamlearnRegisterDataSourceResultErrorInvalidTimestamp => {
                "STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_INVALID_TIMESTAMP"
            }
            ESteammLearnRegisterDataSourceResult::SteamlearnRegisterDataSourceResultDisabled => {
                "STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_DISABLED"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR" => {
                Some(Self::SteamlearnRegisterDataSourceResultError)
            }
            "STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_SUCCESS_CREATED" => {
                Some(Self::SteamlearnRegisterDataSourceResultSuccessCreated)
            }
            "STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_SUCCESS_FOUND" => {
                Some(Self::SteamlearnRegisterDataSourceResultSuccessFound)
            }
            "STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_GENERIC" => {
                Some(Self::SteamlearnRegisterDataSourceResultErrorGeneric)
            }
            "STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_INVALID_NAME" => {
                Some(Self::SteamlearnRegisterDataSourceResultErrorInvalidName)
            }
            "STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_INVALID_VERSION" => {
                Some(Self::SteamlearnRegisterDataSourceResultErrorInvalidVersion)
            }
            "STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_DATA_CHANGED" => {
                Some(Self::SteamlearnRegisterDataSourceResultErrorDataChanged)
            }
            "STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_DATA_INVALID" => {
                Some(Self::SteamlearnRegisterDataSourceResultErrorDataInvalid)
            }
            "STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_FORBIDDEN" => {
                Some(Self::SteamlearnRegisterDataSourceResultErrorForbidden)
            }
            "STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_INVALID_TIMESTAMP" => {
                Some(Self::SteamlearnRegisterDataSourceResultErrorInvalidTimestamp)
            }
            "STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_DISABLED" => {
                Some(Self::SteamlearnRegisterDataSourceResultDisabled)
            }
            _ => None,
        }
    }
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum ESteamLearnCacheDataResult {
    SteamlearnCacheDataError = 0,
    SteamlearnCacheDataSuccess = 1,
    SteamlearnCacheDataErrorUnknownDataSource = 2,
    SteamlearnCacheDataErrorUncachedDataSource = 3,
    SteamlearnCacheDataErrorInvalidKeys = 4,
    SteamlearnCacheDataErrorForbidden = 5,
    SteamlearnCacheDataErrorInvalidTimestamp = 6,
    SteamlearnCacheDataDisabled = 7,
}
impl ESteamLearnCacheDataResult {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic
    /// use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ESteamLearnCacheDataResult::SteamlearnCacheDataError => "STEAMLEARN_CACHE_DATA_ERROR",
            ESteamLearnCacheDataResult::SteamlearnCacheDataSuccess => {
                "STEAMLEARN_CACHE_DATA_SUCCESS"
            }
            ESteamLearnCacheDataResult::SteamlearnCacheDataErrorUnknownDataSource => {
                "STEAMLEARN_CACHE_DATA_ERROR_UNKNOWN_DATA_SOURCE"
            }
            ESteamLearnCacheDataResult::SteamlearnCacheDataErrorUncachedDataSource => {
                "STEAMLEARN_CACHE_DATA_ERROR_UNCACHED_DATA_SOURCE"
            }
            ESteamLearnCacheDataResult::SteamlearnCacheDataErrorInvalidKeys => {
                "STEAMLEARN_CACHE_DATA_ERROR_INVALID_KEYS"
            }
            ESteamLearnCacheDataResult::SteamlearnCacheDataErrorForbidden => {
                "STEAMLEARN_CACHE_DATA_ERROR_FORBIDDEN"
            }
            ESteamLearnCacheDataResult::SteamlearnCacheDataErrorInvalidTimestamp => {
                "STEAMLEARN_CACHE_DATA_ERROR_INVALID_TIMESTAMP"
            }
            ESteamLearnCacheDataResult::SteamlearnCacheDataDisabled => {
                "STEAMLEARN_CACHE_DATA_DISABLED"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "STEAMLEARN_CACHE_DATA_ERROR" => Some(Self::SteamlearnCacheDataError),
            "STEAMLEARN_CACHE_DATA_SUCCESS" => Some(Self::SteamlearnCacheDataSuccess),
            "STEAMLEARN_CACHE_DATA_ERROR_UNKNOWN_DATA_SOURCE" => {
                Some(Self::SteamlearnCacheDataErrorUnknownDataSource)
            }
            "STEAMLEARN_CACHE_DATA_ERROR_UNCACHED_DATA_SOURCE" => {
                Some(Self::SteamlearnCacheDataErrorUncachedDataSource)
            }
            "STEAMLEARN_CACHE_DATA_ERROR_INVALID_KEYS" => {
                Some(Self::SteamlearnCacheDataErrorInvalidKeys)
            }
            "STEAMLEARN_CACHE_DATA_ERROR_FORBIDDEN" => {
                Some(Self::SteamlearnCacheDataErrorForbidden)
            }
            "STEAMLEARN_CACHE_DATA_ERROR_INVALID_TIMESTAMP" => {
                Some(Self::SteamlearnCacheDataErrorInvalidTimestamp)
            }
            "STEAMLEARN_CACHE_DATA_DISABLED" => Some(Self::SteamlearnCacheDataDisabled),
            _ => None,
        }
    }
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum ESteamLearnSnapshotProjectResult {
    SteamlearnSnapshotProjectError = 0,
    SteamlearnSnapshotProjectSuccessStored = 1,
    SteamlearnSnapshotProjectSuccessQueued = 2,
    SteamlearnSnapshotProjectErrorInvalidProjectId = 3,
    SteamlearnSnapshotProjectErrorUnknownDataSource = 4,
    SteamlearnSnapshotProjectErrorInvalidDataSourceKey = 5,
    SteamlearnSnapshotProjectErrorMissingCacheDuration = 6,
    SteamlearnSnapshotProjectErrorNoPublishedConfig = 7,
    SteamlearnSnapshotProjectErrorForbidden = 8,
    SteamlearnSnapshotProjectErrorInvalidTimestamp = 9,
    SteamlearnSnapshotProjectErrorInternalDataSourceError = 10,
    SteamlearnSnapshotProjectDisabled = 11,
    SteamlearnSnapshotProjectErrorInvalidPublishedVersion = 12,
}
impl ESteamLearnSnapshotProjectResult {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic
    /// use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ESteamLearnSnapshotProjectResult::SteamlearnSnapshotProjectError => {
                "STEAMLEARN_SNAPSHOT_PROJECT_ERROR"
            }
            ESteamLearnSnapshotProjectResult::SteamlearnSnapshotProjectSuccessStored => {
                "STEAMLEARN_SNAPSHOT_PROJECT_SUCCESS_STORED"
            }
            ESteamLearnSnapshotProjectResult::SteamlearnSnapshotProjectSuccessQueued => {
                "STEAMLEARN_SNAPSHOT_PROJECT_SUCCESS_QUEUED"
            }
            ESteamLearnSnapshotProjectResult::SteamlearnSnapshotProjectErrorInvalidProjectId => {
                "STEAMLEARN_SNAPSHOT_PROJECT_ERROR_INVALID_PROJECT_ID"
            }
            ESteamLearnSnapshotProjectResult::SteamlearnSnapshotProjectErrorUnknownDataSource => {
                "STEAMLEARN_SNAPSHOT_PROJECT_ERROR_UNKNOWN_DATA_SOURCE"
            }
            ESteamLearnSnapshotProjectResult::SteamlearnSnapshotProjectErrorInvalidDataSourceKey => {
                "STEAMLEARN_SNAPSHOT_PROJECT_ERROR_INVALID_DATA_SOURCE_KEY"
            }
            ESteamLearnSnapshotProjectResult::SteamlearnSnapshotProjectErrorMissingCacheDuration => {
                "STEAMLEARN_SNAPSHOT_PROJECT_ERROR_MISSING_CACHE_DURATION"
            }
            ESteamLearnSnapshotProjectResult::SteamlearnSnapshotProjectErrorNoPublishedConfig => {
                "STEAMLEARN_SNAPSHOT_PROJECT_ERROR_NO_PUBLISHED_CONFIG"
            }
            ESteamLearnSnapshotProjectResult::SteamlearnSnapshotProjectErrorForbidden => {
                "STEAMLEARN_SNAPSHOT_PROJECT_ERROR_FORBIDDEN"
            }
            ESteamLearnSnapshotProjectResult::SteamlearnSnapshotProjectErrorInvalidTimestamp => {
                "STEAMLEARN_SNAPSHOT_PROJECT_ERROR_INVALID_TIMESTAMP"
            }
            ESteamLearnSnapshotProjectResult::SteamlearnSnapshotProjectErrorInternalDataSourceError => {
                "STEAMLEARN_SNAPSHOT_PROJECT_ERROR_INTERNAL_DATA_SOURCE_ERROR"
            }
            ESteamLearnSnapshotProjectResult::SteamlearnSnapshotProjectDisabled => {
                "STEAMLEARN_SNAPSHOT_PROJECT_DISABLED"
            }
            ESteamLearnSnapshotProjectResult::SteamlearnSnapshotProjectErrorInvalidPublishedVersion => {
                "STEAMLEARN_SNAPSHOT_PROJECT_ERROR_INVALID_PUBLISHED_VERSION"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "STEAMLEARN_SNAPSHOT_PROJECT_ERROR" => Some(Self::SteamlearnSnapshotProjectError),
            "STEAMLEARN_SNAPSHOT_PROJECT_SUCCESS_STORED" => {
                Some(Self::SteamlearnSnapshotProjectSuccessStored)
            }
            "STEAMLEARN_SNAPSHOT_PROJECT_SUCCESS_QUEUED" => {
                Some(Self::SteamlearnSnapshotProjectSuccessQueued)
            }
            "STEAMLEARN_SNAPSHOT_PROJECT_ERROR_INVALID_PROJECT_ID" => {
                Some(Self::SteamlearnSnapshotProjectErrorInvalidProjectId)
            }
            "STEAMLEARN_SNAPSHOT_PROJECT_ERROR_UNKNOWN_DATA_SOURCE" => {
                Some(Self::SteamlearnSnapshotProjectErrorUnknownDataSource)
            }
            "STEAMLEARN_SNAPSHOT_PROJECT_ERROR_INVALID_DATA_SOURCE_KEY" => {
                Some(Self::SteamlearnSnapshotProjectErrorInvalidDataSourceKey)
            }
            "STEAMLEARN_SNAPSHOT_PROJECT_ERROR_MISSING_CACHE_DURATION" => {
                Some(Self::SteamlearnSnapshotProjectErrorMissingCacheDuration)
            }
            "STEAMLEARN_SNAPSHOT_PROJECT_ERROR_NO_PUBLISHED_CONFIG" => {
                Some(Self::SteamlearnSnapshotProjectErrorNoPublishedConfig)
            }
            "STEAMLEARN_SNAPSHOT_PROJECT_ERROR_FORBIDDEN" => {
                Some(Self::SteamlearnSnapshotProjectErrorForbidden)
            }
            "STEAMLEARN_SNAPSHOT_PROJECT_ERROR_INVALID_TIMESTAMP" => {
                Some(Self::SteamlearnSnapshotProjectErrorInvalidTimestamp)
            }
            "STEAMLEARN_SNAPSHOT_PROJECT_ERROR_INTERNAL_DATA_SOURCE_ERROR" => {
                Some(Self::SteamlearnSnapshotProjectErrorInternalDataSourceError)
            }
            "STEAMLEARN_SNAPSHOT_PROJECT_DISABLED" => Some(Self::SteamlearnSnapshotProjectDisabled),
            "STEAMLEARN_SNAPSHOT_PROJECT_ERROR_INVALID_PUBLISHED_VERSION" => {
                Some(Self::SteamlearnSnapshotProjectErrorInvalidPublishedVersion)
            }
            _ => None,
        }
    }
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum ESteamLearnGetAccessTokensResult {
    SteamlearnGetAccessTokensError = 0,
    SteamlearnGetAccessTokensSuccess = 1,
}
impl ESteamLearnGetAccessTokensResult {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic
    /// use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ESteamLearnGetAccessTokensResult::SteamlearnGetAccessTokensError => {
                "STEAMLEARN_GET_ACCESS_TOKENS_ERROR"
            }
            ESteamLearnGetAccessTokensResult::SteamlearnGetAccessTokensSuccess => {
                "STEAMLEARN_GET_ACCESS_TOKENS_SUCCESS"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "STEAMLEARN_GET_ACCESS_TOKENS_ERROR" => Some(Self::SteamlearnGetAccessTokensError),
            "STEAMLEARN_GET_ACCESS_TOKENS_SUCCESS" => Some(Self::SteamlearnGetAccessTokensSuccess),
            _ => None,
        }
    }
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum ESteamLearnInferenceResult {
    SteamlearnInferenceError = 0,
    SteamlearnInferenceSuccess = 1,
    SteamlearnInferenceErrorInvalidProjectId = 2,
    SteamlearnInferenceErrorMissingCachedSchemaData = 3,
    SteamlearnInferenceErrorNoPublishedConfig = 4,
    SteamlearnInferenceErrorForbidden = 5,
    SteamlearnInferenceErrorInvalidTimestamp = 6,
    SteamlearnInferenceErrorInvalidPublishedVersion = 7,
    SteamlearnInferenceErrorNoFetchIdFound = 8,
    SteamlearnInferenceErrorTooBusy = 9,
}
impl ESteamLearnInferenceResult {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic
    /// use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ESteamLearnInferenceResult::SteamlearnInferenceError => "STEAMLEARN_INFERENCE_ERROR",
            ESteamLearnInferenceResult::SteamlearnInferenceSuccess => {
                "STEAMLEARN_INFERENCE_SUCCESS"
            }
            ESteamLearnInferenceResult::SteamlearnInferenceErrorInvalidProjectId => {
                "STEAMLEARN_INFERENCE_ERROR_INVALID_PROJECT_ID"
            }
            ESteamLearnInferenceResult::SteamlearnInferenceErrorMissingCachedSchemaData => {
                "STEAMLEARN_INFERENCE_ERROR_MISSING_CACHED_SCHEMA_DATA"
            }
            ESteamLearnInferenceResult::SteamlearnInferenceErrorNoPublishedConfig => {
                "STEAMLEARN_INFERENCE_ERROR_NO_PUBLISHED_CONFIG"
            }
            ESteamLearnInferenceResult::SteamlearnInferenceErrorForbidden => {
                "STEAMLEARN_INFERENCE_ERROR_FORBIDDEN"
            }
            ESteamLearnInferenceResult::SteamlearnInferenceErrorInvalidTimestamp => {
                "STEAMLEARN_INFERENCE_ERROR_INVALID_TIMESTAMP"
            }
            ESteamLearnInferenceResult::SteamlearnInferenceErrorInvalidPublishedVersion => {
                "STEAMLEARN_INFERENCE_ERROR_INVALID_PUBLISHED_VERSION"
            }
            ESteamLearnInferenceResult::SteamlearnInferenceErrorNoFetchIdFound => {
                "STEAMLEARN_INFERENCE_ERROR_NO_FETCH_ID_FOUND"
            }
            ESteamLearnInferenceResult::SteamlearnInferenceErrorTooBusy => {
                "STEAMLEARN_INFERENCE_ERROR_TOO_BUSY"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "STEAMLEARN_INFERENCE_ERROR" => Some(Self::SteamlearnInferenceError),
            "STEAMLEARN_INFERENCE_SUCCESS" => Some(Self::SteamlearnInferenceSuccess),
            "STEAMLEARN_INFERENCE_ERROR_INVALID_PROJECT_ID" => {
                Some(Self::SteamlearnInferenceErrorInvalidProjectId)
            }
            "STEAMLEARN_INFERENCE_ERROR_MISSING_CACHED_SCHEMA_DATA" => {
                Some(Self::SteamlearnInferenceErrorMissingCachedSchemaData)
            }
            "STEAMLEARN_INFERENCE_ERROR_NO_PUBLISHED_CONFIG" => {
                Some(Self::SteamlearnInferenceErrorNoPublishedConfig)
            }
            "STEAMLEARN_INFERENCE_ERROR_FORBIDDEN" => Some(Self::SteamlearnInferenceErrorForbidden),
            "STEAMLEARN_INFERENCE_ERROR_INVALID_TIMESTAMP" => {
                Some(Self::SteamlearnInferenceErrorInvalidTimestamp)
            }
            "STEAMLEARN_INFERENCE_ERROR_INVALID_PUBLISHED_VERSION" => {
                Some(Self::SteamlearnInferenceErrorInvalidPublishedVersion)
            }
            "STEAMLEARN_INFERENCE_ERROR_NO_FETCH_ID_FOUND" => {
                Some(Self::SteamlearnInferenceErrorNoFetchIdFound)
            }
            "STEAMLEARN_INFERENCE_ERROR_TOO_BUSY" => Some(Self::SteamlearnInferenceErrorTooBusy),
            _ => None,
        }
    }
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum ESteamLearnInferenceMetadataResult {
    SteamlearnInferenceMetadataError = 0,
    SteamlearnInferenceMetadataSuccess = 1,
    SteamlearnInferenceMetadataErrorInvalidProjectId = 2,
    SteamlearnInferenceMetadataErrorNoPublishedConfig = 3,
    SteamlearnInferenceMetadataErrorForbidden = 4,
    SteamlearnInferenceMetadataErrorInvalidTimestamp = 5,
    SteamlearnInferenceMetadataErrorInvalidPublishedVersion = 6,
    SteamlearnInferenceMetadataErrorNoFetchIdFound = 7,
}
impl ESteamLearnInferenceMetadataResult {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic
    /// use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ESteamLearnInferenceMetadataResult::SteamlearnInferenceMetadataError => {
                "STEAMLEARN_INFERENCE_METADATA_ERROR"
            }
            ESteamLearnInferenceMetadataResult::SteamlearnInferenceMetadataSuccess => {
                "STEAMLEARN_INFERENCE_METADATA_SUCCESS"
            }
            ESteamLearnInferenceMetadataResult::SteamlearnInferenceMetadataErrorInvalidProjectId => {
                "STEAMLEARN_INFERENCE_METADATA_ERROR_INVALID_PROJECT_ID"
            }
            ESteamLearnInferenceMetadataResult::SteamlearnInferenceMetadataErrorNoPublishedConfig => {
                "STEAMLEARN_INFERENCE_METADATA_ERROR_NO_PUBLISHED_CONFIG"
            }
            ESteamLearnInferenceMetadataResult::SteamlearnInferenceMetadataErrorForbidden => {
                "STEAMLEARN_INFERENCE_METADATA_ERROR_FORBIDDEN"
            }
            ESteamLearnInferenceMetadataResult::SteamlearnInferenceMetadataErrorInvalidTimestamp => {
                "STEAMLEARN_INFERENCE_METADATA_ERROR_INVALID_TIMESTAMP"
            }
            ESteamLearnInferenceMetadataResult::SteamlearnInferenceMetadataErrorInvalidPublishedVersion => {
                "STEAMLEARN_INFERENCE_METADATA_ERROR_INVALID_PUBLISHED_VERSION"
            }
            ESteamLearnInferenceMetadataResult::SteamlearnInferenceMetadataErrorNoFetchIdFound => {
                "STEAMLEARN_INFERENCE_METADATA_ERROR_NO_FETCH_ID_FOUND"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "STEAMLEARN_INFERENCE_METADATA_ERROR" => Some(Self::SteamlearnInferenceMetadataError),
            "STEAMLEARN_INFERENCE_METADATA_SUCCESS" => {
                Some(Self::SteamlearnInferenceMetadataSuccess)
            }
            "STEAMLEARN_INFERENCE_METADATA_ERROR_INVALID_PROJECT_ID" => {
                Some(Self::SteamlearnInferenceMetadataErrorInvalidProjectId)
            }
            "STEAMLEARN_INFERENCE_METADATA_ERROR_NO_PUBLISHED_CONFIG" => {
                Some(Self::SteamlearnInferenceMetadataErrorNoPublishedConfig)
            }
            "STEAMLEARN_INFERENCE_METADATA_ERROR_FORBIDDEN" => {
                Some(Self::SteamlearnInferenceMetadataErrorForbidden)
            }
            "STEAMLEARN_INFERENCE_METADATA_ERROR_INVALID_TIMESTAMP" => {
                Some(Self::SteamlearnInferenceMetadataErrorInvalidTimestamp)
            }
            "STEAMLEARN_INFERENCE_METADATA_ERROR_INVALID_PUBLISHED_VERSION" => {
                Some(Self::SteamlearnInferenceMetadataErrorInvalidPublishedVersion)
            }
            "STEAMLEARN_INFERENCE_METADATA_ERROR_NO_FETCH_ID_FOUND" => {
                Some(Self::SteamlearnInferenceMetadataErrorNoFetchIdFound)
            }
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CExtraMsgBlock {
    #[prost(uint32, optional, tag = "1")]
    pub msg_type: ::core::option::Option<u32>,
    #[prost(bytes = "vec", optional, tag = "2")]
    pub contents: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(uint64, optional, tag = "3")]
    pub msg_key: ::core::option::Option<u64>,
    #[prost(bool, optional, tag = "4")]
    pub is_compressed: ::core::option::Option<bool>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgSteamLearnServerInfo {
    #[prost(bool, optional, tag = "1")]
    pub enable_data_submission: ::core::option::Option<bool>,
    #[prost(message, optional, tag = "4")]
    pub access_tokens: ::core::option::Option<CMsgSteamLearnAccessTokens>,
    #[prost(message, repeated, tag = "5")]
    pub project_infos: ::prost::alloc::vec::Vec<c_msg_steam_learn_server_info::ProjectInfo>,
}
/// Nested message and enum types in `CMsgSteamLearnServerInfo`.
pub mod c_msg_steam_learn_server_info {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct ProjectInfo {
        #[prost(uint32, optional, tag = "1")]
        pub project_id: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "2")]
        pub snapshot_published_version: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "3")]
        pub inference_published_version: ::core::option::Option<u32>,
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGcAssertJobData {
    #[prost(string, optional, tag = "1")]
    pub message_type: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bytes = "vec", optional, tag = "2")]
    pub message_data: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGcConCommand {
    #[prost(string, optional, tag = "1")]
    pub command: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgSdoAssert {
    #[prost(int32, optional, tag = "1")]
    pub sdo_type: ::core::option::Option<i32>,
    #[prost(message, repeated, tag = "2")]
    pub requests: ::prost::alloc::vec::Vec<c_msg_sdo_assert::Request>,
}
/// Nested message and enum types in `CMsgSDOAssert`.
pub mod c_msg_sdo_assert {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Request {
        #[prost(uint64, repeated, packed = "false", tag = "1")]
        pub key: ::prost::alloc::vec::Vec<u64>,
        #[prost(string, optional, tag = "2")]
        pub requesting_job: ::core::option::Option<::prost::alloc::string::String>,
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgSoidOwner {
    #[prost(uint32, optional, tag = "1")]
    pub r#type: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "2")]
    pub id: ::core::option::Option<u64>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgSoSingleObject {
    #[prost(int32, optional, tag = "2")]
    pub type_id: ::core::option::Option<i32>,
    #[prost(bytes = "vec", optional, tag = "3")]
    pub object_data: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(fixed64, optional, tag = "4")]
    pub version: ::core::option::Option<u64>,
    #[prost(message, optional, tag = "5")]
    pub owner_soid: ::core::option::Option<CMsgSoidOwner>,
    #[prost(uint32, optional, tag = "6")]
    pub service_id: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgSoMultipleObjects {
    #[prost(message, repeated, tag = "2")]
    pub objects_modified: ::prost::alloc::vec::Vec<c_msg_so_multiple_objects::SingleObject>,
    #[prost(fixed64, optional, tag = "3")]
    pub version: ::core::option::Option<u64>,
    #[prost(message, repeated, tag = "4")]
    pub objects_added: ::prost::alloc::vec::Vec<c_msg_so_multiple_objects::SingleObject>,
    #[prost(message, repeated, tag = "5")]
    pub objects_removed: ::prost::alloc::vec::Vec<c_msg_so_multiple_objects::SingleObject>,
    #[prost(message, optional, tag = "6")]
    pub owner_soid: ::core::option::Option<CMsgSoidOwner>,
    #[prost(uint32, optional, tag = "7")]
    pub service_id: ::core::option::Option<u32>,
}
/// Nested message and enum types in `CMsgSOMultipleObjects`.
pub mod c_msg_so_multiple_objects {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SingleObject {
        #[prost(int32, optional, tag = "1")]
        pub type_id: ::core::option::Option<i32>,
        #[prost(bytes = "vec", optional, tag = "2")]
        pub object_data: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgSoCacheSubscribed {
    #[prost(message, repeated, tag = "2")]
    pub objects: ::prost::alloc::vec::Vec<c_msg_so_cache_subscribed::SubscribedType>,
    #[prost(fixed64, optional, tag = "3")]
    pub version: ::core::option::Option<u64>,
    #[prost(message, optional, tag = "4")]
    pub owner_soid: ::core::option::Option<CMsgSoidOwner>,
    #[prost(uint32, optional, tag = "5")]
    pub service_id: ::core::option::Option<u32>,
    #[prost(uint32, repeated, packed = "false", tag = "6")]
    pub service_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(fixed64, optional, tag = "7")]
    pub sync_version: ::core::option::Option<u64>,
}
/// Nested message and enum types in `CMsgSOCacheSubscribed`.
pub mod c_msg_so_cache_subscribed {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SubscribedType {
        #[prost(int32, optional, tag = "1")]
        pub type_id: ::core::option::Option<i32>,
        #[prost(bytes = "vec", repeated, tag = "2")]
        pub object_data: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgSoCacheSubscribedUpToDate {
    #[prost(fixed64, optional, tag = "1")]
    pub version: ::core::option::Option<u64>,
    #[prost(message, optional, tag = "2")]
    pub owner_soid: ::core::option::Option<CMsgSoidOwner>,
    #[prost(uint32, optional, tag = "3")]
    pub service_id: ::core::option::Option<u32>,
    #[prost(uint32, repeated, packed = "false", tag = "4")]
    pub service_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(fixed64, optional, tag = "5")]
    pub sync_version: ::core::option::Option<u64>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgSoCacheUnsubscribed {
    #[prost(message, optional, tag = "2")]
    pub owner_soid: ::core::option::Option<CMsgSoidOwner>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgSoCacheSubscriptionCheck {
    #[prost(fixed64, optional, tag = "2")]
    pub version: ::core::option::Option<u64>,
    #[prost(message, optional, tag = "3")]
    pub owner_soid: ::core::option::Option<CMsgSoidOwner>,
    #[prost(uint32, optional, tag = "4")]
    pub service_id: ::core::option::Option<u32>,
    #[prost(uint32, repeated, packed = "false", tag = "5")]
    pub service_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(fixed64, optional, tag = "6")]
    pub sync_version: ::core::option::Option<u64>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgSoCacheSubscriptionRefresh {
    #[prost(message, optional, tag = "2")]
    pub owner_soid: ::core::option::Option<CMsgSoidOwner>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgSoCacheVersion {
    #[prost(fixed64, optional, tag = "1")]
    pub version: ::core::option::Option<u64>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGcMultiplexMessage {
    #[prost(uint32, optional, tag = "1")]
    pub msgtype: ::core::option::Option<u32>,
    #[prost(bytes = "vec", optional, tag = "2")]
    pub payload: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(fixed64, repeated, packed = "false", tag = "3")]
    pub steamids: ::prost::alloc::vec::Vec<u64>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgGcToGcSubGcStarting {
    #[prost(int32, optional, tag = "1", default = "-1")]
    pub dir_index: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CgcToGcMsgMasterAck {
    #[prost(int32, optional, tag = "1", default = "-1")]
    pub dir_index: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "3")]
    pub machine_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "4")]
    pub process_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "6")]
    pub directory: ::prost::alloc::vec::Vec<cgc_to_gc_msg_master_ack::Process>,
}
/// Nested message and enum types in `CGCToGCMsgMasterAck`.
pub mod cgc_to_gc_msg_master_ack {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Process {
        #[prost(int32, optional, tag = "1", default = "-1")]
        pub dir_index: ::core::option::Option<i32>,
        #[prost(uint32, repeated, packed = "false", tag = "2")]
        pub type_instances: ::prost::alloc::vec::Vec<u32>,
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CgcToGcMsgMasterAckResponse {
    #[prost(int32, optional, tag = "1", default = "2")]
    pub eresult: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgGcToGcUniverseStartup {
    #[prost(bool, optional, tag = "1")]
    pub is_initial_startup: ::core::option::Option<bool>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgGcToGcUniverseStartupResponse {
    #[prost(int32, optional, tag = "1")]
    pub eresult: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CgcToGcMsgMasterStartupComplete {
    #[prost(message, repeated, tag = "1")]
    pub gc_info: ::prost::alloc::vec::Vec<cgc_to_gc_msg_master_startup_complete::GcInfo>,
}
/// Nested message and enum types in `CGCToGCMsgMasterStartupComplete`.
pub mod cgc_to_gc_msg_master_startup_complete {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct GcInfo {
        #[prost(int32, optional, tag = "1", default = "-1")]
        pub dir_index: ::core::option::Option<i32>,
        #[prost(string, optional, tag = "2")]
        pub machine_name: ::core::option::Option<::prost::alloc::string::String>,
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CgcToGcMsgRouted {
    #[prost(uint32, optional, tag = "1")]
    pub msg_type: ::core::option::Option<u32>,
    #[prost(fixed64, optional, tag = "2")]
    pub sender_id: ::core::option::Option<u64>,
    #[prost(bytes = "vec", optional, tag = "3")]
    pub net_message: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CgcToGcMsgRoutedReply {
    #[prost(uint32, optional, tag = "1")]
    pub msg_type: ::core::option::Option<u32>,
    #[prost(bytes = "vec", optional, tag = "2")]
    pub net_message: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGcUpdateSubGcSessionInfo {
    #[prost(message, repeated, tag = "1")]
    pub updates: ::prost::alloc::vec::Vec<c_msg_gc_update_sub_gc_session_info::CMsgUpdate>,
}
/// Nested message and enum types in `CMsgGCUpdateSubGCSessionInfo`.
pub mod c_msg_gc_update_sub_gc_session_info {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct CMsgUpdate {
        #[prost(fixed64, optional, tag = "1")]
        pub steamid: ::core::option::Option<u64>,
        #[prost(fixed32, optional, tag = "2")]
        pub ip: ::core::option::Option<u32>,
        #[prost(bool, optional, tag = "3")]
        pub trusted: ::core::option::Option<bool>,
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgGcRequestSubGcSessionInfo {
    #[prost(fixed64, optional, tag = "1")]
    pub steamid: ::core::option::Option<u64>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgGcRequestSubGcSessionInfoResponse {
    #[prost(fixed32, optional, tag = "1")]
    pub ip: ::core::option::Option<u32>,
    #[prost(bool, optional, tag = "2")]
    pub trusted: ::core::option::Option<bool>,
    #[prost(uint32, optional, tag = "3")]
    pub port: ::core::option::Option<u32>,
    #[prost(bool, optional, tag = "4")]
    pub success: ::core::option::Option<bool>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgSoCacheHaveVersion {
    #[prost(message, optional, tag = "1")]
    pub soid: ::core::option::Option<CMsgSoidOwner>,
    #[prost(fixed64, optional, tag = "2")]
    pub version: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "3")]
    pub service_id: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub cached_file_version: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgClientHello {
    #[prost(uint32, optional, tag = "1")]
    pub version: ::core::option::Option<u32>,
    #[prost(message, repeated, tag = "2")]
    pub socache_have_versions: ::prost::alloc::vec::Vec<CMsgSoCacheHaveVersion>,
    #[prost(uint32, optional, tag = "3")]
    pub client_session_need: ::core::option::Option<u32>,
    #[prost(
        enumeration = "PartnerAccountType",
        optional,
        tag = "4",
        default = "PartnerNone"
    )]
    pub client_launcher: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "5")]
    pub secret_key: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "6")]
    pub client_language: ::core::option::Option<u32>,
    #[prost(
        enumeration = "ESourceEngine",
        optional,
        tag = "7",
        default = "KEseSource1"
    )]
    pub engine: ::core::option::Option<i32>,
    #[prost(bytes = "vec", optional, tag = "8")]
    pub steamdatagram_login: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(uint32, optional, tag = "9")]
    pub platform_id: ::core::option::Option<u32>,
    #[prost(bytes = "vec", optional, tag = "10")]
    pub game_msg: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(int32, optional, tag = "11")]
    pub os_type: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "12")]
    pub render_system: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "13")]
    pub render_system_req: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "14")]
    pub screen_width: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "15")]
    pub screen_height: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "16")]
    pub screen_refresh: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "17")]
    pub render_width: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "18")]
    pub render_height: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "19")]
    pub swap_width: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "20")]
    pub swap_height: ::core::option::Option<u32>,
    #[prost(bool, optional, tag = "22")]
    pub is_steam_china: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "24")]
    pub is_steam_china_client: ::core::option::Option<bool>,
    #[prost(string, optional, tag = "23")]
    pub platform_name: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgClientWelcome {
    #[prost(uint32, optional, tag = "1")]
    pub version: ::core::option::Option<u32>,
    #[prost(bytes = "vec", optional, tag = "2")]
    pub game_data: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(message, repeated, tag = "3")]
    pub outofdate_subscribed_caches: ::prost::alloc::vec::Vec<CMsgSoCacheSubscribed>,
    #[prost(message, repeated, tag = "4")]
    pub uptodate_subscribed_caches: ::prost::alloc::vec::Vec<CMsgSoCacheSubscriptionCheck>,
    #[prost(message, optional, tag = "5")]
    pub location: ::core::option::Option<c_msg_client_welcome::Location>,
    #[prost(uint32, optional, tag = "9")]
    pub gc_socache_file_version: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "10")]
    pub txn_country_code: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bytes = "vec", optional, tag = "11")]
    pub game_data2: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(uint32, optional, tag = "12")]
    pub rtime32_gc_welcome_timestamp: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "13")]
    pub currency: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "14")]
    pub balance: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "15")]
    pub balance_url: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "16")]
    pub has_accepted_china_ssa: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "17")]
    pub is_banned_steam_china: ::core::option::Option<bool>,
    #[prost(message, optional, tag = "18")]
    pub additional_welcome_msgs: ::core::option::Option<CExtraMsgBlock>,
    #[prost(message, optional, tag = "20")]
    pub steam_learn_server_info: ::core::option::Option<CMsgSteamLearnServerInfo>,
}
/// Nested message and enum types in `CMsgClientWelcome`.
pub mod c_msg_client_welcome {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Location {
        #[prost(float, optional, tag = "1")]
        pub latitude: ::core::option::Option<f32>,
        #[prost(float, optional, tag = "2")]
        pub longitude: ::core::option::Option<f32>,
        #[prost(string, optional, tag = "3")]
        pub country: ::core::option::Option<::prost::alloc::string::String>,
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgConnectionStatus {
    #[prost(
        enumeration = "GcConnectionStatus",
        optional,
        tag = "1",
        default = "HaveSession"
    )]
    pub status: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "2")]
    pub client_session_need: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "3")]
    pub queue_position: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "4")]
    pub queue_size: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "5")]
    pub wait_seconds: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "6")]
    pub estimated_wait_seconds_remaining: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGcToGcsoCacheSubscribe {
    #[prost(fixed64, optional, tag = "1")]
    pub subscriber: ::core::option::Option<u64>,
    #[prost(fixed64, optional, tag = "2")]
    pub subscribe_to_id: ::core::option::Option<u64>,
    #[prost(fixed64, optional, tag = "3")]
    pub sync_version: ::core::option::Option<u64>,
    #[prost(message, repeated, tag = "4")]
    pub have_versions: ::prost::alloc::vec::Vec<c_msg_gc_to_gcso_cache_subscribe::CMsgHaveVersions>,
    #[prost(uint32, optional, tag = "5")]
    pub subscribe_to_type: ::core::option::Option<u32>,
}
/// Nested message and enum types in `CMsgGCToGCSOCacheSubscribe`.
pub mod c_msg_gc_to_gcso_cache_subscribe {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct CMsgHaveVersions {
        #[prost(uint32, optional, tag = "1")]
        pub service_id: ::core::option::Option<u32>,
        #[prost(uint64, optional, tag = "2")]
        pub version: ::core::option::Option<u64>,
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgGcToGcsoCacheUnsubscribe {
    #[prost(fixed64, optional, tag = "1")]
    pub subscriber: ::core::option::Option<u64>,
    #[prost(fixed64, optional, tag = "2")]
    pub unsubscribe_from_id: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "3")]
    pub unsubscribe_from_type: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgGcClientPing {}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGcToGcForwardAccountDetails {
    #[prost(fixed64, optional, tag = "1")]
    pub steamid: ::core::option::Option<u64>,
    #[prost(message, optional, tag = "2")]
    pub account_details: ::core::option::Option<CgcSystemMsgGetAccountDetailsResponse>,
    #[prost(uint32, optional, tag = "3")]
    pub age_seconds: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGcToGcLoadSessionSoCache {
    #[prost(uint32, optional, tag = "1")]
    pub account_id: ::core::option::Option<u32>,
    #[prost(message, optional, tag = "2")]
    pub forward_account_details: ::core::option::Option<CMsgGcToGcForwardAccountDetails>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgGcToGcLoadSessionSoCacheResponse {}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgGcToGcUpdateSessionStats {
    #[prost(uint32, optional, tag = "1")]
    pub user_sessions: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub server_sessions: ::core::option::Option<u32>,
    #[prost(bool, optional, tag = "3")]
    pub in_logon_surge: ::core::option::Option<bool>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgGcToClientRequestDropped {}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CWorkshopPopulateItemDescriptionsRequest {
    #[prost(uint32, optional, tag = "1")]
    pub appid: ::core::option::Option<u32>,
    #[prost(message, repeated, tag = "2")]
    pub languages: ::prost::alloc::vec::Vec<
        c_workshop_populate_item_descriptions_request::ItemDescriptionsLanguageBlock,
    >,
}
/// Nested message and enum types in
/// `CWorkshop_PopulateItemDescriptions_Request`.
pub mod c_workshop_populate_item_descriptions_request {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SingleItemDescription {
        #[prost(uint32, optional, tag = "1")]
        pub gameitemid: ::core::option::Option<u32>,
        #[prost(string, optional, tag = "2")]
        pub item_description: ::core::option::Option<::prost::alloc::string::String>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ItemDescriptionsLanguageBlock {
        #[prost(string, optional, tag = "1")]
        pub language: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(message, repeated, tag = "2")]
        pub descriptions: ::prost::alloc::vec::Vec<SingleItemDescription>,
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CWorkshopGetContributorsRequest {
    #[prost(uint32, optional, tag = "1")]
    pub appid: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub gameitemid: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CWorkshopGetContributorsResponse {
    #[prost(fixed64, repeated, packed = "false", tag = "1")]
    pub contributors: ::prost::alloc::vec::Vec<u64>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CWorkshopSetItemPaymentRulesRequest {
    #[prost(uint32, optional, tag = "1")]
    pub appid: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub gameitemid: ::core::option::Option<u32>,
    #[prost(message, repeated, tag = "3")]
    pub associated_workshop_files: ::prost::alloc::vec::Vec<
        c_workshop_set_item_payment_rules_request::WorkshopItemPaymentRule,
    >,
    #[prost(message, repeated, tag = "4")]
    pub partner_accounts:
        ::prost::alloc::vec::Vec<c_workshop_set_item_payment_rules_request::PartnerItemPaymentRule>,
    #[prost(bool, optional, tag = "5")]
    pub validate_only: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "6")]
    pub make_workshop_files_subscribable: ::core::option::Option<bool>,
    #[prost(message, optional, tag = "7")]
    pub associated_workshop_file_for_direct_payments: ::core::option::Option<
        c_workshop_set_item_payment_rules_request::WorkshopDirectPaymentRule,
    >,
}
/// Nested message and enum types in `CWorkshop_SetItemPaymentRules_Request`.
pub mod c_workshop_set_item_payment_rules_request {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct WorkshopItemPaymentRule {
        #[prost(uint64, optional, tag = "1")]
        pub workshop_file_id: ::core::option::Option<u64>,
        #[prost(float, optional, tag = "2")]
        pub revenue_percentage: ::core::option::Option<f32>,
        #[prost(string, optional, tag = "3")]
        pub rule_description: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(uint32, optional, tag = "4", default = "1")]
        pub rule_type: ::core::option::Option<u32>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct WorkshopDirectPaymentRule {
        #[prost(uint64, optional, tag = "1")]
        pub workshop_file_id: ::core::option::Option<u64>,
        #[prost(string, optional, tag = "2")]
        pub rule_description: ::core::option::Option<::prost::alloc::string::String>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PartnerItemPaymentRule {
        #[prost(uint32, optional, tag = "1")]
        pub account_id: ::core::option::Option<u32>,
        #[prost(float, optional, tag = "2")]
        pub revenue_percentage: ::core::option::Option<f32>,
        #[prost(string, optional, tag = "3")]
        pub rule_description: ::core::option::Option<::prost::alloc::string::String>,
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CWorkshopSetItemPaymentRulesResponse {
    #[prost(string, repeated, tag = "1")]
    pub validation_errors: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CCommunityClanAnnouncementInfo {
    #[prost(uint64, optional, tag = "1")]
    pub gid: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub clanid: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "3")]
    pub posterid: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "4")]
    pub headline: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "5")]
    pub posttime: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "6")]
    pub updatetime: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "7")]
    pub body: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "8")]
    pub commentcount: ::core::option::Option<i32>,
    #[prost(string, repeated, tag = "9")]
    pub tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "10")]
    pub language: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "11")]
    pub hidden: ::core::option::Option<bool>,
    #[prost(fixed64, optional, tag = "12")]
    pub forum_topic_id: ::core::option::Option<u64>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CCommunityGetClanAnnouncementsRequest {
    #[prost(uint64, optional, tag = "1")]
    pub steamid: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "2")]
    pub offset: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub count: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub maxchars: ::core::option::Option<u32>,
    #[prost(bool, optional, tag = "5")]
    pub strip_html: ::core::option::Option<bool>,
    #[prost(string, repeated, tag = "6")]
    pub required_tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "7")]
    pub require_no_tags: ::core::option::Option<bool>,
    #[prost(uint32, repeated, packed = "false", tag = "8")]
    pub language_preference: ::prost::alloc::vec::Vec<u32>,
    #[prost(bool, optional, tag = "9")]
    pub hidden_only: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "10")]
    pub only_gid: ::core::option::Option<bool>,
    #[prost(uint32, optional, tag = "11")]
    pub rtime_oldest_date: ::core::option::Option<u32>,
    #[prost(bool, optional, tag = "12")]
    pub include_hidden: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "13")]
    pub include_partner_events: ::core::option::Option<bool>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CCommunityGetClanAnnouncementsResponse {
    #[prost(uint32, optional, tag = "1")]
    pub maxchars: ::core::option::Option<u32>,
    #[prost(bool, optional, tag = "2")]
    pub strip_html: ::core::option::Option<bool>,
    #[prost(message, repeated, tag = "3")]
    pub announcements: ::prost::alloc::vec::Vec<CCommunityClanAnnouncementInfo>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CBroadcastPostGameDataFrameRequest {
    #[prost(uint32, optional, tag = "1")]
    pub appid: ::core::option::Option<u32>,
    #[prost(fixed64, optional, tag = "2")]
    pub steamid: ::core::option::Option<u64>,
    #[prost(fixed64, optional, tag = "3")]
    pub broadcast_id: ::core::option::Option<u64>,
    #[prost(bytes = "vec", optional, tag = "4")]
    pub frame_data: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgSerializedSoCache {
    #[prost(uint32, optional, tag = "1")]
    pub file_version: ::core::option::Option<u32>,
    #[prost(message, repeated, tag = "2")]
    pub caches: ::prost::alloc::vec::Vec<c_msg_serialized_so_cache::Cache>,
    #[prost(uint32, optional, tag = "3")]
    pub gc_socache_file_version: ::core::option::Option<u32>,
}
/// Nested message and enum types in `CMsgSerializedSOCache`.
pub mod c_msg_serialized_so_cache {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TypeCache {
        #[prost(uint32, optional, tag = "1")]
        pub r#type: ::core::option::Option<u32>,
        #[prost(bytes = "vec", repeated, tag = "2")]
        pub objects: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
        #[prost(uint32, optional, tag = "3")]
        pub service_id: ::core::option::Option<u32>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Cache {
        #[prost(uint32, optional, tag = "1")]
        pub r#type: ::core::option::Option<u32>,
        #[prost(uint64, optional, tag = "2")]
        pub id: ::core::option::Option<u64>,
        #[prost(message, repeated, tag = "3")]
        pub versions: ::prost::alloc::vec::Vec<cache::Version>,
        #[prost(message, repeated, tag = "4")]
        pub type_caches: ::prost::alloc::vec::Vec<TypeCache>,
    }
    /// Nested message and enum types in `Cache`.
    pub mod cache {
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct Version {
            #[prost(uint32, optional, tag = "1")]
            pub service: ::core::option::Option<u32>,
            #[prost(uint64, optional, tag = "2")]
            pub version: ::core::option::Option<u64>,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGcToClientPollConvarRequest {
    #[prost(string, optional, tag = "1")]
    pub convar_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "2")]
    pub poll_id: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGcToClientPollConvarResponse {
    #[prost(uint32, optional, tag = "1")]
    pub poll_id: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "2")]
    pub convar_value: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CgcMsgCompressedMsgToClient {
    #[prost(uint32, optional, tag = "1")]
    pub msg_id: ::core::option::Option<u32>,
    #[prost(bytes = "vec", optional, tag = "2")]
    pub compressed_msg: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGcToGcMasterBroadcastMessage {
    #[prost(uint32, optional, tag = "1")]
    pub users_per_second: ::core::option::Option<u32>,
    #[prost(bool, optional, tag = "2")]
    pub send_to_users: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "3")]
    pub send_to_servers: ::core::option::Option<bool>,
    #[prost(uint32, optional, tag = "4")]
    pub msg_id: ::core::option::Option<u32>,
    #[prost(bytes = "vec", optional, tag = "5")]
    pub msg_data: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGcToGcMasterSubscribeToCache {
    #[prost(uint32, optional, tag = "1")]
    pub soid_type: ::core::option::Option<u32>,
    #[prost(fixed64, optional, tag = "2")]
    pub soid_id: ::core::option::Option<u64>,
    #[prost(uint32, repeated, packed = "false", tag = "3")]
    pub account_ids: ::prost::alloc::vec::Vec<u32>,
    #[prost(fixed64, repeated, packed = "false", tag = "4")]
    pub steam_ids: ::prost::alloc::vec::Vec<u64>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgGcToGcMasterSubscribeToCacheResponse {}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGcToGcMasterSubscribeToCacheAsync {
    #[prost(message, optional, tag = "1")]
    pub subscribe_msg: ::core::option::Option<CMsgGcToGcMasterSubscribeToCache>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGcToGcMasterUnsubscribeFromCache {
    #[prost(uint32, optional, tag = "1")]
    pub soid_type: ::core::option::Option<u32>,
    #[prost(fixed64, optional, tag = "2")]
    pub soid_id: ::core::option::Option<u64>,
    #[prost(uint32, repeated, packed = "false", tag = "3")]
    pub account_ids: ::prost::alloc::vec::Vec<u32>,
    #[prost(fixed64, repeated, packed = "false", tag = "4")]
    pub steam_ids: ::prost::alloc::vec::Vec<u64>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgGcToGcMasterDestroyCache {
    #[prost(uint32, optional, tag = "1")]
    pub soid_type: ::core::option::Option<u32>,
    #[prost(fixed64, optional, tag = "2")]
    pub soid_id: ::core::option::Option<u64>,
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum ESourceEngine {
    KEseSource1 = 0,
    KEseSource2 = 1,
}
impl ESourceEngine {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic
    /// use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ESourceEngine::KEseSource1 => "k_ESE_Source1",
            ESourceEngine::KEseSource2 => "k_ESE_Source2",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "k_ESE_Source1" => Some(Self::KEseSource1),
            "k_ESE_Source2" => Some(Self::KEseSource2),
            _ => None,
        }
    }
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum PartnerAccountType {
    PartnerNone = 0,
    PartnerPerfectWorld = 1,
    PartnerInvalid = 3,
}
impl PartnerAccountType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic
    /// use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            PartnerAccountType::PartnerNone => "PARTNER_NONE",
            PartnerAccountType::PartnerPerfectWorld => "PARTNER_PERFECT_WORLD",
            PartnerAccountType::PartnerInvalid => "PARTNER_INVALID",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PARTNER_NONE" => Some(Self::PartnerNone),
            "PARTNER_PERFECT_WORLD" => Some(Self::PartnerPerfectWorld),
            "PARTNER_INVALID" => Some(Self::PartnerInvalid),
            _ => None,
        }
    }
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum GcConnectionStatus {
    HaveSession = 0,
    GcGoingDown = 1,
    NoSession = 2,
    NoSessionInLogonQueue = 3,
    NoSteam = 4,
    Suspended = 5,
    SteamGoingDown = 6,
}
impl GcConnectionStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic
    /// use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            GcConnectionStatus::HaveSession => "GCConnectionStatus_HAVE_SESSION",
            GcConnectionStatus::GcGoingDown => "GCConnectionStatus_GC_GOING_DOWN",
            GcConnectionStatus::NoSession => "GCConnectionStatus_NO_SESSION",
            GcConnectionStatus::NoSessionInLogonQueue => {
                "GCConnectionStatus_NO_SESSION_IN_LOGON_QUEUE"
            }
            GcConnectionStatus::NoSteam => "GCConnectionStatus_NO_STEAM",
            GcConnectionStatus::Suspended => "GCConnectionStatus_SUSPENDED",
            GcConnectionStatus::SteamGoingDown => "GCConnectionStatus_STEAM_GOING_DOWN",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "GCConnectionStatus_HAVE_SESSION" => Some(Self::HaveSession),
            "GCConnectionStatus_GC_GOING_DOWN" => Some(Self::GcGoingDown),
            "GCConnectionStatus_NO_SESSION" => Some(Self::NoSession),
            "GCConnectionStatus_NO_SESSION_IN_LOGON_QUEUE" => Some(Self::NoSessionInLogonQueue),
            "GCConnectionStatus_NO_STEAM" => Some(Self::NoSteam),
            "GCConnectionStatus_SUSPENDED" => Some(Self::Suspended),
            "GCConnectionStatus_STEAM_GOING_DOWN" => Some(Self::SteamGoingDown),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CsoCitadelLobby {
    #[prost(uint64, optional, tag = "1")]
    pub lobby_id: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub match_id: ::core::option::Option<u64>,
    #[prost(
        enumeration = "ECitadelMatchMode",
        optional,
        tag = "3",
        default = "KECitadelMatchModeInvalid"
    )]
    pub match_mode: ::core::option::Option<i32>,
    #[prost(
        enumeration = "ECitadelGameMode",
        optional,
        tag = "4",
        default = "KECitadelGameModeInvalid"
    )]
    pub game_mode: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "5")]
    pub compatibility_version: ::core::option::Option<u32>,
    #[prost(message, repeated, tag = "6")]
    pub extra_messages: ::prost::alloc::vec::Vec<CExtraMsgBlock>,
    #[prost(fixed64, optional, tag = "7")]
    pub server_steam_id: ::core::option::Option<u64>,
    #[prost(
        enumeration = "ELobbyServerState",
        optional,
        tag = "8",
        default = "KELobbyServerStateAssign"
    )]
    pub server_state: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "9")]
    pub udp_connect_ip: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "10")]
    pub udp_connect_port: ::core::option::Option<u32>,
    #[prost(bytes = "vec", optional, tag = "12")]
    pub sdr_address: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(uint32, optional, tag = "13")]
    pub server_version: ::core::option::Option<u32>,
    #[prost(bool, optional, tag = "14")]
    pub safe_to_abandon: ::core::option::Option<bool>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CLobbyDataPostMatchSurvey {
    #[prost(message, repeated, tag = "1")]
    pub surveys: ::prost::alloc::vec::Vec<c_lobby_data_post_match_survey::PlayerSurvey>,
}
/// Nested message and enum types in `CLobbyData_PostMatchSurvey`.
pub mod c_lobby_data_post_match_survey {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct PlayerSurvey {
        #[prost(uint32, optional, tag = "1")]
        pub account_id: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "2")]
        pub question_id: ::core::option::Option<u32>,
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgHeroSelectionMatchInfo {
    #[prost(message, repeated, tag = "1")]
    pub hero_selections: ::prost::alloc::vec::Vec<c_msg_hero_selection_match_info::Hero>,
}
/// Nested message and enum types in `CMsgHeroSelectionMatchInfo`.
pub mod c_msg_hero_selection_match_info {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Hero {
        #[prost(uint32, optional, tag = "1")]
        pub hero_id: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "2")]
        pub priority: ::core::option::Option<u32>,
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgStartFindingMatchInfo {
    #[prost(string, optional, tag = "1")]
    pub server_search_key: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "2")]
    pub server_command_string: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(
        enumeration = "ECitadelMatchMode",
        optional,
        tag = "3",
        default = "KECitadelMatchModeInvalid"
    )]
    pub match_mode: ::core::option::Option<i32>,
    #[prost(
        enumeration = "ECitadelGameMode",
        optional,
        tag = "5",
        default = "KECitadelGameModeInvalid"
    )]
    pub game_mode: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "6")]
    pub solo_match: ::core::option::Option<bool>,
    #[prost(
        enumeration = "ECitadelBotDifficulty",
        optional,
        tag = "7",
        default = "KECitadelBotDifficultyNone"
    )]
    pub bot_difficulty: ::core::option::Option<i32>,
    #[prost(
        enumeration = "ECitadelRegionMode",
        optional,
        tag = "8",
        default = "KECitadelRegionModeRow"
    )]
    pub region_mode: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgAnyToGcReportAsserts {
    #[prost(uint32, optional, tag = "1")]
    pub version: ::core::option::Option<u32>,
    #[prost(message, repeated, tag = "2")]
    pub asserts: ::prost::alloc::vec::Vec<c_msg_any_to_gc_report_asserts::TrackedAssert>,
}
/// Nested message and enum types in `CMsgAnyToGCReportAsserts`.
pub mod c_msg_any_to_gc_report_asserts {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TrackedAssert {
        #[prost(string, optional, tag = "1")]
        pub filename: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(uint32, optional, tag = "2")]
        pub line_number: ::core::option::Option<u32>,
        #[prost(string, optional, tag = "3")]
        pub sample_msg: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag = "4")]
        pub sample_stack: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(uint32, optional, tag = "5")]
        pub times_fired: ::core::option::Option<u32>,
        #[prost(string, optional, tag = "6")]
        pub function_name: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag = "7")]
        pub condition: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(uint32, optional, tag = "8")]
        pub total_times_fired: ::core::option::Option<u32>,
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgAnyToGcReportAssertsResponse {
    #[prost(bool, optional, tag = "1")]
    pub success: ::core::option::Option<bool>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgRegionPingTimesClient {
    #[prost(fixed32, repeated, tag = "1")]
    pub data_center_codes: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "2")]
    pub ping_times: ::prost::alloc::vec::Vec<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CsoCitadelParty {
    #[prost(uint64, optional, tag = "1")]
    pub party_id: ::core::option::Option<u64>,
    #[prost(message, repeated, tag = "2")]
    pub members: ::prost::alloc::vec::Vec<cso_citadel_party::Member>,
    #[prost(message, repeated, tag = "3")]
    pub invites: ::prost::alloc::vec::Vec<cso_citadel_party::Invite>,
    #[prost(string, optional, tag = "4")]
    pub dev_server_command: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "5")]
    pub left_members: ::prost::alloc::vec::Vec<cso_citadel_party::LeftMember>,
    #[prost(uint64, optional, tag = "6")]
    pub join_code: ::core::option::Option<u64>,
    #[prost(
        enumeration = "ECitadelBotDifficulty",
        optional,
        tag = "7",
        default = "KECitadelBotDifficultyNone"
    )]
    pub bot_difficulty: ::core::option::Option<i32>,
    #[prost(
        enumeration = "ECitadelMatchMode",
        optional,
        tag = "9",
        default = "KECitadelMatchModeInvalid"
    )]
    pub match_mode: ::core::option::Option<i32>,
    #[prost(
        enumeration = "ECitadelGameMode",
        optional,
        tag = "10",
        default = "KECitadelGameModeInvalid"
    )]
    pub game_mode: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "11")]
    pub match_making_start_time: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "12")]
    pub server_search_key: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "13")]
    pub is_high_skill_range_party: ::core::option::Option<bool>,
    #[prost(
        enumeration = "cso_citadel_party::EChatMode",
        optional,
        tag = "14",
        default = "KENone"
    )]
    pub chat_mode: ::core::option::Option<i32>,
    #[prost(
        enumeration = "ECitadelRegionMode",
        optional,
        tag = "15",
        default = "KECitadelRegionModeRow"
    )]
    pub region_mode: ::core::option::Option<i32>,
}
/// Nested message and enum types in `CSOCitadelParty`.
pub mod cso_citadel_party {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Member {
        #[prost(uint32, optional, tag = "1")]
        pub account_id: ::core::option::Option<u32>,
        #[prost(string, optional, tag = "2")]
        pub persona_name: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(uint32, optional, tag = "3")]
        pub rights_flags: ::core::option::Option<u32>,
        #[prost(bool, optional, tag = "4")]
        pub is_ready: ::core::option::Option<bool>,
        #[prost(
            enumeration = "EPlayerType",
            optional,
            tag = "5",
            default = "KEPlayerTypePlayer"
        )]
        pub player_type: ::core::option::Option<i32>,
        #[prost(uint32, optional, tag = "6")]
        pub compatibility_version: ::core::option::Option<u32>,
        #[prost(
            enumeration = "super::EgcPlatform",
            optional,
            tag = "7",
            default = "KEGcPlatformNone"
        )]
        pub platform: ::core::option::Option<i32>,
        #[prost(uint32, optional, tag = "8")]
        pub team: ::core::option::Option<u32>,
        #[prost(message, optional, tag = "9")]
        pub hero_roster: ::core::option::Option<super::CMsgHeroSelectionMatchInfo>,
        #[prost(uint64, optional, tag = "10")]
        pub permissions: ::core::option::Option<u64>,
        #[prost(uint64, optional, tag = "11")]
        pub new_player_progress: ::core::option::Option<u64>,
        #[prost(uint32, repeated, tag = "12")]
        pub owned_heroes: ::prost::alloc::vec::Vec<u32>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct LeftMember {
        #[prost(uint32, optional, tag = "1")]
        pub account_id: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "2")]
        pub rights_flags: ::core::option::Option<u32>,
        #[prost(
            enumeration = "EPlayerType",
            optional,
            tag = "3",
            default = "KEPlayerTypePlayer"
        )]
        pub player_type: ::core::option::Option<i32>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Invite {
        #[prost(uint32, optional, tag = "1")]
        pub account_id: ::core::option::Option<u32>,
        #[prost(string, optional, tag = "2")]
        pub persona_name: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(uint32, optional, tag = "3")]
        pub invited_by: ::core::option::Option<u32>,
    }
    #[derive(
        serde::Serialize,
        serde::Deserialize,
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration,
    )]
    #[repr(i32)]
    pub enum EMemberRights {
        KEMemberRightsAdmin = 1,
        KEMemberRightsCreator = 2,
    }
    impl EMemberRights {
        /// String value of the enum field names used in the ProtoBuf
        /// definition.
        ///
        /// The values are not transformed in any way and thus are considered
        /// stable (if the ProtoBuf definition does not change) and safe
        /// for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                EMemberRights::KEMemberRightsAdmin => "k_eMemberRights_Admin",
                EMemberRights::KEMemberRightsCreator => "k_eMemberRights_Creator",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "k_eMemberRights_Admin" => Some(Self::KEMemberRightsAdmin),
                "k_eMemberRights_Creator" => Some(Self::KEMemberRightsCreator),
                _ => None,
            }
        }
    }
    #[derive(
        serde::Serialize,
        serde::Deserialize,
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration,
    )]
    #[repr(i32)]
    pub enum EPlayerType {
        KEPlayerTypePlayer = 0,
        KEPlayerTypeSpectator = 1,
    }
    impl EPlayerType {
        /// String value of the enum field names used in the ProtoBuf
        /// definition.
        ///
        /// The values are not transformed in any way and thus are considered
        /// stable (if the ProtoBuf definition does not change) and safe
        /// for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                EPlayerType::KEPlayerTypePlayer => "k_ePlayerType_Player",
                EPlayerType::KEPlayerTypeSpectator => "k_ePlayerType_Spectator",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "k_ePlayerType_Player" => Some(Self::KEPlayerTypePlayer),
                "k_ePlayerType_Spectator" => Some(Self::KEPlayerTypeSpectator),
                _ => None,
            }
        }
    }
    #[derive(
        serde::Serialize,
        serde::Deserialize,
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration,
    )]
    #[repr(i32)]
    pub enum EChatMode {
        KENone = 0,
        KEPartyChat = 1,
        KETeamChat = 2,
    }
    impl EChatMode {
        /// String value of the enum field names used in the ProtoBuf
        /// definition.
        ///
        /// The values are not transformed in any way and thus are considered
        /// stable (if the ProtoBuf definition does not change) and safe
        /// for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                EChatMode::KENone => "k_eNone",
                EChatMode::KEPartyChat => "k_ePartyChat",
                EChatMode::KETeamChat => "k_eTeamChat",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "k_eNone" => Some(Self::KENone),
                "k_ePartyChat" => Some(Self::KEPartyChat),
                "k_eTeamChat" => Some(Self::KETeamChat),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgMatchPlayerPathsData {
    #[prost(uint32, optional, tag = "1")]
    pub version: ::core::option::Option<u32>,
    #[prost(float, optional, tag = "2")]
    pub interval_s: ::core::option::Option<f32>,
    #[prost(uint32, optional, tag = "3")]
    pub x_resolution: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub y_resolution: ::core::option::Option<u32>,
    #[prost(message, repeated, tag = "5")]
    pub paths: ::prost::alloc::vec::Vec<c_msg_match_player_paths_data::Path>,
}
/// Nested message and enum types in `CMsgMatchPlayerPathsData`.
pub mod c_msg_match_player_paths_data {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Path {
        #[prost(uint32, optional, tag = "1")]
        pub player_slot: ::core::option::Option<u32>,
        #[prost(float, optional, tag = "2")]
        pub x_min: ::core::option::Option<f32>,
        #[prost(float, optional, tag = "3")]
        pub y_min: ::core::option::Option<f32>,
        #[prost(float, optional, tag = "4")]
        pub x_max: ::core::option::Option<f32>,
        #[prost(float, optional, tag = "5")]
        pub y_max: ::core::option::Option<f32>,
        #[prost(uint32, repeated, tag = "6")]
        pub x_pos: ::prost::alloc::vec::Vec<u32>,
        #[prost(uint32, repeated, tag = "7")]
        pub y_pos: ::prost::alloc::vec::Vec<u32>,
        #[prost(bool, repeated, tag = "8")]
        pub alive: ::prost::alloc::vec::Vec<bool>,
        #[prost(uint32, repeated, tag = "9")]
        pub health: ::prost::alloc::vec::Vec<u32>,
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgMatchPlayerDamageMatrix {
    #[prost(message, repeated, tag = "1")]
    pub damage_dealers: ::prost::alloc::vec::Vec<c_msg_match_player_damage_matrix::DamageDealer>,
    #[prost(uint32, repeated, tag = "2")]
    pub sample_time_s: ::prost::alloc::vec::Vec<u32>,
    #[prost(message, optional, tag = "3")]
    pub source_details: ::core::option::Option<c_msg_match_player_damage_matrix::SourceDetails>,
}
/// Nested message and enum types in `CMsgMatchPlayerDamageMatrix`.
pub mod c_msg_match_player_damage_matrix {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DamageToPlayer {
        #[prost(uint32, optional, tag = "1")]
        pub target_player_slot: ::core::option::Option<u32>,
        #[prost(uint32, repeated, tag = "2")]
        pub damage: ::prost::alloc::vec::Vec<u32>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DamageSource {
        #[prost(message, repeated, tag = "2")]
        pub damage_to_players: ::prost::alloc::vec::Vec<DamageToPlayer>,
        #[prost(uint32, optional, tag = "4")]
        pub source_details_index: ::core::option::Option<u32>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DamageDealer {
        #[prost(uint32, optional, tag = "1")]
        pub dealer_player_slot: ::core::option::Option<u32>,
        #[prost(message, repeated, tag = "2")]
        pub damage_sources: ::prost::alloc::vec::Vec<DamageSource>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SourceDetails {
        #[prost(enumeration = "EStatType", repeated, tag = "1")]
        pub stat_type: ::prost::alloc::vec::Vec<i32>,
        #[prost(string, repeated, tag = "2")]
        pub source_name: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
    #[derive(
        serde::Serialize,
        serde::Deserialize,
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration,
    )]
    #[repr(i32)]
    pub enum EStatType {
        KETypeDamage = 0,
        KETypeHealing = 1,
        KETypeHealPrevented = 2,
        KETypeMitigated = 3,
        KETypeLethalDamage = 4,
    }
    impl EStatType {
        /// String value of the enum field names used in the ProtoBuf
        /// definition.
        ///
        /// The values are not transformed in any way and thus are considered
        /// stable (if the ProtoBuf definition does not change) and safe
        /// for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                EStatType::KETypeDamage => "k_eType_Damage",
                EStatType::KETypeHealing => "k_eType_Healing",
                EStatType::KETypeHealPrevented => "k_eType_HealPrevented",
                EStatType::KETypeMitigated => "k_eType_Mitigated",
                EStatType::KETypeLethalDamage => "k_eType_LethalDamage",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "k_eType_Damage" => Some(Self::KETypeDamage),
                "k_eType_Healing" => Some(Self::KETypeHealing),
                "k_eType_HealPrevented" => Some(Self::KETypeHealPrevented),
                "k_eType_Mitigated" => Some(Self::KETypeMitigated),
                "k_eType_LethalDamage" => Some(Self::KETypeLethalDamage),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgMatchMetaDataContents {
    #[prost(message, optional, tag = "2")]
    pub match_info: ::core::option::Option<c_msg_match_meta_data_contents::MatchInfo>,
}
/// Nested message and enum types in `CMsgMatchMetaDataContents`.
pub mod c_msg_match_meta_data_contents {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Position {
        #[prost(float, optional, tag = "1")]
        pub x: ::core::option::Option<f32>,
        #[prost(float, optional, tag = "2")]
        pub y: ::core::option::Option<f32>,
        #[prost(float, optional, tag = "3")]
        pub z: ::core::option::Option<f32>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Deaths {
        #[prost(uint32, optional, tag = "1")]
        pub game_time_s: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "9")]
        pub killer_player_slot: ::core::option::Option<u32>,
        #[prost(message, optional, tag = "10")]
        pub death_pos: ::core::option::Option<Position>,
        #[prost(message, optional, tag = "11")]
        pub killer_pos: ::core::option::Option<Position>,
        #[prost(uint32, optional, tag = "12")]
        pub death_duration_s: ::core::option::Option<u32>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Items {
        #[prost(uint32, optional, tag = "1")]
        pub game_time_s: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "2")]
        pub item_id: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "3")]
        pub upgrade_id: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "4")]
        pub sold_time_s: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "5")]
        pub flags: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "6")]
        pub imbued_ability_id: ::core::option::Option<u32>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Ping {
        #[prost(uint32, optional, tag = "1")]
        pub ping_type: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "2")]
        pub ping_data: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "3")]
        pub game_time_s: ::core::option::Option<u32>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct GoldSource {
        #[prost(
            enumeration = "EGoldSource",
            optional,
            tag = "1",
            default = "KEPlayers"
        )]
        pub source: ::core::option::Option<i32>,
        #[prost(uint32, optional, tag = "2")]
        pub kills: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "3")]
        pub damage: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "4")]
        pub gold: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "5")]
        pub gold_orbs: ::core::option::Option<u32>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CustomUserStatInfo {
        #[prost(string, optional, tag = "1")]
        pub name: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(uint32, optional, tag = "2")]
        pub id: ::core::option::Option<u32>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct CustomUserStat {
        #[prost(uint32, optional, tag = "2")]
        pub value: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "3")]
        pub id: ::core::option::Option<u32>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PlayerStats {
        #[prost(uint32, optional, tag = "1")]
        pub time_stamp_s: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "2")]
        pub net_worth: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "3")]
        pub gold_player: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "4")]
        pub gold_player_orbs: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "5")]
        pub gold_lane_creep_orbs: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "6")]
        pub gold_neutral_creep_orbs: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "7")]
        pub gold_boss: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "8")]
        pub gold_boss_orb: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "9")]
        pub gold_treasure: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "10")]
        pub gold_denied: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "11")]
        pub gold_death_loss: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "12")]
        pub gold_lane_creep: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "13")]
        pub gold_neutral_creep: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "14")]
        pub kills: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "15")]
        pub deaths: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "16")]
        pub assists: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "17")]
        pub creep_kills: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "18")]
        pub neutral_kills: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "19")]
        pub possible_creeps: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "20")]
        pub creep_damage: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "21")]
        pub player_damage: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "22")]
        pub neutral_damage: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "23")]
        pub boss_damage: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "24")]
        pub denies: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "25")]
        pub player_healing: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "26")]
        pub ability_points: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "27")]
        pub self_healing: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "28")]
        pub player_damage_taken: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "29")]
        pub max_health: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "30")]
        pub weapon_power: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "31")]
        pub tech_power: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "32")]
        pub shots_hit: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "33")]
        pub shots_missed: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "34")]
        pub damage_absorbed: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "35")]
        pub absorption_provided: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "36")]
        pub hero_bullets_hit: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "37")]
        pub hero_bullets_hit_crit: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "38")]
        pub heal_prevented: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "39")]
        pub heal_lost: ::core::option::Option<u32>,
        #[prost(message, repeated, tag = "40")]
        pub gold_sources: ::prost::alloc::vec::Vec<GoldSource>,
        #[prost(message, repeated, tag = "41")]
        pub custom_user_stats: ::prost::alloc::vec::Vec<CustomUserStat>,
        #[prost(uint32, optional, tag = "42")]
        pub damage_mitigated: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "43")]
        pub level: ::core::option::Option<u32>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct AbilityStat {
        #[prost(uint32, optional, tag = "1")]
        pub ability_id: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "2")]
        pub ability_value: ::core::option::Option<u32>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct BookReward {
        #[prost(uint32, optional, tag = "1")]
        pub book_id: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "2")]
        pub xp_amount: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "3")]
        pub starting_xp: ::core::option::Option<u32>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Players {
        #[prost(uint32, optional, tag = "1")]
        pub account_id: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "2")]
        pub player_slot: ::core::option::Option<u32>,
        #[prost(message, repeated, tag = "3")]
        pub death_details: ::prost::alloc::vec::Vec<Deaths>,
        #[prost(message, repeated, tag = "4")]
        pub items: ::prost::alloc::vec::Vec<Items>,
        #[prost(message, repeated, tag = "5")]
        pub stats: ::prost::alloc::vec::Vec<PlayerStats>,
        #[prost(
            enumeration = "super::ECitadelLobbyTeam",
            optional,
            tag = "6",
            default = "KECitadelLobbyTeamTeam0"
        )]
        pub team: ::core::option::Option<i32>,
        #[prost(uint32, optional, tag = "8")]
        pub kills: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "9")]
        pub deaths: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "10")]
        pub assists: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "11")]
        pub net_worth: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "12")]
        pub hero_id: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "13")]
        pub last_hits: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "14")]
        pub denies: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "15")]
        pub ability_points: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "16")]
        pub party: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "17")]
        pub assigned_lane: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "18")]
        pub level: ::core::option::Option<u32>,
        #[prost(message, repeated, tag = "19")]
        pub pings: ::prost::alloc::vec::Vec<Ping>,
        #[prost(message, repeated, tag = "20")]
        pub ability_stats: ::prost::alloc::vec::Vec<AbilityStat>,
        #[prost(float, repeated, tag = "21")]
        pub stats_type_stat: ::prost::alloc::vec::Vec<f32>,
        #[prost(message, repeated, tag = "22")]
        pub book_rewards: ::prost::alloc::vec::Vec<BookReward>,
        #[prost(uint32, optional, tag = "23")]
        pub abandon_match_time_s: ::core::option::Option<u32>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Objective {
        #[prost(
            enumeration = "super::ECitadelObjective",
            optional,
            tag = "1",
            default = "KECitadelObjectiveTeam0Core"
        )]
        pub legacy_objective_id: ::core::option::Option<i32>,
        #[prost(uint32, optional, tag = "2")]
        pub destroyed_time_s: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "4")]
        pub creep_damage: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "5")]
        pub creep_damage_mitigated: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "6")]
        pub player_damage: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "7")]
        pub player_damage_mitigated: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "8")]
        pub first_damage_time_s: ::core::option::Option<u32>,
        #[prost(
            enumeration = "super::ECitadelTeamObjective",
            optional,
            tag = "9",
            default = "KECitadelTeamObjectiveCore"
        )]
        pub team_objective_id: ::core::option::Option<i32>,
        #[prost(
            enumeration = "super::ECitadelLobbyTeam",
            optional,
            tag = "10",
            default = "KECitadelLobbyTeamTeam0"
        )]
        pub team: ::core::option::Option<i32>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct MidBoss {
        #[prost(
            enumeration = "super::ECitadelLobbyTeam",
            optional,
            tag = "1",
            default = "KECitadelLobbyTeamTeam0"
        )]
        pub team_killed: ::core::option::Option<i32>,
        #[prost(
            enumeration = "super::ECitadelLobbyTeam",
            optional,
            tag = "2",
            default = "KECitadelLobbyTeamTeam0"
        )]
        pub team_claimed: ::core::option::Option<i32>,
        #[prost(uint32, optional, tag = "3")]
        pub destroyed_time_s: ::core::option::Option<u32>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Pause {
        #[prost(uint32, optional, tag = "1")]
        pub game_time_s: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "2")]
        pub pause_duration_s: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "3")]
        pub player_slot: ::core::option::Option<u32>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct WatchedDeathReplay {
        #[prost(uint32, optional, tag = "1")]
        pub game_time_s: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "2")]
        pub player_slot: ::core::option::Option<u32>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct MatchInfo {
        #[prost(uint32, optional, tag = "1")]
        pub duration_s: ::core::option::Option<u32>,
        #[prost(
            enumeration = "EMatchOutcome",
            optional,
            tag = "2",
            default = "KEOutcomeTeamWin"
        )]
        pub match_outcome: ::core::option::Option<i32>,
        #[prost(
            enumeration = "super::ECitadelLobbyTeam",
            optional,
            tag = "3",
            default = "KECitadelLobbyTeamTeam0"
        )]
        pub winning_team: ::core::option::Option<i32>,
        #[prost(message, repeated, tag = "4")]
        pub players: ::prost::alloc::vec::Vec<Players>,
        #[prost(uint32, optional, tag = "5")]
        pub start_time: ::core::option::Option<u32>,
        #[prost(uint64, optional, tag = "6")]
        pub match_id: ::core::option::Option<u64>,
        #[prost(uint32, optional, tag = "8")]
        pub legacy_objectives_mask: ::core::option::Option<u32>,
        #[prost(
            enumeration = "super::ECitadelGameMode",
            optional,
            tag = "9",
            default = "KECitadelGameModeInvalid"
        )]
        pub game_mode: ::core::option::Option<i32>,
        #[prost(
            enumeration = "super::ECitadelMatchMode",
            optional,
            tag = "10",
            default = "KECitadelMatchModeInvalid"
        )]
        pub match_mode: ::core::option::Option<i32>,
        #[prost(message, repeated, tag = "11")]
        pub objectives: ::prost::alloc::vec::Vec<Objective>,
        #[prost(message, optional, tag = "12")]
        pub match_paths: ::core::option::Option<super::CMsgMatchPlayerPathsData>,
        #[prost(message, optional, tag = "13")]
        pub damage_matrix: ::core::option::Option<super::CMsgMatchPlayerDamageMatrix>,
        #[prost(message, repeated, tag = "14")]
        pub match_pauses: ::prost::alloc::vec::Vec<Pause>,
        #[prost(message, repeated, tag = "15")]
        pub custom_user_stats: ::prost::alloc::vec::Vec<CustomUserStatInfo>,
        #[prost(message, repeated, tag = "16")]
        pub watched_death_replays: ::prost::alloc::vec::Vec<WatchedDeathReplay>,
        #[prost(uint64, optional, tag = "17")]
        pub objectives_mask_team0: ::core::option::Option<u64>,
        #[prost(uint64, optional, tag = "18")]
        pub objectives_mask_team1: ::core::option::Option<u64>,
        #[prost(message, repeated, tag = "19")]
        pub mid_boss: ::prost::alloc::vec::Vec<MidBoss>,
    }
    #[derive(
        serde::Serialize,
        serde::Deserialize,
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration,
    )]
    #[repr(i32)]
    pub enum EMatchOutcome {
        KEOutcomeTeamWin = 0,
        KEOutcomeError = 1,
    }
    impl EMatchOutcome {
        /// String value of the enum field names used in the ProtoBuf
        /// definition.
        ///
        /// The values are not transformed in any way and thus are considered
        /// stable (if the ProtoBuf definition does not change) and safe
        /// for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                EMatchOutcome::KEOutcomeTeamWin => "k_eOutcome_TeamWin",
                EMatchOutcome::KEOutcomeError => "k_eOutcome_Error",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "k_eOutcome_TeamWin" => Some(Self::KEOutcomeTeamWin),
                "k_eOutcome_Error" => Some(Self::KEOutcomeError),
                _ => None,
            }
        }
    }
    #[derive(
        serde::Serialize,
        serde::Deserialize,
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration,
    )]
    #[repr(i32)]
    pub enum EGoldSource {
        KEPlayers = 1,
        KELaneCreeps = 2,
        KENeutrals = 3,
        KEBosses = 4,
        KETreasure = 5,
        KEAssists = 6,
        KEDenies = 7,
    }
    impl EGoldSource {
        /// String value of the enum field names used in the ProtoBuf
        /// definition.
        ///
        /// The values are not transformed in any way and thus are considered
        /// stable (if the ProtoBuf definition does not change) and safe
        /// for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                EGoldSource::KEPlayers => "k_ePlayers",
                EGoldSource::KELaneCreeps => "k_eLaneCreeps",
                EGoldSource::KENeutrals => "k_eNeutrals",
                EGoldSource::KEBosses => "k_eBosses",
                EGoldSource::KETreasure => "k_eTreasure",
                EGoldSource::KEAssists => "k_eAssists",
                EGoldSource::KEDenies => "k_eDenies",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "k_ePlayers" => Some(Self::KEPlayers),
                "k_eLaneCreeps" => Some(Self::KELaneCreeps),
                "k_eNeutrals" => Some(Self::KENeutrals),
                "k_eBosses" => Some(Self::KEBosses),
                "k_eTreasure" => Some(Self::KETreasure),
                "k_eAssists" => Some(Self::KEAssists),
                "k_eDenies" => Some(Self::KEDenies),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgMatchMetaData {
    #[prost(uint32, optional, tag = "1")]
    pub version: ::core::option::Option<u32>,
    #[prost(bytes = "vec", optional, tag = "2")]
    pub match_details: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(uint64, optional, tag = "3")]
    pub match_id: ::core::option::Option<u64>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgMapLine {
    #[prost(int32, optional, tag = "1")]
    pub x: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub y: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "3")]
    pub initial: ::core::option::Option<bool>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgAccountHeroStats {
    #[prost(uint32, optional, tag = "1")]
    pub hero_id: ::core::option::Option<u32>,
    #[prost(uint32, repeated, packed = "false", tag = "2")]
    pub stat_id: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint64, repeated, packed = "false", tag = "3")]
    pub total_value: ::prost::alloc::vec::Vec<u64>,
    #[prost(uint32, repeated, packed = "false", tag = "4")]
    pub medals_bronze: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, packed = "false", tag = "5")]
    pub medals_silver: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, packed = "false", tag = "6")]
    pub medals_gold: ::prost::alloc::vec::Vec<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgAccountBookStats {
    #[prost(uint32, optional, tag = "1")]
    pub book_id: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub book_xp: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub book_max_xp: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgAccountStats {
    #[prost(uint32, optional, tag = "1")]
    pub account_id: ::core::option::Option<u32>,
    #[prost(message, repeated, tag = "2")]
    pub stats: ::prost::alloc::vec::Vec<CMsgAccountHeroStats>,
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum CMsgLaneColor {
    KELaneColorInvalid = 0,
    KELaneColorYellow = 1,
    KELaneColorOrange = 3,
    KELaneColorBlue = 4,
    KELaneColorPurple = 6,
}
impl CMsgLaneColor {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic
    /// use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            CMsgLaneColor::KELaneColorInvalid => "k_ELaneColor_Invalid",
            CMsgLaneColor::KELaneColorYellow => "k_ELaneColor_Yellow",
            CMsgLaneColor::KELaneColorOrange => "k_ELaneColor_Orange",
            CMsgLaneColor::KELaneColorBlue => "k_ELaneColor_Blue",
            CMsgLaneColor::KELaneColorPurple => "k_ELaneColor_Purple",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "k_ELaneColor_Invalid" => Some(Self::KELaneColorInvalid),
            "k_ELaneColor_Yellow" => Some(Self::KELaneColorYellow),
            "k_ELaneColor_Orange" => Some(Self::KELaneColorOrange),
            "k_ELaneColor_Blue" => Some(Self::KELaneColorBlue),
            "k_ELaneColor_Purple" => Some(Self::KELaneColorPurple),
            _ => None,
        }
    }
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum EgcCitadelCommonMessages {
    KEMsgAnyToGcReportAsserts = 7000,
    KEMsgAnyToGcReportAssertsResponse = 7001,
}
impl EgcCitadelCommonMessages {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic
    /// use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            EgcCitadelCommonMessages::KEMsgAnyToGcReportAsserts => "k_EMsgAnyToGCReportAsserts",
            EgcCitadelCommonMessages::KEMsgAnyToGcReportAssertsResponse => {
                "k_EMsgAnyToGCReportAssertsResponse"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "k_EMsgAnyToGCReportAsserts" => Some(Self::KEMsgAnyToGcReportAsserts),
            "k_EMsgAnyToGCReportAssertsResponse" => Some(Self::KEMsgAnyToGcReportAssertsResponse),
            _ => None,
        }
    }
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum ECitadelMatchMode {
    KECitadelMatchModeInvalid = 0,
    KECitadelMatchModeUnranked = 1,
    KECitadelMatchModePrivateLobby = 2,
    KECitadelMatchModeCoopBot = 3,
    KECitadelMatchModeRanked = 4,
    KECitadelMatchModeServerTest = 5,
    KECitadelMatchModeTutorial = 6,
}
impl ECitadelMatchMode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic
    /// use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ECitadelMatchMode::KECitadelMatchModeInvalid => "k_ECitadelMatchMode_Invalid",
            ECitadelMatchMode::KECitadelMatchModeUnranked => "k_ECitadelMatchMode_Unranked",
            ECitadelMatchMode::KECitadelMatchModePrivateLobby => "k_ECitadelMatchMode_PrivateLobby",
            ECitadelMatchMode::KECitadelMatchModeCoopBot => "k_ECitadelMatchMode_CoopBot",
            ECitadelMatchMode::KECitadelMatchModeRanked => "k_ECitadelMatchMode_Ranked",
            ECitadelMatchMode::KECitadelMatchModeServerTest => "k_ECitadelMatchMode_ServerTest",
            ECitadelMatchMode::KECitadelMatchModeTutorial => "k_ECitadelMatchMode_Tutorial",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "k_ECitadelMatchMode_Invalid" => Some(Self::KECitadelMatchModeInvalid),
            "k_ECitadelMatchMode_Unranked" => Some(Self::KECitadelMatchModeUnranked),
            "k_ECitadelMatchMode_PrivateLobby" => Some(Self::KECitadelMatchModePrivateLobby),
            "k_ECitadelMatchMode_CoopBot" => Some(Self::KECitadelMatchModeCoopBot),
            "k_ECitadelMatchMode_Ranked" => Some(Self::KECitadelMatchModeRanked),
            "k_ECitadelMatchMode_ServerTest" => Some(Self::KECitadelMatchModeServerTest),
            "k_ECitadelMatchMode_Tutorial" => Some(Self::KECitadelMatchModeTutorial),
            _ => None,
        }
    }
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum ECitadelLobbyTeam {
    KECitadelLobbyTeamTeam0 = 0,
    KECitadelLobbyTeamTeam1 = 1,
    KECitadelLobbyTeamSpectator = 16,
}
impl ECitadelLobbyTeam {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic
    /// use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ECitadelLobbyTeam::KECitadelLobbyTeamTeam0 => "k_ECitadelLobbyTeam_Team0",
            ECitadelLobbyTeam::KECitadelLobbyTeamTeam1 => "k_ECitadelLobbyTeam_Team1",
            ECitadelLobbyTeam::KECitadelLobbyTeamSpectator => "k_ECitadelLobbyTeam_Spectator",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "k_ECitadelLobbyTeam_Team0" => Some(Self::KECitadelLobbyTeamTeam0),
            "k_ECitadelLobbyTeam_Team1" => Some(Self::KECitadelLobbyTeamTeam1),
            "k_ECitadelLobbyTeam_Spectator" => Some(Self::KECitadelLobbyTeamSpectator),
            _ => None,
        }
    }
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum ECitadelAccountStatMedal {
    KENone = 0,
    KEBronze = 1,
    KESilver = 2,
    KEGold = 3,
}
impl ECitadelAccountStatMedal {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic
    /// use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ECitadelAccountStatMedal::KENone => "k_eNone",
            ECitadelAccountStatMedal::KEBronze => "k_eBronze",
            ECitadelAccountStatMedal::KESilver => "k_eSilver",
            ECitadelAccountStatMedal::KEGold => "k_eGold",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "k_eNone" => Some(Self::KENone),
            "k_eBronze" => Some(Self::KEBronze),
            "k_eSilver" => Some(Self::KESilver),
            "k_eGold" => Some(Self::KEGold),
            _ => None,
        }
    }
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum ECitadelObjective {
    KECitadelObjectiveTeam0Core = 0,
    KECitadelObjectiveTeam0Tier1Lane1 = 1,
    KECitadelObjectiveTeam0Tier1Lane2 = 2,
    KECitadelObjectiveTeam0Tier1Lane3 = 3,
    KECitadelObjectiveTeam0Tier1Lane4 = 4,
    KECitadelObjectiveTeam0Tier2Lane1 = 5,
    KECitadelObjectiveTeam0Tier2Lane2 = 6,
    KECitadelObjectiveTeam0Tier2Lane3 = 7,
    KECitadelObjectiveTeam0Tier2Lane4 = 8,
    KECitadelObjectiveTeam0Titan = 9,
    KECitadelObjectiveTeam0TitanShieldGenerator1 = 10,
    KECitadelObjectiveTeam0TitanShieldGenerator2 = 11,
    KECitadelObjectiveTeam0BarrackBossLane1 = 12,
    KECitadelObjectiveTeam0BarrackBossLane2 = 13,
    KECitadelObjectiveTeam0BarrackBossLane3 = 14,
    KECitadelObjectiveTeam0BarrackBossLane4 = 15,
    KECitadelObjectiveTeam1Core = 16,
    KECitadelObjectiveTeam1Tier1Lane1 = 17,
    KECitadelObjectiveTeam1Tier1Lane2 = 18,
    KECitadelObjectiveTeam1Tier1Lane3 = 19,
    KECitadelObjectiveTeam1Tier1Lane4 = 20,
    KECitadelObjectiveTeam1Tier2Lane1 = 21,
    KECitadelObjectiveTeam1Tier2Lane2 = 22,
    KECitadelObjectiveTeam1Tier2Lane3 = 23,
    KECitadelObjectiveTeam1Tier2Lane4 = 24,
    KECitadelObjectiveTeam1Titan = 25,
    KECitadelObjectiveTeam1TitanShieldGenerator1 = 26,
    KECitadelObjectiveTeam1TitanShieldGenerator2 = 27,
    KECitadelObjectiveTeam1BarrackBossLane1 = 28,
    KECitadelObjectiveTeam1BarrackBossLane2 = 29,
    KECitadelObjectiveTeam1BarrackBossLane3 = 30,
    KECitadelObjectiveTeam1BarrackBossLane4 = 31,
    KECitadelObjectiveNeutralMid = 32,
}
impl ECitadelObjective {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic
    /// use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ECitadelObjective::KECitadelObjectiveTeam0Core => "k_eCitadelObjective_Team0_Core",
            ECitadelObjective::KECitadelObjectiveTeam0Tier1Lane1 => {
                "k_eCitadelObjective_Team0_Tier1_Lane1"
            }
            ECitadelObjective::KECitadelObjectiveTeam0Tier1Lane2 => {
                "k_eCitadelObjective_Team0_Tier1_Lane2"
            }
            ECitadelObjective::KECitadelObjectiveTeam0Tier1Lane3 => {
                "k_eCitadelObjective_Team0_Tier1_Lane3"
            }
            ECitadelObjective::KECitadelObjectiveTeam0Tier1Lane4 => {
                "k_eCitadelObjective_Team0_Tier1_Lane4"
            }
            ECitadelObjective::KECitadelObjectiveTeam0Tier2Lane1 => {
                "k_eCitadelObjective_Team0_Tier2_Lane1"
            }
            ECitadelObjective::KECitadelObjectiveTeam0Tier2Lane2 => {
                "k_eCitadelObjective_Team0_Tier2_Lane2"
            }
            ECitadelObjective::KECitadelObjectiveTeam0Tier2Lane3 => {
                "k_eCitadelObjective_Team0_Tier2_Lane3"
            }
            ECitadelObjective::KECitadelObjectiveTeam0Tier2Lane4 => {
                "k_eCitadelObjective_Team0_Tier2_Lane4"
            }
            ECitadelObjective::KECitadelObjectiveTeam0Titan => "k_eCitadelObjective_Team0_Titan",
            ECitadelObjective::KECitadelObjectiveTeam0TitanShieldGenerator1 => {
                "k_eCitadelObjective_Team0_TitanShieldGenerator_1"
            }
            ECitadelObjective::KECitadelObjectiveTeam0TitanShieldGenerator2 => {
                "k_eCitadelObjective_Team0_TitanShieldGenerator_2"
            }
            ECitadelObjective::KECitadelObjectiveTeam0BarrackBossLane1 => {
                "k_eCitadelObjective_Team0_BarrackBoss_Lane1"
            }
            ECitadelObjective::KECitadelObjectiveTeam0BarrackBossLane2 => {
                "k_eCitadelObjective_Team0_BarrackBoss_Lane2"
            }
            ECitadelObjective::KECitadelObjectiveTeam0BarrackBossLane3 => {
                "k_eCitadelObjective_Team0_BarrackBoss_Lane3"
            }
            ECitadelObjective::KECitadelObjectiveTeam0BarrackBossLane4 => {
                "k_eCitadelObjective_Team0_BarrackBoss_Lane4"
            }
            ECitadelObjective::KECitadelObjectiveTeam1Core => "k_eCitadelObjective_Team1_Core",
            ECitadelObjective::KECitadelObjectiveTeam1Tier1Lane1 => {
                "k_eCitadelObjective_Team1_Tier1_Lane1"
            }
            ECitadelObjective::KECitadelObjectiveTeam1Tier1Lane2 => {
                "k_eCitadelObjective_Team1_Tier1_Lane2"
            }
            ECitadelObjective::KECitadelObjectiveTeam1Tier1Lane3 => {
                "k_eCitadelObjective_Team1_Tier1_Lane3"
            }
            ECitadelObjective::KECitadelObjectiveTeam1Tier1Lane4 => {
                "k_eCitadelObjective_Team1_Tier1_Lane4"
            }
            ECitadelObjective::KECitadelObjectiveTeam1Tier2Lane1 => {
                "k_eCitadelObjective_Team1_Tier2_Lane1"
            }
            ECitadelObjective::KECitadelObjectiveTeam1Tier2Lane2 => {
                "k_eCitadelObjective_Team1_Tier2_Lane2"
            }
            ECitadelObjective::KECitadelObjectiveTeam1Tier2Lane3 => {
                "k_eCitadelObjective_Team1_Tier2_Lane3"
            }
            ECitadelObjective::KECitadelObjectiveTeam1Tier2Lane4 => {
                "k_eCitadelObjective_Team1_Tier2_Lane4"
            }
            ECitadelObjective::KECitadelObjectiveTeam1Titan => "k_eCitadelObjective_Team1_Titan",
            ECitadelObjective::KECitadelObjectiveTeam1TitanShieldGenerator1 => {
                "k_eCitadelObjective_Team1_TitanShieldGenerator_1"
            }
            ECitadelObjective::KECitadelObjectiveTeam1TitanShieldGenerator2 => {
                "k_eCitadelObjective_Team1_TitanShieldGenerator_2"
            }
            ECitadelObjective::KECitadelObjectiveTeam1BarrackBossLane1 => {
                "k_eCitadelObjective_Team1_BarrackBoss_Lane1"
            }
            ECitadelObjective::KECitadelObjectiveTeam1BarrackBossLane2 => {
                "k_eCitadelObjective_Team1_BarrackBoss_Lane2"
            }
            ECitadelObjective::KECitadelObjectiveTeam1BarrackBossLane3 => {
                "k_eCitadelObjective_Team1_BarrackBoss_Lane3"
            }
            ECitadelObjective::KECitadelObjectiveTeam1BarrackBossLane4 => {
                "k_eCitadelObjective_Team1_BarrackBoss_Lane4"
            }
            ECitadelObjective::KECitadelObjectiveNeutralMid => "k_eCitadelObjective_Neutral_Mid",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "k_eCitadelObjective_Team0_Core" => Some(Self::KECitadelObjectiveTeam0Core),
            "k_eCitadelObjective_Team0_Tier1_Lane1" => {
                Some(Self::KECitadelObjectiveTeam0Tier1Lane1)
            }
            "k_eCitadelObjective_Team0_Tier1_Lane2" => {
                Some(Self::KECitadelObjectiveTeam0Tier1Lane2)
            }
            "k_eCitadelObjective_Team0_Tier1_Lane3" => {
                Some(Self::KECitadelObjectiveTeam0Tier1Lane3)
            }
            "k_eCitadelObjective_Team0_Tier1_Lane4" => {
                Some(Self::KECitadelObjectiveTeam0Tier1Lane4)
            }
            "k_eCitadelObjective_Team0_Tier2_Lane1" => {
                Some(Self::KECitadelObjectiveTeam0Tier2Lane1)
            }
            "k_eCitadelObjective_Team0_Tier2_Lane2" => {
                Some(Self::KECitadelObjectiveTeam0Tier2Lane2)
            }
            "k_eCitadelObjective_Team0_Tier2_Lane3" => {
                Some(Self::KECitadelObjectiveTeam0Tier2Lane3)
            }
            "k_eCitadelObjective_Team0_Tier2_Lane4" => {
                Some(Self::KECitadelObjectiveTeam0Tier2Lane4)
            }
            "k_eCitadelObjective_Team0_Titan" => Some(Self::KECitadelObjectiveTeam0Titan),
            "k_eCitadelObjective_Team0_TitanShieldGenerator_1" => {
                Some(Self::KECitadelObjectiveTeam0TitanShieldGenerator1)
            }
            "k_eCitadelObjective_Team0_TitanShieldGenerator_2" => {
                Some(Self::KECitadelObjectiveTeam0TitanShieldGenerator2)
            }
            "k_eCitadelObjective_Team0_BarrackBoss_Lane1" => {
                Some(Self::KECitadelObjectiveTeam0BarrackBossLane1)
            }
            "k_eCitadelObjective_Team0_BarrackBoss_Lane2" => {
                Some(Self::KECitadelObjectiveTeam0BarrackBossLane2)
            }
            "k_eCitadelObjective_Team0_BarrackBoss_Lane3" => {
                Some(Self::KECitadelObjectiveTeam0BarrackBossLane3)
            }
            "k_eCitadelObjective_Team0_BarrackBoss_Lane4" => {
                Some(Self::KECitadelObjectiveTeam0BarrackBossLane4)
            }
            "k_eCitadelObjective_Team1_Core" => Some(Self::KECitadelObjectiveTeam1Core),
            "k_eCitadelObjective_Team1_Tier1_Lane1" => {
                Some(Self::KECitadelObjectiveTeam1Tier1Lane1)
            }
            "k_eCitadelObjective_Team1_Tier1_Lane2" => {
                Some(Self::KECitadelObjectiveTeam1Tier1Lane2)
            }
            "k_eCitadelObjective_Team1_Tier1_Lane3" => {
                Some(Self::KECitadelObjectiveTeam1Tier1Lane3)
            }
            "k_eCitadelObjective_Team1_Tier1_Lane4" => {
                Some(Self::KECitadelObjectiveTeam1Tier1Lane4)
            }
            "k_eCitadelObjective_Team1_Tier2_Lane1" => {
                Some(Self::KECitadelObjectiveTeam1Tier2Lane1)
            }
            "k_eCitadelObjective_Team1_Tier2_Lane2" => {
                Some(Self::KECitadelObjectiveTeam1Tier2Lane2)
            }
            "k_eCitadelObjective_Team1_Tier2_Lane3" => {
                Some(Self::KECitadelObjectiveTeam1Tier2Lane3)
            }
            "k_eCitadelObjective_Team1_Tier2_Lane4" => {
                Some(Self::KECitadelObjectiveTeam1Tier2Lane4)
            }
            "k_eCitadelObjective_Team1_Titan" => Some(Self::KECitadelObjectiveTeam1Titan),
            "k_eCitadelObjective_Team1_TitanShieldGenerator_1" => {
                Some(Self::KECitadelObjectiveTeam1TitanShieldGenerator1)
            }
            "k_eCitadelObjective_Team1_TitanShieldGenerator_2" => {
                Some(Self::KECitadelObjectiveTeam1TitanShieldGenerator2)
            }
            "k_eCitadelObjective_Team1_BarrackBoss_Lane1" => {
                Some(Self::KECitadelObjectiveTeam1BarrackBossLane1)
            }
            "k_eCitadelObjective_Team1_BarrackBoss_Lane2" => {
                Some(Self::KECitadelObjectiveTeam1BarrackBossLane2)
            }
            "k_eCitadelObjective_Team1_BarrackBoss_Lane3" => {
                Some(Self::KECitadelObjectiveTeam1BarrackBossLane3)
            }
            "k_eCitadelObjective_Team1_BarrackBoss_Lane4" => {
                Some(Self::KECitadelObjectiveTeam1BarrackBossLane4)
            }
            "k_eCitadelObjective_Neutral_Mid" => Some(Self::KECitadelObjectiveNeutralMid),
            _ => None,
        }
    }
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum ECitadelTeamObjective {
    KECitadelTeamObjectiveCore = 0,
    KECitadelTeamObjectiveTier1Lane1 = 1,
    KECitadelTeamObjectiveTier1Lane2 = 2,
    KECitadelTeamObjectiveTier1Lane3 = 3,
    KECitadelTeamObjectiveTier1Lane4 = 4,
    KECitadelTeamObjectiveTier2Lane1 = 5,
    KECitadelTeamObjectiveTier2Lane2 = 6,
    KECitadelTeamObjectiveTier2Lane3 = 7,
    KECitadelTeamObjectiveTier2Lane4 = 8,
    KECitadelTeamObjectiveTitan = 9,
    KECitadelTeamObjectiveTitanShieldGenerator1 = 10,
    KECitadelTeamObjectiveTitanShieldGenerator2 = 11,
    KECitadelTeamObjectiveBarrackBossLane1 = 12,
    KECitadelTeamObjectiveBarrackBossLane2 = 13,
    KECitadelTeamObjectiveBarrackBossLane3 = 14,
    KECitadelTeamObjectiveBarrackBossLane4 = 15,
}
impl ECitadelTeamObjective {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic
    /// use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ECitadelTeamObjective::KECitadelTeamObjectiveCore => "k_eCitadelTeamObjective_Core",
            ECitadelTeamObjective::KECitadelTeamObjectiveTier1Lane1 => {
                "k_eCitadelTeamObjective_Tier1_Lane1"
            }
            ECitadelTeamObjective::KECitadelTeamObjectiveTier1Lane2 => {
                "k_eCitadelTeamObjective_Tier1_Lane2"
            }
            ECitadelTeamObjective::KECitadelTeamObjectiveTier1Lane3 => {
                "k_eCitadelTeamObjective_Tier1_Lane3"
            }
            ECitadelTeamObjective::KECitadelTeamObjectiveTier1Lane4 => {
                "k_eCitadelTeamObjective_Tier1_Lane4"
            }
            ECitadelTeamObjective::KECitadelTeamObjectiveTier2Lane1 => {
                "k_eCitadelTeamObjective_Tier2_Lane1"
            }
            ECitadelTeamObjective::KECitadelTeamObjectiveTier2Lane2 => {
                "k_eCitadelTeamObjective_Tier2_Lane2"
            }
            ECitadelTeamObjective::KECitadelTeamObjectiveTier2Lane3 => {
                "k_eCitadelTeamObjective_Tier2_Lane3"
            }
            ECitadelTeamObjective::KECitadelTeamObjectiveTier2Lane4 => {
                "k_eCitadelTeamObjective_Tier2_Lane4"
            }
            ECitadelTeamObjective::KECitadelTeamObjectiveTitan => "k_eCitadelTeamObjective_Titan",
            ECitadelTeamObjective::KECitadelTeamObjectiveTitanShieldGenerator1 => {
                "k_eCitadelTeamObjective_TitanShieldGenerator_1"
            }
            ECitadelTeamObjective::KECitadelTeamObjectiveTitanShieldGenerator2 => {
                "k_eCitadelTeamObjective_TitanShieldGenerator_2"
            }
            ECitadelTeamObjective::KECitadelTeamObjectiveBarrackBossLane1 => {
                "k_eCitadelTeamObjective_BarrackBoss_Lane1"
            }
            ECitadelTeamObjective::KECitadelTeamObjectiveBarrackBossLane2 => {
                "k_eCitadelTeamObjective_BarrackBoss_Lane2"
            }
            ECitadelTeamObjective::KECitadelTeamObjectiveBarrackBossLane3 => {
                "k_eCitadelTeamObjective_BarrackBoss_Lane3"
            }
            ECitadelTeamObjective::KECitadelTeamObjectiveBarrackBossLane4 => {
                "k_eCitadelTeamObjective_BarrackBoss_Lane4"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "k_eCitadelTeamObjective_Core" => Some(Self::KECitadelTeamObjectiveCore),
            "k_eCitadelTeamObjective_Tier1_Lane1" => Some(Self::KECitadelTeamObjectiveTier1Lane1),
            "k_eCitadelTeamObjective_Tier1_Lane2" => Some(Self::KECitadelTeamObjectiveTier1Lane2),
            "k_eCitadelTeamObjective_Tier1_Lane3" => Some(Self::KECitadelTeamObjectiveTier1Lane3),
            "k_eCitadelTeamObjective_Tier1_Lane4" => Some(Self::KECitadelTeamObjectiveTier1Lane4),
            "k_eCitadelTeamObjective_Tier2_Lane1" => Some(Self::KECitadelTeamObjectiveTier2Lane1),
            "k_eCitadelTeamObjective_Tier2_Lane2" => Some(Self::KECitadelTeamObjectiveTier2Lane2),
            "k_eCitadelTeamObjective_Tier2_Lane3" => Some(Self::KECitadelTeamObjectiveTier2Lane3),
            "k_eCitadelTeamObjective_Tier2_Lane4" => Some(Self::KECitadelTeamObjectiveTier2Lane4),
            "k_eCitadelTeamObjective_Titan" => Some(Self::KECitadelTeamObjectiveTitan),
            "k_eCitadelTeamObjective_TitanShieldGenerator_1" => {
                Some(Self::KECitadelTeamObjectiveTitanShieldGenerator1)
            }
            "k_eCitadelTeamObjective_TitanShieldGenerator_2" => {
                Some(Self::KECitadelTeamObjectiveTitanShieldGenerator2)
            }
            "k_eCitadelTeamObjective_BarrackBoss_Lane1" => {
                Some(Self::KECitadelTeamObjectiveBarrackBossLane1)
            }
            "k_eCitadelTeamObjective_BarrackBoss_Lane2" => {
                Some(Self::KECitadelTeamObjectiveBarrackBossLane2)
            }
            "k_eCitadelTeamObjective_BarrackBoss_Lane3" => {
                Some(Self::KECitadelTeamObjectiveBarrackBossLane3)
            }
            "k_eCitadelTeamObjective_BarrackBoss_Lane4" => {
                Some(Self::KECitadelTeamObjectiveBarrackBossLane4)
            }
            _ => None,
        }
    }
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum ECitadelBotDifficulty {
    KECitadelBotDifficultyNone = 0,
    KECitadelBotDifficultyEasy = 1,
    KECitadelBotDifficultyMedium = 2,
    KECitadelBotDifficultyHard = 3,
    KECitadelBotDifficultyNightmare = 4,
    KECitadelBotDifficultyGuided = 5,
}
impl ECitadelBotDifficulty {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic
    /// use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ECitadelBotDifficulty::KECitadelBotDifficultyNone => "k_ECitadelBotDifficulty_None",
            ECitadelBotDifficulty::KECitadelBotDifficultyEasy => "k_ECitadelBotDifficulty_Easy",
            ECitadelBotDifficulty::KECitadelBotDifficultyMedium => "k_ECitadelBotDifficulty_Medium",
            ECitadelBotDifficulty::KECitadelBotDifficultyHard => "k_ECitadelBotDifficulty_Hard",
            ECitadelBotDifficulty::KECitadelBotDifficultyNightmare => {
                "k_ECitadelBotDifficulty_Nightmare"
            }
            ECitadelBotDifficulty::KECitadelBotDifficultyGuided => "k_ECitadelBotDifficulty_Guided",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "k_ECitadelBotDifficulty_None" => Some(Self::KECitadelBotDifficultyNone),
            "k_ECitadelBotDifficulty_Easy" => Some(Self::KECitadelBotDifficultyEasy),
            "k_ECitadelBotDifficulty_Medium" => Some(Self::KECitadelBotDifficultyMedium),
            "k_ECitadelBotDifficulty_Hard" => Some(Self::KECitadelBotDifficultyHard),
            "k_ECitadelBotDifficulty_Nightmare" => Some(Self::KECitadelBotDifficultyNightmare),
            "k_ECitadelBotDifficulty_Guided" => Some(Self::KECitadelBotDifficultyGuided),
            _ => None,
        }
    }
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum ECitadelRegionMode {
    KECitadelRegionModeRow = 0,
    KECitadelRegionModeEurope = 1,
    KECitadelRegionModeSeAsia = 2,
    KECitadelRegionModeSAmerica = 3,
    KECitadelRegionModeRussia = 4,
    KECitadelRegionModeOceania = 5,
}
impl ECitadelRegionMode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic
    /// use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ECitadelRegionMode::KECitadelRegionModeRow => "k_ECitadelRegionMode_ROW",
            ECitadelRegionMode::KECitadelRegionModeEurope => "k_ECitadelRegionMode_Europe",
            ECitadelRegionMode::KECitadelRegionModeSeAsia => "k_ECitadelRegionMode_SEAsia",
            ECitadelRegionMode::KECitadelRegionModeSAmerica => "k_ECitadelRegionMode_SAmerica",
            ECitadelRegionMode::KECitadelRegionModeRussia => "k_ECitadelRegionMode_Russia",
            ECitadelRegionMode::KECitadelRegionModeOceania => "k_ECitadelRegionMode_Oceania",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "k_ECitadelRegionMode_ROW" => Some(Self::KECitadelRegionModeRow),
            "k_ECitadelRegionMode_Europe" => Some(Self::KECitadelRegionModeEurope),
            "k_ECitadelRegionMode_SEAsia" => Some(Self::KECitadelRegionModeSeAsia),
            "k_ECitadelRegionMode_SAmerica" => Some(Self::KECitadelRegionModeSAmerica),
            "k_ECitadelRegionMode_Russia" => Some(Self::KECitadelRegionModeRussia),
            "k_ECitadelRegionMode_Oceania" => Some(Self::KECitadelRegionModeOceania),
            _ => None,
        }
    }
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum ECitadelGameMode {
    KECitadelGameModeInvalid = 0,
    KECitadelGameModeNormal = 1,
    KECitadelGameMode1v1Test = 2,
    KECitadelGameModeSandbox = 3,
}
impl ECitadelGameMode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic
    /// use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ECitadelGameMode::KECitadelGameModeInvalid => "k_ECitadelGameMode_Invalid",
            ECitadelGameMode::KECitadelGameModeNormal => "k_ECitadelGameMode_Normal",
            ECitadelGameMode::KECitadelGameMode1v1Test => "k_ECitadelGameMode_1v1Test",
            ECitadelGameMode::KECitadelGameModeSandbox => "k_ECitadelGameMode_Sandbox",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "k_ECitadelGameMode_Invalid" => Some(Self::KECitadelGameModeInvalid),
            "k_ECitadelGameMode_Normal" => Some(Self::KECitadelGameModeNormal),
            "k_ECitadelGameMode_1v1Test" => Some(Self::KECitadelGameMode1v1Test),
            "k_ECitadelGameMode_Sandbox" => Some(Self::KECitadelGameModeSandbox),
            _ => None,
        }
    }
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum ELobbyServerState {
    KELobbyServerStateAssign = 0,
    KELobbyServerStateInGame = 1,
    KELobbyServerStatePostMatch = 2,
    KELobbyServerStateSignedOut = 3,
    KELobbyServerStateAbandoned = 4,
}
impl ELobbyServerState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic
    /// use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ELobbyServerState::KELobbyServerStateAssign => "k_eLobbyServerState_Assign",
            ELobbyServerState::KELobbyServerStateInGame => "k_eLobbyServerState_InGame",
            ELobbyServerState::KELobbyServerStatePostMatch => "k_eLobbyServerState_PostMatch",
            ELobbyServerState::KELobbyServerStateSignedOut => "k_eLobbyServerState_SignedOut",
            ELobbyServerState::KELobbyServerStateAbandoned => "k_eLobbyServerState_Abandoned",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "k_eLobbyServerState_Assign" => Some(Self::KELobbyServerStateAssign),
            "k_eLobbyServerState_InGame" => Some(Self::KELobbyServerStateInGame),
            "k_eLobbyServerState_PostMatch" => Some(Self::KELobbyServerStatePostMatch),
            "k_eLobbyServerState_SignedOut" => Some(Self::KELobbyServerStateSignedOut),
            "k_eLobbyServerState_Abandoned" => Some(Self::KELobbyServerStateAbandoned),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CUserMessageEmpty {
    #[prost(uint32, optional, tag = "1")]
    pub empty: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CCitadelUserMessageDamage {
    #[prost(int32, optional, tag = "1")]
    pub damage: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub pre_damage: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub r#type: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "4")]
    pub citadel_type: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "5")]
    pub origin: ::core::option::Option<CMsgVector>,
    #[prost(int32, optional, tag = "6", default = "-1")]
    pub entindex_victim: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "7", default = "-1")]
    pub entindex_inflictor: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "8", default = "-1")]
    pub entindex_attacker: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "9", default = "-1")]
    pub entindex_ability: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "10")]
    pub damage_absorbed: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "11")]
    pub victim_health_max: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "12")]
    pub victim_health_new: ::core::option::Option<i32>,
    #[prost(uint64, optional, tag = "13")]
    pub flags: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "14")]
    pub ability_id: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "15")]
    pub attacker_class: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "16")]
    pub victim_class: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "17")]
    pub victim_shield_max: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "18")]
    pub victim_shield_new: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "19")]
    pub hits: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "20")]
    pub health_lost: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PingCommonData {
    #[prost(uint32, optional, tag = "1")]
    pub ping_message_id: ::core::option::Option<u32>,
    #[prost(message, optional, tag = "2")]
    pub ping_location: ::core::option::Option<CMsgVector>,
    #[prost(uint32, optional, tag = "3", default = "16777215")]
    pub entity_index: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "4", default = "-1")]
    pub sender_player_slot: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "5")]
    pub speech_concept: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "6")]
    pub response_chosen: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(float, optional, tag = "7")]
    pub cooldown_time: ::core::option::Option<f32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CCitadelUserMsgMapPing {
    #[prost(message, required, tag = "1")]
    pub ping_data: PingCommonData,
    #[prost(uint32, optional, tag = "2")]
    pub event_type: ::core::option::Option<u32>,
    #[prost(
        enumeration = "ChatMsgPingMarkerInfo",
        optional,
        tag = "3",
        default = "KEPingMarkerInfoShowMarkerAndSound"
    )]
    pub ping_marker_and_sound_info: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "4")]
    pub pinged_enemy_entity: ::core::option::Option<bool>,
    #[prost(uint32, optional, tag = "5")]
    pub pinged_entity_class: ::core::option::Option<u32>,
    #[prost(bool, optional, tag = "6")]
    pub is_minimap_ping: ::core::option::Option<bool>,
    #[prost(string, optional, tag = "7")]
    pub pinged_hero_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "8")]
    pub is_blind_ping: ::core::option::Option<bool>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CCitadelUserMsgPingWheel {
    #[prost(message, required, tag = "1")]
    pub ping_data: PingCommonData,
    #[prost(uint32, optional, tag = "2")]
    pub ping_wheel_option_id: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CCitadelUserMsgAbilityPing {
    #[prost(message, optional, tag = "1")]
    pub ping_data: ::core::option::Option<PingCommonData>,
    #[prost(uint32, optional, tag = "2")]
    pub ability_id: ::core::option::Option<u32>,
    #[prost(float, optional, tag = "3")]
    pub ability_cooldown: ::core::option::Option<f32>,
    #[prost(
        enumeration = "ChatMsgPingMarkerInfo",
        optional,
        tag = "4",
        default = "KEPingMarkerInfoShowMarkerAndSound"
    )]
    pub ping_marker_and_sound_info: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CCitadelUserMsgQuickResponse {
    #[prost(message, required, tag = "1")]
    pub ping_data: PingCommonData,
    #[prost(uint32, optional, tag = "2")]
    pub responding_to_ping_message_id: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "3", default = "-1")]
    pub responding_to_player_slot: ::core::option::Option<i32>,
    #[prost(
        enumeration = "CMsgLaneColor",
        optional,
        tag = "4",
        default = "KELaneColorInvalid"
    )]
    pub lane_color: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CCitadelUserMsgMapLine {
    #[prost(int32, optional, tag = "1", default = "-1")]
    pub sender_player_slot: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "2")]
    pub mapline: ::core::option::Option<CMsgMapLine>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CCitadelUserMsgTeamRewards {
    #[prost(uint32, optional, tag = "1")]
    pub xp: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub gold: ::core::option::Option<u32>,
    #[prost(bool, optional, tag = "3")]
    pub winner: ::core::option::Option<bool>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CCitadelUserMsgTriggerDamageFlash {
    #[prost(int32, optional, tag = "1", default = "-1")]
    pub entindex_flash_victim: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2", default = "-1")]
    pub entindex_flash_attacker: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub entindex_flash_hitgroup: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "4")]
    pub flash_value: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "5")]
    pub flash_type: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "6")]
    pub flash_flags: ::core::option::Option<u32>,
    #[prost(message, optional, tag = "7")]
    pub flash_position: ::core::option::Option<CMsgVector>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CCitadelUserMsgAbilitiesChanged {
    #[prost(int32, optional, tag = "1", default = "-1")]
    pub entindex_purchaser: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2", default = "-1")]
    pub entindex_ability: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "3")]
    pub ability_id: ::core::option::Option<u32>,
    #[prost(
        enumeration = "c_citadel_user_msg_abilities_changed::Change",
        optional,
        tag = "4",
        default = "EInvalid"
    )]
    pub change: ::core::option::Option<i32>,
}
/// Nested message and enum types in `CCitadelUserMsg_AbilitiesChanged`.
pub mod c_citadel_user_msg_abilities_changed {
    #[derive(
        serde::Serialize,
        serde::Deserialize,
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration,
    )]
    #[repr(i32)]
    pub enum Change {
        EInvalid = -1,
        EPurchased = 0,
        EUpgraded = 1,
        ESold = 2,
        ESwappedActivatedAbility = 3,
    }
    impl Change {
        /// String value of the enum field names used in the ProtoBuf
        /// definition.
        ///
        /// The values are not transformed in any way and thus are considered
        /// stable (if the ProtoBuf definition does not change) and safe
        /// for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Change::EInvalid => "EInvalid",
                Change::EPurchased => "EPurchased",
                Change::EUpgraded => "EUpgraded",
                Change::ESold => "ESold",
                Change::ESwappedActivatedAbility => "ESwappedActivatedAbility",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "EInvalid" => Some(Self::EInvalid),
                "EPurchased" => Some(Self::EPurchased),
                "EUpgraded" => Some(Self::EUpgraded),
                "ESold" => Some(Self::ESold),
                "ESwappedActivatedAbility" => Some(Self::ESwappedActivatedAbility),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CCitadelUserMsgAbilityInterrupted {
    #[prost(int32, optional, tag = "1", default = "-1")]
    pub entindex_victim: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2", default = "-1")]
    pub entindex_interrupter: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "3")]
    pub ability_id_interrupted: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub ability_id_interrupter: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "5")]
    pub hero_id_interrupter: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CCitadelUserMsgAbilityLateFailure {
    #[prost(int32, optional, tag = "1", default = "-1")]
    pub entindex_caster: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2", default = "-1")]
    pub entindex_ability: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "3")]
    pub failure_type: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CCitadelUserMsgRecentDamageSummary {
    #[prost(int32, optional, tag = "1", default = "-1")]
    pub player_slot: ::core::option::Option<i32>,
    #[prost(message, repeated, tag = "2")]
    pub damage_records:
        ::prost::alloc::vec::Vec<c_citadel_user_msg_recent_damage_summary::DamageRecord>,
    #[prost(float, optional, tag = "3")]
    pub start_time: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "4")]
    pub end_time: ::core::option::Option<f32>,
    #[prost(int32, optional, tag = "5")]
    pub total_damage: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "6")]
    pub lost_gold: ::core::option::Option<i32>,
    #[prost(message, repeated, tag = "7")]
    pub modifier_records:
        ::prost::alloc::vec::Vec<c_citadel_user_msg_recent_damage_summary::ModifierRecord>,
}
/// Nested message and enum types in `CCitadelUserMsg_RecentDamageSummary`.
pub mod c_citadel_user_msg_recent_damage_summary {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct DamageRecord {
        #[prost(int32, optional, tag = "1")]
        pub damage: ::core::option::Option<i32>,
        #[prost(int32, optional, tag = "2")]
        pub hits: ::core::option::Option<i32>,
        #[prost(uint32, optional, tag = "3")]
        pub damage_type: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "4")]
        pub hero_id: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "5")]
        pub ability_id: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "6")]
        pub attacker_class: ::core::option::Option<u32>,
        #[prost(int32, optional, tag = "7")]
        pub damage_absorbed: ::core::option::Option<i32>,
        #[prost(bool, optional, tag = "8")]
        pub is_killing_blow: ::core::option::Option<bool>,
        #[prost(uint32, optional, tag = "9")]
        pub victim_hero_id: ::core::option::Option<u32>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct ModifierRecord {
        #[prost(uint32, optional, tag = "1")]
        pub ability_id: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "2")]
        pub modifier_type_id: ::core::option::Option<u32>,
        #[prost(int32, optional, tag = "3", default = "-1")]
        pub entindex_caster: ::core::option::Option<i32>,
        #[prost(float, optional, tag = "4")]
        pub start_time: ::core::option::Option<f32>,
        #[prost(float, optional, tag = "5")]
        pub end_time: ::core::option::Option<f32>,
        #[prost(bool, optional, tag = "6")]
        pub debuff: ::core::option::Option<bool>,
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CCitadelUserMsgSpectatorTeamChanged {
    #[prost(int32, optional, tag = "1")]
    pub teamnumber: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CCitadelUserMsgChatWheel {
    #[prost(uint32, optional, tag = "1")]
    pub chat_message_id: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "2", default = "-1")]
    pub player_slot: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3", default = "-1")]
    pub pawn_entindex: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "4")]
    pub account_id: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "5")]
    pub hero_id: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "6")]
    pub param_1: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(
        enumeration = "CMsgLaneColor",
        optional,
        tag = "7",
        default = "KELaneColorInvalid"
    )]
    pub lane_color: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CCitadelUserMsgChatMsg {
    #[prost(int32, optional, tag = "1", default = "-1")]
    pub player_slot: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "2")]
    pub text: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "3")]
    pub all_chat: ::core::option::Option<bool>,
    #[prost(
        enumeration = "CMsgLaneColor",
        optional,
        tag = "4",
        default = "KELaneColorInvalid"
    )]
    pub lane_color: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CCitadelUserMsgGoldHistory {
    #[prost(int32, optional, tag = "1", default = "-1")]
    pub entindex_player: ::core::option::Option<i32>,
    #[prost(message, repeated, tag = "2")]
    pub minute_records: ::prost::alloc::vec::Vec<c_citadel_user_msg_gold_history::MinuteRecord>,
}
/// Nested message and enum types in `CCitadelUserMsg_GoldHistory`.
pub mod c_citadel_user_msg_gold_history {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct GoldRecord {
        #[prost(int32, optional, tag = "1")]
        pub currency_source: ::core::option::Option<i32>,
        #[prost(int32, optional, tag = "2")]
        pub gold: ::core::option::Option<i32>,
        #[prost(int32, optional, tag = "3")]
        pub events: ::core::option::Option<i32>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct MinuteRecord {
        #[prost(int32, optional, tag = "1")]
        pub match_minute: ::core::option::Option<i32>,
        #[prost(message, repeated, tag = "2")]
        pub gold_records: ::prost::alloc::vec::Vec<GoldRecord>,
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CCitadelUserMsgCameraController {
    #[prost(
        enumeration = "CameraAction",
        required,
        tag = "1",
        default = "KEActionAddOp"
    )]
    pub action: i32,
    #[prost(
        enumeration = "CameraOperation",
        optional,
        tag = "2",
        default = "KECameraOpMaintain"
    )]
    pub operation: ::core::option::Option<i32>,
    #[prost(
        enumeration = "CameraParam",
        optional,
        tag = "3",
        default = "KEParamClearAllOps"
    )]
    pub param: ::core::option::Option<i32>,
    #[prost(float, optional, tag = "4")]
    pub delay: ::core::option::Option<f32>,
    #[prost(bool, optional, tag = "11")]
    pub relative_values: ::core::option::Option<bool>,
    #[prost(uint32, optional, tag = "5")]
    pub context_symbol_id: ::core::option::Option<u32>,
    #[prost(message, optional, tag = "6")]
    pub maintain: ::core::option::Option<c_citadel_user_msg_camera_controller::Maintain>,
    #[prost(message, optional, tag = "7")]
    pub approach: ::core::option::Option<c_citadel_user_msg_camera_controller::Approach>,
    #[prost(message, optional, tag = "8")]
    pub spring: ::core::option::Option<c_citadel_user_msg_camera_controller::Spring>,
    #[prost(message, optional, tag = "9")]
    pub lerp: ::core::option::Option<c_citadel_user_msg_camera_controller::Lerp>,
    #[prost(message, optional, tag = "10")]
    pub lag: ::core::option::Option<c_citadel_user_msg_camera_controller::Lag>,
}
/// Nested message and enum types in `CCitadelUserMsg_CameraController`.
pub mod c_citadel_user_msg_camera_controller {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Maintain {
        #[prost(float, optional, tag = "1", default = "1")]
        pub duration: ::core::option::Option<f32>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Approach {
        #[prost(float, optional, tag = "1", default = "600")]
        pub speed: ::core::option::Option<f32>,
        #[prost(float, optional, tag = "2", default = "600")]
        pub default_speed: ::core::option::Option<f32>,
        #[prost(float, optional, tag = "3", default = "1000")]
        pub acceleration: ::core::option::Option<f32>,
        #[prost(float, optional, tag = "4", default = "0")]
        pub min_duration: ::core::option::Option<f32>,
        #[prost(float, optional, tag = "5")]
        pub approach_float: ::core::option::Option<f32>,
        #[prost(message, optional, tag = "6")]
        pub approach_vector: ::core::option::Option<super::CMsgVector>,
        #[prost(bool, optional, tag = "7")]
        pub chase_default: ::core::option::Option<bool>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Spring {
        #[prost(float, optional, tag = "1", default = "10")]
        pub spring_strength: ::core::option::Option<f32>,
        #[prost(float, optional, tag = "4", default = "0")]
        pub min_speed: ::core::option::Option<f32>,
        #[prost(float, optional, tag = "5", default = "0")]
        pub max_duration: ::core::option::Option<f32>,
        #[prost(float, optional, tag = "6")]
        pub target_float: ::core::option::Option<f32>,
        #[prost(message, optional, tag = "7")]
        pub target_vector: ::core::option::Option<super::CMsgVector>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Lerp {
        #[prost(float, optional, tag = "1")]
        pub start_float: ::core::option::Option<f32>,
        #[prost(message, optional, tag = "2")]
        pub start_vector: ::core::option::Option<super::CMsgVector>,
        #[prost(float, optional, tag = "3")]
        pub end_float: ::core::option::Option<f32>,
        #[prost(message, optional, tag = "4")]
        pub end_vector: ::core::option::Option<super::CMsgVector>,
        #[prost(float, optional, tag = "5")]
        pub bias: ::core::option::Option<f32>,
        #[prost(float, optional, tag = "6")]
        pub gain: ::core::option::Option<f32>,
        #[prost(float, optional, tag = "7", default = "1")]
        pub duration: ::core::option::Option<f32>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Lag {
        #[prost(float, optional, tag = "1")]
        pub min_duration: ::core::option::Option<f32>,
        #[prost(float, optional, tag = "2")]
        pub lag_time: ::core::option::Option<f32>,
        #[prost(float, optional, tag = "3")]
        pub max_speed: ::core::option::Option<f32>,
        #[prost(float, optional, tag = "4")]
        pub spring_strength: ::core::option::Option<f32>,
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CCitadelUserMsgPostMatchDetails {
    #[prost(bytes = "vec", optional, tag = "1")]
    pub match_details: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CCitadelUserMsgChatEvent {
    #[prost(
        enumeration = "ECitadelChatMessage",
        optional,
        tag = "1",
        default = "CitadelChatMessageUnpauseCountdown"
    )]
    pub r#type: ::core::option::Option<i32>,
    #[prost(uint32, repeated, packed = "false", tag = "2")]
    pub values: ::prost::alloc::vec::Vec<u32>,
    #[prost(int32, repeated, packed = "false", tag = "3")]
    pub player_slots: ::prost::alloc::vec::Vec<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CCitadelUserMsgHeroKilled {
    #[prost(int32, optional, tag = "1", default = "-1")]
    pub entindex_victim: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2", default = "-1")]
    pub entindex_inflictor: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3", default = "-1")]
    pub entindex_attacker: ::core::option::Option<i32>,
    #[prost(int32, repeated, packed = "false", tag = "4")]
    pub entindex_assisters: ::prost::alloc::vec::Vec<i32>,
    #[prost(int32, optional, tag = "5", default = "-1")]
    pub entindex_scorer: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "6")]
    pub respawn_reason: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CCitadelEntityMsgBreakablePropSpawnDebris {
    #[prost(message, optional, tag = "1")]
    pub entity_msg: ::core::option::Option<CEntityMsg>,
    #[prost(message, optional, tag = "2")]
    pub damage_pos: ::core::option::Option<CMsgVector>,
    #[prost(float, optional, tag = "3")]
    pub damage: ::core::option::Option<f32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CCitadelUserMsgReturnIdol {
    #[prost(int32, optional, tag = "1")]
    pub location_index: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "2")]
    pub return_location: ::core::option::Option<CMsgVector>,
    #[prost(bool, optional, tag = "3")]
    pub location_enabled: ::core::option::Option<bool>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CCitadelUserMsgSetClientCameraAngles {
    #[prost(int32, optional, tag = "1", default = "-1")]
    pub player_slot: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "2")]
    pub camera_angles: ::core::option::Option<CMsgQAngle>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CCitadelUserMessageBulletHit {
    #[prost(int32, optional, tag = "1")]
    pub shotid: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub pellet: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3", default = "-1")]
    pub hit_entindex: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CCitadelUserMessageObjectiveMask {
    #[prost(uint64, optional, tag = "2")]
    pub objective_mask_team0: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "3")]
    pub objective_mask_team1: ::core::option::Option<u64>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CCitadelUserMessageModifierApplied {
    #[prost(int32, optional, tag = "1", default = "-1")]
    pub entindex_caster: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2", default = "-1")]
    pub entindex_parent: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub serial_number: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CCitadelUserMessageAuraModifierApplied {
    #[prost(int32, optional, tag = "1", default = "-1")]
    pub entindex_caster: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2", default = "-1")]
    pub entindex_target: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "3")]
    pub modifier_type_id: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "4")]
    pub modifier_serial_number: ::core::option::Option<i32>,
    #[prost(float, optional, tag = "5")]
    pub aura_start_time: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "6")]
    pub aura_end_time: ::core::option::Option<f32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CCitadelUserMsgObstructedShotFired {}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CCitadelUserMsgPostProcessingAnim {
    #[prost(int32, optional, tag = "1", default = "-1")]
    pub entindex_owner: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "2")]
    pub clear_all_states: ::core::option::Option<bool>,
    #[prost(
        enumeration = "PostProcessingGameStates",
        optional,
        tag = "3",
        default = "PostProcStateKilled"
    )]
    pub state: ::core::option::Option<i32>,
    #[prost(float, optional, tag = "4")]
    pub start_time: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "5")]
    pub fade_in_time: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "6")]
    pub hold_time: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "7")]
    pub fade_out_time: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "8")]
    pub scale: ::core::option::Option<f32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CCitadelUserMsgDeathReplayData {
    #[prost(int32, optional, tag = "1", default = "-1")]
    pub killer_scorer: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2", default = "-1")]
    pub killer_inflictor: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "3")]
    pub damage_summary: ::core::option::Option<CCitadelUserMsgRecentDamageSummary>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CCitadelUserMsgForceShopClosed {}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CCitadelUserMsgPlayerLifetimeStatInfo {
    #[prost(message, repeated, tag = "1")]
    pub stats: ::prost::alloc::vec::Vec<c_citadel_user_msg_player_lifetime_stat_info::Stat>,
    #[prost(uint64, optional, tag = "2")]
    pub match_id: ::core::option::Option<u64>,
    #[prost(bool, optional, tag = "3")]
    pub end_of_match: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "4")]
    pub is_official_match: ::core::option::Option<bool>,
}
/// Nested message and enum types in `CCitadelUserMsg_PlayerLifetimeStatInfo`.
pub mod c_citadel_user_msg_player_lifetime_stat_info {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Stat {
        #[prost(string, optional, tag = "1")]
        pub stat_name: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(uint32, optional, tag = "2")]
        pub match_total: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "3")]
        pub lifetime_value: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "4")]
        pub priority: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "5")]
        pub prev_lifetime_max: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "6")]
        pub stat_type: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "7")]
        pub stat_type_id: ::core::option::Option<u32>,
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CCitadelUserMsgStaminaDrained {
    #[prost(int32, optional, tag = "1", default = "-1")]
    pub entindex_victim: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub stamina_drained: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CCitadelUserMessageAbilityNotify {
    #[prost(int32, optional, tag = "1", default = "-1")]
    pub entindex_victim: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2", default = "-1")]
    pub entindex_attacker: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "3")]
    pub ability_id: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CCitadelUserMessageCurrencyChanged {
    #[prost(int32, optional, tag = "1", default = "-1")]
    pub entindex_hero_pawn: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub currency_type: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub currency_source: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "4")]
    pub delta: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "5")]
    pub notification: ::core::option::Option<bool>,
    #[prost(int32, optional, tag = "6", default = "-1")]
    pub entindex_victim: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "7")]
    pub victim_pos: ::core::option::Option<CMsgVector>,
    #[prost(int32, optional, tag = "8")]
    pub playsound: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "9")]
    pub ability_id: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CCitadelUserMessageGameOver {
    #[prost(int32, optional, tag = "1")]
    pub winning_team: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "2")]
    pub just_a_test: ::core::option::Option<bool>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CCitadelUserMsgGetDamageStatsResponse {
    #[prost(uint32, optional, tag = "1")]
    pub player_slot: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "2")]
    pub ability_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "3")]
    pub damage: ::core::option::Option<c_citadel_user_msg_get_damage_stats_response::StatType>,
    #[prost(message, optional, tag = "4")]
    pub healing: ::core::option::Option<c_citadel_user_msg_get_damage_stats_response::StatType>,
}
/// Nested message and enum types in `CCitadelUserMsg_GetDamageStatsResponse`.
pub mod c_citadel_user_msg_get_damage_stats_response {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct StatType {
        #[prost(uint32, repeated, tag = "1")]
        pub target_player_slot: ::prost::alloc::vec::Vec<u32>,
        #[prost(uint32, repeated, tag = "2")]
        pub value: ::prost::alloc::vec::Vec<u32>,
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CCitadelUserMsgParticipantStartSoundEvent {
    #[prost(message, required, tag = "1")]
    pub event: CMsgSosStartSoundEvent,
    #[prost(int32, repeated, packed = "false", tag = "2")]
    pub player_slots: ::prost::alloc::vec::Vec<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CCitadelUserMsgParticipantStopSoundEvent {
    #[prost(message, required, tag = "1")]
    pub event: CMsgSosStopSoundEvent,
    #[prost(int32, repeated, packed = "false", tag = "2")]
    pub player_slots: ::prost::alloc::vec::Vec<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CCitadelUserMsgParticipantStopSoundEventHash {
    #[prost(message, required, tag = "1")]
    pub event: CMsgSosStopSoundEventHash,
    #[prost(int32, repeated, packed = "false", tag = "2")]
    pub player_slots: ::prost::alloc::vec::Vec<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CCitadelUserMsgParticipantSetSoundEventParams {
    #[prost(message, required, tag = "1")]
    pub event: CMsgSosSetSoundEventParams,
    #[prost(int32, repeated, packed = "false", tag = "2")]
    pub player_slots: ::prost::alloc::vec::Vec<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CCitadelUserMsgParticipantSetLibraryStackFields {
    #[prost(message, required, tag = "1")]
    pub event: CMsgSosSetLibraryStackFields,
    #[prost(int32, repeated, packed = "false", tag = "2")]
    pub player_slots: ::prost::alloc::vec::Vec<i32>,
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum CitadelUserMessageIds {
    KEUserMsgDamage = 300,
    KEUserMsgMapPing = 303,
    KEUserMsgTeamRewards = 304,
    KEUserMsgAbilityFailed = 306,
    KEUserMsgTriggerDamageFlash = 308,
    KEUserMsgAbilitiesChanged = 309,
    KEUserMsgRecentDamageSummary = 310,
    KEUserMsgSpectatorTeamChanged = 311,
    KEUserMsgChatWheel = 312,
    KEUserMsgGoldHistory = 313,
    KEUserMsgChatMsg = 314,
    KEUserMsgQuickResponse = 315,
    KEUserMsgPostMatchDetails = 316,
    KEUserMsgChatEvent = 317,
    KEUserMsgAbilityInterrupted = 318,
    KEUserMsgHeroKilled = 319,
    KEUserMsgReturnIdol = 320,
    KEUserMsgSetClientCameraAngles = 321,
    KEUserMsgMapLine = 322,
    KEUserMsgBulletHit = 323,
    KEUserMsgObjectiveMask = 324,
    KEUserMsgModifierApplied = 325,
    KEUserMsgCameraController = 326,
    KEUserMsgAuraModifierApplied = 327,
    KEUserMsgObstructedShotFired = 329,
    KEUserMsgAbilityLateFailure = 330,
    KEUserMsgAbilityPing = 331,
    KEUserMsgPostProcessingAnim = 332,
    KEUserMsgDeathReplayData = 333,
    KEUserMsgPlayerLifetimeStatInfo = 334,
    KEUserMsgForceShopClosed = 336,
    KEUserMsgStaminaDrained = 337,
    KEUserMsgAbilityNotify = 338,
    KEUserMsgGetDamageStatsResponse = 339,
    KEUserMsgParticipantStartSoundEvent = 340,
    KEUserMsgParticipantStopSoundEvent = 341,
    KEUserMsgParticipantStopSoundEventHash = 342,
    KEUserMsgParticipantSetSoundEventParams = 343,
    KEUserMsgParticipantSetLibraryStackFields = 344,
    KEUserMsgCurrencyChanged = 345,
    KEUserMsgGameOver = 346,
}
impl CitadelUserMessageIds {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic
    /// use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            CitadelUserMessageIds::KEUserMsgDamage => "k_EUserMsg_Damage",
            CitadelUserMessageIds::KEUserMsgMapPing => "k_EUserMsg_MapPing",
            CitadelUserMessageIds::KEUserMsgTeamRewards => "k_EUserMsg_TeamRewards",
            CitadelUserMessageIds::KEUserMsgAbilityFailed => "k_EUserMsg_AbilityFailed",
            CitadelUserMessageIds::KEUserMsgTriggerDamageFlash => "k_EUserMsg_TriggerDamageFlash",
            CitadelUserMessageIds::KEUserMsgAbilitiesChanged => "k_EUserMsg_AbilitiesChanged",
            CitadelUserMessageIds::KEUserMsgRecentDamageSummary => "k_EUserMsg_RecentDamageSummary",
            CitadelUserMessageIds::KEUserMsgSpectatorTeamChanged => {
                "k_EUserMsg_SpectatorTeamChanged"
            }
            CitadelUserMessageIds::KEUserMsgChatWheel => "k_EUserMsg_ChatWheel",
            CitadelUserMessageIds::KEUserMsgGoldHistory => "k_EUserMsg_GoldHistory",
            CitadelUserMessageIds::KEUserMsgChatMsg => "k_EUserMsg_ChatMsg",
            CitadelUserMessageIds::KEUserMsgQuickResponse => "k_EUserMsg_QuickResponse",
            CitadelUserMessageIds::KEUserMsgPostMatchDetails => "k_EUserMsg_PostMatchDetails",
            CitadelUserMessageIds::KEUserMsgChatEvent => "k_EUserMsg_ChatEvent",
            CitadelUserMessageIds::KEUserMsgAbilityInterrupted => "k_EUserMsg_AbilityInterrupted",
            CitadelUserMessageIds::KEUserMsgHeroKilled => "k_EUserMsg_HeroKilled",
            CitadelUserMessageIds::KEUserMsgReturnIdol => "k_EUserMsg_ReturnIdol",
            CitadelUserMessageIds::KEUserMsgSetClientCameraAngles => {
                "k_EUserMsg_SetClientCameraAngles"
            }
            CitadelUserMessageIds::KEUserMsgMapLine => "k_EUserMsg_MapLine",
            CitadelUserMessageIds::KEUserMsgBulletHit => "k_EUserMsg_BulletHit",
            CitadelUserMessageIds::KEUserMsgObjectiveMask => "k_EUserMsg_ObjectiveMask",
            CitadelUserMessageIds::KEUserMsgModifierApplied => "k_EUserMsg_ModifierApplied",
            CitadelUserMessageIds::KEUserMsgCameraController => "k_EUserMsg_CameraController",
            CitadelUserMessageIds::KEUserMsgAuraModifierApplied => "k_EUserMsg_AuraModifierApplied",
            CitadelUserMessageIds::KEUserMsgObstructedShotFired => "k_EUserMsg_ObstructedShotFired",
            CitadelUserMessageIds::KEUserMsgAbilityLateFailure => "k_EUserMsg_AbilityLateFailure",
            CitadelUserMessageIds::KEUserMsgAbilityPing => "k_EUserMsg_AbilityPing",
            CitadelUserMessageIds::KEUserMsgPostProcessingAnim => "k_EUserMsg_PostProcessingAnim",
            CitadelUserMessageIds::KEUserMsgDeathReplayData => "k_EUserMsg_DeathReplayData",
            CitadelUserMessageIds::KEUserMsgPlayerLifetimeStatInfo => {
                "k_EUserMsg_PlayerLifetimeStatInfo"
            }
            CitadelUserMessageIds::KEUserMsgForceShopClosed => "k_EUserMsg_ForceShopClosed",
            CitadelUserMessageIds::KEUserMsgStaminaDrained => "k_EUserMsg_StaminaDrained",
            CitadelUserMessageIds::KEUserMsgAbilityNotify => "k_EUserMsg_AbilityNotify",
            CitadelUserMessageIds::KEUserMsgGetDamageStatsResponse => {
                "k_EUserMsg_GetDamageStatsResponse"
            }
            CitadelUserMessageIds::KEUserMsgParticipantStartSoundEvent => {
                "k_EUserMsg_ParticipantStartSoundEvent"
            }
            CitadelUserMessageIds::KEUserMsgParticipantStopSoundEvent => {
                "k_EUserMsg_ParticipantStopSoundEvent"
            }
            CitadelUserMessageIds::KEUserMsgParticipantStopSoundEventHash => {
                "k_EUserMsg_ParticipantStopSoundEventHash"
            }
            CitadelUserMessageIds::KEUserMsgParticipantSetSoundEventParams => {
                "k_EUserMsg_ParticipantSetSoundEventParams"
            }
            CitadelUserMessageIds::KEUserMsgParticipantSetLibraryStackFields => {
                "k_EUserMsg_ParticipantSetLibraryStackFields"
            }
            CitadelUserMessageIds::KEUserMsgCurrencyChanged => "k_EUserMsg_CurrencyChanged",
            CitadelUserMessageIds::KEUserMsgGameOver => "k_EUserMsg_GameOver",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "k_EUserMsg_Damage" => Some(Self::KEUserMsgDamage),
            "k_EUserMsg_MapPing" => Some(Self::KEUserMsgMapPing),
            "k_EUserMsg_TeamRewards" => Some(Self::KEUserMsgTeamRewards),
            "k_EUserMsg_AbilityFailed" => Some(Self::KEUserMsgAbilityFailed),
            "k_EUserMsg_TriggerDamageFlash" => Some(Self::KEUserMsgTriggerDamageFlash),
            "k_EUserMsg_AbilitiesChanged" => Some(Self::KEUserMsgAbilitiesChanged),
            "k_EUserMsg_RecentDamageSummary" => Some(Self::KEUserMsgRecentDamageSummary),
            "k_EUserMsg_SpectatorTeamChanged" => Some(Self::KEUserMsgSpectatorTeamChanged),
            "k_EUserMsg_ChatWheel" => Some(Self::KEUserMsgChatWheel),
            "k_EUserMsg_GoldHistory" => Some(Self::KEUserMsgGoldHistory),
            "k_EUserMsg_ChatMsg" => Some(Self::KEUserMsgChatMsg),
            "k_EUserMsg_QuickResponse" => Some(Self::KEUserMsgQuickResponse),
            "k_EUserMsg_PostMatchDetails" => Some(Self::KEUserMsgPostMatchDetails),
            "k_EUserMsg_ChatEvent" => Some(Self::KEUserMsgChatEvent),
            "k_EUserMsg_AbilityInterrupted" => Some(Self::KEUserMsgAbilityInterrupted),
            "k_EUserMsg_HeroKilled" => Some(Self::KEUserMsgHeroKilled),
            "k_EUserMsg_ReturnIdol" => Some(Self::KEUserMsgReturnIdol),
            "k_EUserMsg_SetClientCameraAngles" => Some(Self::KEUserMsgSetClientCameraAngles),
            "k_EUserMsg_MapLine" => Some(Self::KEUserMsgMapLine),
            "k_EUserMsg_BulletHit" => Some(Self::KEUserMsgBulletHit),
            "k_EUserMsg_ObjectiveMask" => Some(Self::KEUserMsgObjectiveMask),
            "k_EUserMsg_ModifierApplied" => Some(Self::KEUserMsgModifierApplied),
            "k_EUserMsg_CameraController" => Some(Self::KEUserMsgCameraController),
            "k_EUserMsg_AuraModifierApplied" => Some(Self::KEUserMsgAuraModifierApplied),
            "k_EUserMsg_ObstructedShotFired" => Some(Self::KEUserMsgObstructedShotFired),
            "k_EUserMsg_AbilityLateFailure" => Some(Self::KEUserMsgAbilityLateFailure),
            "k_EUserMsg_AbilityPing" => Some(Self::KEUserMsgAbilityPing),
            "k_EUserMsg_PostProcessingAnim" => Some(Self::KEUserMsgPostProcessingAnim),
            "k_EUserMsg_DeathReplayData" => Some(Self::KEUserMsgDeathReplayData),
            "k_EUserMsg_PlayerLifetimeStatInfo" => Some(Self::KEUserMsgPlayerLifetimeStatInfo),
            "k_EUserMsg_ForceShopClosed" => Some(Self::KEUserMsgForceShopClosed),
            "k_EUserMsg_StaminaDrained" => Some(Self::KEUserMsgStaminaDrained),
            "k_EUserMsg_AbilityNotify" => Some(Self::KEUserMsgAbilityNotify),
            "k_EUserMsg_GetDamageStatsResponse" => Some(Self::KEUserMsgGetDamageStatsResponse),
            "k_EUserMsg_ParticipantStartSoundEvent" => {
                Some(Self::KEUserMsgParticipantStartSoundEvent)
            }
            "k_EUserMsg_ParticipantStopSoundEvent" => {
                Some(Self::KEUserMsgParticipantStopSoundEvent)
            }
            "k_EUserMsg_ParticipantStopSoundEventHash" => {
                Some(Self::KEUserMsgParticipantStopSoundEventHash)
            }
            "k_EUserMsg_ParticipantSetSoundEventParams" => {
                Some(Self::KEUserMsgParticipantSetSoundEventParams)
            }
            "k_EUserMsg_ParticipantSetLibraryStackFields" => {
                Some(Self::KEUserMsgParticipantSetLibraryStackFields)
            }
            "k_EUserMsg_CurrencyChanged" => Some(Self::KEUserMsgCurrencyChanged),
            "k_EUserMsg_GameOver" => Some(Self::KEUserMsgGameOver),
            _ => None,
        }
    }
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum CitadelEntityMessageIds {
    KEEntityMsgBreakablePropSpawnDebris = 500,
}
impl CitadelEntityMessageIds {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic
    /// use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            CitadelEntityMessageIds::KEEntityMsgBreakablePropSpawnDebris => {
                "k_EEntityMsg_BreakablePropSpawnDebris"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "k_EEntityMsg_BreakablePropSpawnDebris" => {
                Some(Self::KEEntityMsgBreakablePropSpawnDebris)
            }
            _ => None,
        }
    }
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum ChatMsgPingMarkerInfo {
    KEPingMarkerInfoShowMarkerAndSound = 0,
    KEPingMarkerInfoHideMarkerAndSound = 1,
    KEPingMarkerInfoShowMarkerOnSender = 2,
    KEPingMarkerInfoOnlyShowMarker = 3,
    KEPingMarkerInfoOnlyPlaySound = 4,
}
impl ChatMsgPingMarkerInfo {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic
    /// use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ChatMsgPingMarkerInfo::KEPingMarkerInfoShowMarkerAndSound => {
                "k_EPingMarkerInfo_ShowMarkerAndSound"
            }
            ChatMsgPingMarkerInfo::KEPingMarkerInfoHideMarkerAndSound => {
                "k_EPingMarkerInfo_HideMarkerAndSound"
            }
            ChatMsgPingMarkerInfo::KEPingMarkerInfoShowMarkerOnSender => {
                "k_EPingMarkerInfo_ShowMarkerOnSender"
            }
            ChatMsgPingMarkerInfo::KEPingMarkerInfoOnlyShowMarker => {
                "k_EPingMarkerInfo_OnlyShowMarker"
            }
            ChatMsgPingMarkerInfo::KEPingMarkerInfoOnlyPlaySound => {
                "k_EPingMarkerInfo_OnlyPlaySound"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "k_EPingMarkerInfo_ShowMarkerAndSound" => {
                Some(Self::KEPingMarkerInfoShowMarkerAndSound)
            }
            "k_EPingMarkerInfo_HideMarkerAndSound" => {
                Some(Self::KEPingMarkerInfoHideMarkerAndSound)
            }
            "k_EPingMarkerInfo_ShowMarkerOnSender" => {
                Some(Self::KEPingMarkerInfoShowMarkerOnSender)
            }
            "k_EPingMarkerInfo_OnlyShowMarker" => Some(Self::KEPingMarkerInfoOnlyShowMarker),
            "k_EPingMarkerInfo_OnlyPlaySound" => Some(Self::KEPingMarkerInfoOnlyPlaySound),
            _ => None,
        }
    }
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum CameraOperation {
    KECameraOpMaintain = 2,
    KECameraOpApproach = 3,
    KECameraOpSpring = 4,
    KECameraOpLerp = 5,
    KECameraOpLag = 6,
}
impl CameraOperation {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic
    /// use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            CameraOperation::KECameraOpMaintain => "k_ECameraOp_Maintain",
            CameraOperation::KECameraOpApproach => "k_ECameraOp_Approach",
            CameraOperation::KECameraOpSpring => "k_ECameraOp_Spring",
            CameraOperation::KECameraOpLerp => "k_ECameraOp_Lerp",
            CameraOperation::KECameraOpLag => "k_ECameraOp_Lag",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "k_ECameraOp_Maintain" => Some(Self::KECameraOpMaintain),
            "k_ECameraOp_Approach" => Some(Self::KECameraOpApproach),
            "k_ECameraOp_Spring" => Some(Self::KECameraOpSpring),
            "k_ECameraOp_Lerp" => Some(Self::KECameraOpLerp),
            "k_ECameraOp_Lag" => Some(Self::KECameraOpLag),
            _ => None,
        }
    }
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum CameraParam {
    KEParamClearAllOps = 0,
    KEParamClearAllOpsForContext = 1,
    KEParamDistance = 2,
    KEParamFov = 3,
    KEParamTargetPosition = 4,
    KEParamVertOffset = 5,
    KEParamHorizOffset = 6,
}
impl CameraParam {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic
    /// use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            CameraParam::KEParamClearAllOps => "k_EParam_ClearAllOps",
            CameraParam::KEParamClearAllOpsForContext => "k_EParam_ClearAllOpsForContext",
            CameraParam::KEParamDistance => "k_EParam_Distance",
            CameraParam::KEParamFov => "k_EParam_FOV",
            CameraParam::KEParamTargetPosition => "k_EParam_TargetPosition",
            CameraParam::KEParamVertOffset => "k_EParam_VertOffset",
            CameraParam::KEParamHorizOffset => "k_EParam_HorizOffset",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "k_EParam_ClearAllOps" => Some(Self::KEParamClearAllOps),
            "k_EParam_ClearAllOpsForContext" => Some(Self::KEParamClearAllOpsForContext),
            "k_EParam_Distance" => Some(Self::KEParamDistance),
            "k_EParam_FOV" => Some(Self::KEParamFov),
            "k_EParam_TargetPosition" => Some(Self::KEParamTargetPosition),
            "k_EParam_VertOffset" => Some(Self::KEParamVertOffset),
            "k_EParam_HorizOffset" => Some(Self::KEParamHorizOffset),
            _ => None,
        }
    }
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum CameraAction {
    KEActionAddOp = 0,
    KEActionClearAllOps = 1,
    KEActionClearOpsForContext = 2,
}
impl CameraAction {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic
    /// use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            CameraAction::KEActionAddOp => "k_EAction_AddOp",
            CameraAction::KEActionClearAllOps => "k_EAction_ClearAllOps",
            CameraAction::KEActionClearOpsForContext => "k_EAction_ClearOpsForContext",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "k_EAction_AddOp" => Some(Self::KEActionAddOp),
            "k_EAction_ClearAllOps" => Some(Self::KEActionClearAllOps),
            "k_EAction_ClearOpsForContext" => Some(Self::KEActionClearOpsForContext),
            _ => None,
        }
    }
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum ECitadelChatMessage {
    CitadelChatMessageUnpauseCountdown = 1,
    CitadelChatMessageUnpaused = 2,
    CitadelChatMessageAutoUnpaused = 3,
    CitadelChatMessagePauseCountdown = 4,
    CitadelChatMessagePaused = 5,
    CitadelChatMessageYoupaused = 6,
    CitadelChatMessageCantpause = 7,
    CitadelChatMessageCantunpauseteam = 8,
    CitadelChatMessageNopausesleft = 9,
    CitadelChatMessageCantpauseyet = 10,
    CitadelChatMessagePregameCountdown = 11,
}
impl ECitadelChatMessage {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic
    /// use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ECitadelChatMessage::CitadelChatMessageUnpauseCountdown => {
                "CITADEL_CHAT_MESSAGE_UNPAUSE_COUNTDOWN"
            }
            ECitadelChatMessage::CitadelChatMessageUnpaused => "CITADEL_CHAT_MESSAGE_UNPAUSED",
            ECitadelChatMessage::CitadelChatMessageAutoUnpaused => {
                "CITADEL_CHAT_MESSAGE_AUTO_UNPAUSED"
            }
            ECitadelChatMessage::CitadelChatMessagePauseCountdown => {
                "CITADEL_CHAT_MESSAGE_PAUSE_COUNTDOWN"
            }
            ECitadelChatMessage::CitadelChatMessagePaused => "CITADEL_CHAT_MESSAGE_PAUSED",
            ECitadelChatMessage::CitadelChatMessageYoupaused => "CITADEL_CHAT_MESSAGE_YOUPAUSED",
            ECitadelChatMessage::CitadelChatMessageCantpause => "CITADEL_CHAT_MESSAGE_CANTPAUSE",
            ECitadelChatMessage::CitadelChatMessageCantunpauseteam => {
                "CITADEL_CHAT_MESSAGE_CANTUNPAUSETEAM"
            }
            ECitadelChatMessage::CitadelChatMessageNopausesleft => {
                "CITADEL_CHAT_MESSAGE_NOPAUSESLEFT"
            }
            ECitadelChatMessage::CitadelChatMessageCantpauseyet => {
                "CITADEL_CHAT_MESSAGE_CANTPAUSEYET"
            }
            ECitadelChatMessage::CitadelChatMessagePregameCountdown => {
                "CITADEL_CHAT_MESSAGE_PREGAME_COUNTDOWN"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CITADEL_CHAT_MESSAGE_UNPAUSE_COUNTDOWN" => {
                Some(Self::CitadelChatMessageUnpauseCountdown)
            }
            "CITADEL_CHAT_MESSAGE_UNPAUSED" => Some(Self::CitadelChatMessageUnpaused),
            "CITADEL_CHAT_MESSAGE_AUTO_UNPAUSED" => Some(Self::CitadelChatMessageAutoUnpaused),
            "CITADEL_CHAT_MESSAGE_PAUSE_COUNTDOWN" => Some(Self::CitadelChatMessagePauseCountdown),
            "CITADEL_CHAT_MESSAGE_PAUSED" => Some(Self::CitadelChatMessagePaused),
            "CITADEL_CHAT_MESSAGE_YOUPAUSED" => Some(Self::CitadelChatMessageYoupaused),
            "CITADEL_CHAT_MESSAGE_CANTPAUSE" => Some(Self::CitadelChatMessageCantpause),
            "CITADEL_CHAT_MESSAGE_CANTUNPAUSETEAM" => Some(Self::CitadelChatMessageCantunpauseteam),
            "CITADEL_CHAT_MESSAGE_NOPAUSESLEFT" => Some(Self::CitadelChatMessageNopausesleft),
            "CITADEL_CHAT_MESSAGE_CANTPAUSEYET" => Some(Self::CitadelChatMessageCantpauseyet),
            "CITADEL_CHAT_MESSAGE_PREGAME_COUNTDOWN" => {
                Some(Self::CitadelChatMessagePregameCountdown)
            }
            _ => None,
        }
    }
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum PostProcessingGameStates {
    PostProcStateKilled = 0,
    PostProcStateBlack = 1,
    PostProcStateBlinded = 2,
    PostProcStateShivPossessed = 3,
}
impl PostProcessingGameStates {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic
    /// use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            PostProcessingGameStates::PostProcStateKilled => "PostProcState_Killed",
            PostProcessingGameStates::PostProcStateBlack => "PostProcState_Black",
            PostProcessingGameStates::PostProcStateBlinded => "PostProcState_Blinded",
            PostProcessingGameStates::PostProcStateShivPossessed => "PostProcState_ShivPossessed",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PostProcState_Killed" => Some(Self::PostProcStateKilled),
            "PostProcState_Black" => Some(Self::PostProcStateBlack),
            "PostProcState_Blinded" => Some(Self::PostProcStateBlinded),
            "PostProcState_ShivPossessed" => Some(Self::PostProcStateShivPossessed),
            _ => None,
        }
    }
}
