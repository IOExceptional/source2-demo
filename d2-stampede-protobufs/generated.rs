// This file is @generated by prost-build.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDemoFileHeader {
    #[prost(string, required, tag = "1")]
    pub demo_file_stamp: ::prost::alloc::string::String,
    #[prost(int32, optional, tag = "2")]
    pub network_protocol: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "3")]
    pub server_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "4")]
    pub client_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "5")]
    pub map_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "6")]
    pub game_directory: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "7")]
    pub fullpackets_version: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "8")]
    pub allow_clientside_entities: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "9")]
    pub allow_clientside_particles: ::core::option::Option<bool>,
    #[prost(string, optional, tag = "10")]
    pub addons: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "11")]
    pub demo_version_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "12")]
    pub demo_version_guid: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "13")]
    pub build_num: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "14")]
    pub game: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "15")]
    pub server_start_tick: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CGameInfo {
    #[prost(message, optional, tag = "4")]
    pub dota: ::core::option::Option<c_game_info::CDotaGameInfo>,
    #[prost(message, optional, tag = "5")]
    pub cs: ::core::option::Option<c_game_info::CcsGameInfo>,
}
/// Nested message and enum types in `CGameInfo`.
pub mod c_game_info {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CDotaGameInfo {
        #[prost(uint64, optional, tag = "1")]
        pub match_id: ::core::option::Option<u64>,
        #[prost(int32, optional, tag = "2")]
        pub game_mode: ::core::option::Option<i32>,
        #[prost(int32, optional, tag = "3")]
        pub game_winner: ::core::option::Option<i32>,
        #[prost(message, repeated, tag = "4")]
        pub player_info: ::prost::alloc::vec::Vec<c_dota_game_info::CPlayerInfo>,
        #[prost(uint32, optional, tag = "5")]
        pub leagueid: ::core::option::Option<u32>,
        #[prost(message, repeated, tag = "6")]
        pub picks_bans: ::prost::alloc::vec::Vec<c_dota_game_info::CHeroSelectEvent>,
        #[prost(uint32, optional, tag = "7")]
        pub radiant_team_id: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "8")]
        pub dire_team_id: ::core::option::Option<u32>,
        #[prost(string, optional, tag = "9")]
        pub radiant_team_tag: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag = "10")]
        pub dire_team_tag: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(uint32, optional, tag = "11")]
        pub end_time: ::core::option::Option<u32>,
    }
    /// Nested message and enum types in `CDotaGameInfo`.
    pub mod c_dota_game_info {
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct CPlayerInfo {
            #[prost(string, optional, tag = "1")]
            pub hero_name: ::core::option::Option<::prost::alloc::string::String>,
            #[prost(string, optional, tag = "2")]
            pub player_name: ::core::option::Option<::prost::alloc::string::String>,
            #[prost(bool, optional, tag = "3")]
            pub is_fake_client: ::core::option::Option<bool>,
            #[prost(uint64, optional, tag = "4")]
            pub steamid: ::core::option::Option<u64>,
            #[prost(int32, optional, tag = "5")]
            pub game_team: ::core::option::Option<i32>,
        }
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct CHeroSelectEvent {
            #[prost(bool, optional, tag = "1")]
            pub is_pick: ::core::option::Option<bool>,
            #[prost(uint32, optional, tag = "2")]
            pub team: ::core::option::Option<u32>,
            #[prost(uint32, optional, tag = "3")]
            pub hero_id: ::core::option::Option<u32>,
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CcsGameInfo {
        #[prost(int32, repeated, packed = "false", tag = "1")]
        pub round_start_ticks: ::prost::alloc::vec::Vec<i32>,
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDemoFileInfo {
    #[prost(float, optional, tag = "1")]
    pub playback_time: ::core::option::Option<f32>,
    #[prost(int32, optional, tag = "2")]
    pub playback_ticks: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub playback_frames: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "4")]
    pub game_info: ::core::option::Option<CGameInfo>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDemoPacket {
    #[prost(bytes = "vec", optional, tag = "3")]
    pub data: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDemoFullPacket {
    #[prost(message, optional, tag = "1")]
    pub string_table: ::core::option::Option<CDemoStringTables>,
    #[prost(message, optional, tag = "2")]
    pub packet: ::core::option::Option<CDemoPacket>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDemoSaveGame {
    #[prost(bytes = "vec", optional, tag = "1")]
    pub data: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(fixed64, optional, tag = "2")]
    pub steam_id: ::core::option::Option<u64>,
    #[prost(fixed64, optional, tag = "3")]
    pub signature: ::core::option::Option<u64>,
    #[prost(int32, optional, tag = "4")]
    pub version: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CDemoSyncTick {}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDemoConsoleCmd {
    #[prost(string, optional, tag = "1")]
    pub cmdstring: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDemoSendTables {
    #[prost(bytes = "vec", optional, tag = "1")]
    pub data: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDemoClassInfo {
    #[prost(message, repeated, tag = "1")]
    pub classes: ::prost::alloc::vec::Vec<c_demo_class_info::ClassT>,
}
/// Nested message and enum types in `CDemoClassInfo`.
pub mod c_demo_class_info {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ClassT {
        #[prost(int32, optional, tag = "1")]
        pub class_id: ::core::option::Option<i32>,
        #[prost(string, optional, tag = "2")]
        pub network_name: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag = "3")]
        pub table_name: ::core::option::Option<::prost::alloc::string::String>,
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDemoCustomData {
    #[prost(int32, optional, tag = "1")]
    pub callback_index: ::core::option::Option<i32>,
    #[prost(bytes = "vec", optional, tag = "2")]
    pub data: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDemoCustomDataCallbacks {
    #[prost(string, repeated, tag = "1")]
    pub save_id: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDemoAnimationHeader {
    #[prost(sint32, optional, tag = "1")]
    pub entity_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub tick: ::core::option::Option<i32>,
    #[prost(bytes = "vec", optional, tag = "3")]
    pub data: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDemoAnimationData {
    #[prost(sint32, optional, tag = "1")]
    pub entity_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub start_tick: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub end_tick: ::core::option::Option<i32>,
    #[prost(bytes = "vec", optional, tag = "4")]
    pub data: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(int64, optional, tag = "5")]
    pub data_checksum: ::core::option::Option<i64>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDemoStringTables {
    #[prost(message, repeated, tag = "1")]
    pub tables: ::prost::alloc::vec::Vec<c_demo_string_tables::TableT>,
}
/// Nested message and enum types in `CDemoStringTables`.
pub mod c_demo_string_tables {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ItemsT {
        #[prost(string, optional, tag = "1")]
        pub str: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(bytes = "vec", optional, tag = "2")]
        pub data: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TableT {
        #[prost(string, optional, tag = "1")]
        pub table_name: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(message, repeated, tag = "2")]
        pub items: ::prost::alloc::vec::Vec<ItemsT>,
        #[prost(message, repeated, tag = "3")]
        pub items_clientside: ::prost::alloc::vec::Vec<ItemsT>,
        #[prost(int32, optional, tag = "4")]
        pub table_flags: ::core::option::Option<i32>,
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CDemoStop {}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDemoUserCmd {
    #[prost(int32, optional, tag = "1")]
    pub cmd_number: ::core::option::Option<i32>,
    #[prost(bytes = "vec", optional, tag = "2")]
    pub data: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDemoSpawnGroups {
    #[prost(bytes = "vec", repeated, tag = "3")]
    pub msgs: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum EDemoCommands {
    DemError = -1,
    DemStop = 0,
    DemFileHeader = 1,
    DemFileInfo = 2,
    DemSyncTick = 3,
    DemSendTables = 4,
    DemClassInfo = 5,
    DemStringTables = 6,
    DemPacket = 7,
    DemSignonPacket = 8,
    DemConsoleCmd = 9,
    DemCustomData = 10,
    DemCustomDataCallbacks = 11,
    DemUserCmd = 12,
    DemFullPacket = 13,
    DemSaveGame = 14,
    DemSpawnGroups = 15,
    DemAnimationData = 16,
    DemAnimationHeader = 17,
    DemMax = 18,
    DemIsCompressed = 64,
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum ENetworkDisconnectionReason {
    NetworkDisconnectInvalid = 0,
    NetworkDisconnectShutdown = 1,
    NetworkDisconnectDisconnectByUser = 2,
    NetworkDisconnectDisconnectByServer = 3,
    NetworkDisconnectLost = 4,
    NetworkDisconnectOverflow = 5,
    NetworkDisconnectSteamBanned = 6,
    NetworkDisconnectSteamInuse = 7,
    NetworkDisconnectSteamTicket = 8,
    NetworkDisconnectSteamLogon = 9,
    NetworkDisconnectSteamAuthcancelled = 10,
    NetworkDisconnectSteamAuthalreadyused = 11,
    NetworkDisconnectSteamAuthinvalid = 12,
    NetworkDisconnectSteamVacbanstate = 13,
    NetworkDisconnectSteamLoggedInElsewhere = 14,
    NetworkDisconnectSteamVacCheckTimedout = 15,
    NetworkDisconnectSteamDropped = 16,
    NetworkDisconnectSteamOwnership = 17,
    NetworkDisconnectServerinfoOverflow = 18,
    NetworkDisconnectTickmsgOverflow = 19,
    NetworkDisconnectStringtablemsgOverflow = 20,
    NetworkDisconnectDeltaentmsgOverflow = 21,
    NetworkDisconnectTempentmsgOverflow = 22,
    NetworkDisconnectSoundsmsgOverflow = 23,
    NetworkDisconnectSnapshotoverflow = 24,
    NetworkDisconnectSnapshoterror = 25,
    NetworkDisconnectReliableoverflow = 26,
    NetworkDisconnectBaddeltatick = 27,
    NetworkDisconnectNomoresplits = 28,
    NetworkDisconnectTimedout = 29,
    NetworkDisconnectDisconnected = 30,
    NetworkDisconnectLeavingsplit = 31,
    NetworkDisconnectDifferentclasstables = 32,
    NetworkDisconnectBadrelaypassword = 33,
    NetworkDisconnectBadspectatorpassword = 34,
    NetworkDisconnectHltvrestricted = 35,
    NetworkDisconnectNospectators = 36,
    NetworkDisconnectHltvunavailable = 37,
    NetworkDisconnectHltvstop = 38,
    NetworkDisconnectKicked = 39,
    NetworkDisconnectBanadded = 40,
    NetworkDisconnectKickbanadded = 41,
    NetworkDisconnectHltvdirect = 42,
    NetworkDisconnectPureserverClientextra = 43,
    NetworkDisconnectPureserverMismatch = 44,
    NetworkDisconnectUsercmd = 45,
    NetworkDisconnectRejectedByGame = 46,
    NetworkDisconnectMessageParseError = 47,
    NetworkDisconnectInvalidMessageError = 48,
    NetworkDisconnectBadServerPassword = 49,
    NetworkDisconnectDirectConnectReservation = 50,
    NetworkDisconnectConnectionFailure = 51,
    NetworkDisconnectNoPeerGroupHandlers = 52,
    NetworkDisconnectReconnection = 53,
    NetworkDisconnectLoopshutdown = 54,
    NetworkDisconnectLoopdeactivate = 55,
    NetworkDisconnectHostEndgame = 56,
    NetworkDisconnectLoopLevelloadActivate = 57,
    NetworkDisconnectCreateServerFailed = 58,
    NetworkDisconnectExiting = 59,
    NetworkDisconnectRequestHoststateIdle = 60,
    NetworkDisconnectRequestHoststateHltvrelay = 61,
    NetworkDisconnectClientConsistencyFail = 62,
    NetworkDisconnectClientUnableToCrcMap = 63,
    NetworkDisconnectClientNoMap = 64,
    NetworkDisconnectClientDifferentMap = 65,
    NetworkDisconnectServerRequiresSteam = 66,
    NetworkDisconnectSteamDenyMisc = 67,
    NetworkDisconnectSteamDenyBadAntiCheat = 68,
    NetworkDisconnectServerShutdown = 69,
    NetworkDisconnectReplayIncompatible = 71,
    NetworkDisconnectConnectRequestTimedout = 72,
    NetworkDisconnectServerIncompatible = 73,
    NetworkDisconnectLocalproblemManyrelays = 74,
    NetworkDisconnectLocalproblemHostedserverprimaryrelay = 75,
    NetworkDisconnectLocalproblemNetworkconfig = 76,
    NetworkDisconnectLocalproblemOther = 77,
    NetworkDisconnectRemoteTimeout = 79,
    NetworkDisconnectRemoteTimeoutConnecting = 80,
    NetworkDisconnectRemoteOther = 81,
    NetworkDisconnectRemoteBadcrypt = 82,
    NetworkDisconnectRemoteCertnottrusted = 83,
    NetworkDisconnectUnusual = 84,
    NetworkDisconnectInternalError = 85,
    NetworkDisconnectRejectBadchallenge = 128,
    NetworkDisconnectRejectNolobby = 129,
    NetworkDisconnectRejectBackgroundMap = 130,
    NetworkDisconnectRejectSinglePlayer = 131,
    NetworkDisconnectRejectHiddenGame = 132,
    NetworkDisconnectRejectLanrestrict = 133,
    NetworkDisconnectRejectBadpassword = 134,
    NetworkDisconnectRejectServerfull = 135,
    NetworkDisconnectRejectInvalidreservation = 136,
    NetworkDisconnectRejectFailedchannel = 137,
    NetworkDisconnectRejectConnectFromLobby = 138,
    NetworkDisconnectRejectReservedForLobby = 139,
    NetworkDisconnectRejectInvalidkeylength = 140,
    NetworkDisconnectRejectOldprotocol = 141,
    NetworkDisconnectRejectNewprotocol = 142,
    NetworkDisconnectRejectInvalidconnection = 143,
    NetworkDisconnectRejectInvalidcertlen = 144,
    NetworkDisconnectRejectInvalidsteamcertlen = 145,
    NetworkDisconnectRejectSteam = 146,
    NetworkDisconnectRejectServerauthdisabled = 147,
    NetworkDisconnectRejectServercdkeyauthinvalid = 148,
    NetworkDisconnectRejectBanned = 149,
    NetworkDisconnectKickedTeamkilling = 150,
    NetworkDisconnectKickedTkStart = 151,
    NetworkDisconnectKickedUntrustedaccount = 152,
    NetworkDisconnectKickedConvictedaccount = 153,
    NetworkDisconnectKickedCompetitivecooldown = 154,
    NetworkDisconnectKickedTeamhurting = 155,
    NetworkDisconnectKickedHostagekilling = 156,
    NetworkDisconnectKickedVotedoff = 157,
    NetworkDisconnectKickedIdle = 158,
    NetworkDisconnectKickedSuicide = 159,
    NetworkDisconnectKickedNosteamlogin = 160,
    NetworkDisconnectKickedNosteamticket = 161,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgVector {
    #[prost(float, optional, tag = "1")]
    pub x: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "2")]
    pub y: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "3")]
    pub z: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "4")]
    pub w: ::core::option::Option<f32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgVector2D {
    #[prost(float, optional, tag = "1")]
    pub x: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "2")]
    pub y: ::core::option::Option<f32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgQAngle {
    #[prost(float, optional, tag = "1")]
    pub x: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "2")]
    pub y: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "3")]
    pub z: ::core::option::Option<f32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgQuaternion {
    #[prost(float, optional, tag = "1")]
    pub x: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "2")]
    pub y: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "3")]
    pub z: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "4")]
    pub w: ::core::option::Option<f32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgTransform {
    #[prost(message, optional, tag = "1")]
    pub position: ::core::option::Option<CMsgVector>,
    #[prost(float, optional, tag = "2")]
    pub scale: ::core::option::Option<f32>,
    #[prost(message, optional, tag = "3")]
    pub orientation: ::core::option::Option<CMsgQuaternion>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgRgba {
    #[prost(int32, optional, tag = "1")]
    pub r: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub g: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub b: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "4")]
    pub a: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgPlayerInfo {
    #[prost(string, optional, tag = "1")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(fixed64, optional, tag = "2")]
    pub xuid: ::core::option::Option<u64>,
    #[prost(int32, optional, tag = "3")]
    pub userid: ::core::option::Option<i32>,
    #[prost(fixed64, optional, tag = "4")]
    pub steamid: ::core::option::Option<u64>,
    #[prost(bool, optional, tag = "5")]
    pub fakeplayer: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "6")]
    pub ishltv: ::core::option::Option<bool>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CEntityMsg {
    #[prost(uint32, optional, tag = "1", default = "16777215")]
    pub target_entity: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgCVars {
    #[prost(message, repeated, tag = "1")]
    pub cvars: ::prost::alloc::vec::Vec<c_msg_c_vars::CVar>,
}
/// Nested message and enum types in `CMsg_CVars`.
pub mod c_msg_c_vars {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CVar {
        #[prost(string, optional, tag = "1")]
        pub name: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag = "2")]
        pub value: ::core::option::Option<::prost::alloc::string::String>,
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CNetMsgNop {}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CNetMsgSplitScreenUser {
    #[prost(int32, optional, tag = "1")]
    pub slot: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CNetMsgDisconnectLegacy {
    #[prost(
        enumeration = "ENetworkDisconnectionReason",
        optional,
        tag = "2",
        default = "NetworkDisconnectInvalid"
    )]
    pub reason: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CNetMsgTick {
    #[prost(uint32, optional, tag = "1")]
    pub tick: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub host_frametime: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub host_frametime_std_deviation: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub host_computationtime: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "5")]
    pub host_computationtime_std_deviation: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "6")]
    pub host_framestarttime_std_deviation: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "7")]
    pub host_loss: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "8")]
    pub host_unfiltered_frametime: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "9")]
    pub hltv_replay_flags: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "10")]
    pub expected_long_tick: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "11")]
    pub expected_long_tick_reason: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CNetMsgStringCmd {
    #[prost(string, optional, tag = "1")]
    pub command: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "2")]
    pub prediction_sync: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CNetMsgSetConVar {
    #[prost(message, optional, tag = "1")]
    pub convars: ::core::option::Option<CMsgCVars>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CNetMsgSignonState {
    #[prost(
        enumeration = "SignonStateT",
        optional,
        tag = "1",
        default = "SignonstateNone"
    )]
    pub signon_state: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "2")]
    pub spawn_count: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub num_server_players: ::core::option::Option<u32>,
    #[prost(string, repeated, tag = "4")]
    pub players_networkids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "5")]
    pub map_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "6")]
    pub addons: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CSvcMsgGameEvent {
    #[prost(string, optional, tag = "1")]
    pub event_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "2")]
    pub eventid: ::core::option::Option<i32>,
    #[prost(message, repeated, tag = "3")]
    pub keys: ::prost::alloc::vec::Vec<csvc_msg_game_event::KeyT>,
}
/// Nested message and enum types in `CSVCMsg_GameEvent`.
pub mod csvc_msg_game_event {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct KeyT {
        #[prost(int32, optional, tag = "1")]
        pub r#type: ::core::option::Option<i32>,
        #[prost(string, optional, tag = "2")]
        pub val_string: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(float, optional, tag = "3")]
        pub val_float: ::core::option::Option<f32>,
        #[prost(int32, optional, tag = "4")]
        pub val_long: ::core::option::Option<i32>,
        #[prost(int32, optional, tag = "5")]
        pub val_short: ::core::option::Option<i32>,
        #[prost(int32, optional, tag = "6")]
        pub val_byte: ::core::option::Option<i32>,
        #[prost(bool, optional, tag = "7")]
        pub val_bool: ::core::option::Option<bool>,
        #[prost(uint64, optional, tag = "8")]
        pub val_uint64: ::core::option::Option<u64>,
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CSvcMsgListGameEvents {
    #[prost(message, repeated, tag = "1")]
    pub events: ::prost::alloc::vec::Vec<csvc_msg_list_game_events::EventT>,
}
/// Nested message and enum types in `CSVCMsgList_GameEvents`.
pub mod csvc_msg_list_game_events {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct EventT {
        #[prost(int32, optional, tag = "1")]
        pub tick: ::core::option::Option<i32>,
        #[prost(message, optional, tag = "2")]
        pub event: ::core::option::Option<super::CSvcMsgGameEvent>,
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CNetMsgSpawnGroupLoad {
    #[prost(string, optional, tag = "1")]
    pub worldname: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "2")]
    pub entitylumpname: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3")]
    pub entityfiltername: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "4")]
    pub spawngrouphandle: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "5")]
    pub spawngroupownerhandle: ::core::option::Option<u32>,
    #[prost(message, optional, tag = "6")]
    pub world_offset_pos: ::core::option::Option<CMsgVector>,
    #[prost(message, optional, tag = "7")]
    pub world_offset_angle: ::core::option::Option<CMsgQAngle>,
    #[prost(bytes = "vec", optional, tag = "8")]
    pub spawngroupmanifest: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(uint32, optional, tag = "9")]
    pub flags: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "10")]
    pub tickcount: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "11")]
    pub manifestincomplete: ::core::option::Option<bool>,
    #[prost(string, optional, tag = "12")]
    pub localnamefixup: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "13")]
    pub parentnamefixup: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "14")]
    pub manifestloadpriority: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "15")]
    pub worldgroupid: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "16")]
    pub creationsequence: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "17")]
    pub savegamefilename: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "18")]
    pub spawngroupparenthandle: ::core::option::Option<u32>,
    #[prost(bool, optional, tag = "19")]
    pub leveltransition: ::core::option::Option<bool>,
    #[prost(string, optional, tag = "20")]
    pub worldgroupname: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CNetMsgSpawnGroupManifestUpdate {
    #[prost(uint32, optional, tag = "1")]
    pub spawngrouphandle: ::core::option::Option<u32>,
    #[prost(bytes = "vec", optional, tag = "2")]
    pub spawngroupmanifest: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bool, optional, tag = "3")]
    pub manifestincomplete: ::core::option::Option<bool>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CNetMsgSpawnGroupSetCreationTick {
    #[prost(uint32, optional, tag = "1")]
    pub spawngrouphandle: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "2")]
    pub tickcount: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "3")]
    pub creationsequence: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CNetMsgSpawnGroupUnload {
    #[prost(uint32, optional, tag = "1")]
    pub spawngrouphandle: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub flags: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "3")]
    pub tickcount: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CNetMsgSpawnGroupLoadCompleted {
    #[prost(uint32, optional, tag = "1")]
    pub spawngrouphandle: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CSvcMsgGameSessionConfiguration {
    #[prost(bool, optional, tag = "1")]
    pub is_multiplayer: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "2")]
    pub is_loadsavegame: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "3")]
    pub is_background_map: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "4")]
    pub is_headless: ::core::option::Option<bool>,
    #[prost(uint32, optional, tag = "5")]
    pub min_client_limit: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "6")]
    pub max_client_limit: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "7")]
    pub max_clients: ::core::option::Option<u32>,
    #[prost(fixed32, optional, tag = "8")]
    pub tick_interval: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "9")]
    pub hostname: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "10")]
    pub savegamename: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "11")]
    pub s1_mapname: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "12")]
    pub gamemode: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "13")]
    pub server_ip_address: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bytes = "vec", optional, tag = "14")]
    pub data: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bool, optional, tag = "15")]
    pub is_localonly: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "19")]
    pub no_steam_server: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "16")]
    pub is_transition: ::core::option::Option<bool>,
    #[prost(string, optional, tag = "17")]
    pub previouslevel: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "18")]
    pub landmarkname: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CNetMsgDebugOverlay {
    #[prost(int32, optional, tag = "1")]
    pub etype: ::core::option::Option<i32>,
    #[prost(message, repeated, tag = "2")]
    pub vectors: ::prost::alloc::vec::Vec<CMsgVector>,
    #[prost(message, repeated, tag = "3")]
    pub colors: ::prost::alloc::vec::Vec<CMsgRgba>,
    #[prost(float, repeated, packed = "false", tag = "4")]
    pub dimensions: ::prost::alloc::vec::Vec<f32>,
    #[prost(float, repeated, packed = "false", tag = "5")]
    pub times: ::prost::alloc::vec::Vec<f32>,
    #[prost(bool, repeated, packed = "false", tag = "6")]
    pub bools: ::prost::alloc::vec::Vec<bool>,
    #[prost(uint64, repeated, packed = "false", tag = "7")]
    pub uint64s: ::prost::alloc::vec::Vec<u64>,
    #[prost(string, repeated, tag = "8")]
    pub strings: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum SignonStateT {
    SignonstateNone = 0,
    SignonstateChallenge = 1,
    SignonstateConnected = 2,
    SignonstateNew = 3,
    SignonstatePrespawn = 4,
    SignonstateSpawn = 5,
    SignonstateFull = 6,
    SignonstateChangelevel = 7,
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum NetMessages {
    NetNop = 0,
    NetDisconnectLegacy = 1,
    NetSplitScreenUser = 3,
    NetTick = 4,
    NetStringCmd = 5,
    NetSetConVar = 6,
    NetSignonState = 7,
    NetSpawnGroupLoad = 8,
    NetSpawnGroupManifestUpdate = 9,
    NetSpawnGroupSetCreationTick = 11,
    NetSpawnGroupUnload = 12,
    NetSpawnGroupLoadCompleted = 13,
    NetDebugOverlay = 15,
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum SpawnGroupFlagsT {
    SpawnGroupLoadEntitiesFromSave = 1,
    SpawnGroupDontSpawnEntities = 2,
    SpawnGroupSynchronousSpawn = 4,
    SpawnGroupIsInitialSpawnGroup = 8,
    SpawnGroupCreateClientOnlyEntities = 16,
    SpawnGroupBlockUntilLoaded = 64,
    SpawnGroupLoadStreamingData = 128,
    SpawnGroupCreateNewSceneWorld = 256,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CDotaMsgLocationPing {
    #[prost(int32, optional, tag = "1")]
    pub x: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub y: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3", default = "-1")]
    pub target: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "4")]
    pub direct_ping: ::core::option::Option<bool>,
    #[prost(uint32, optional, tag = "5", default = "4294967295")]
    pub r#type: ::core::option::Option<u32>,
    #[prost(
        enumeration = "EPingSource",
        optional,
        tag = "6",
        default = "KEPingSourceDefault"
    )]
    pub ping_source: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CDotaMsgItemAlert {
    #[prost(int32, optional, tag = "1")]
    pub x: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub y: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3", default = "-1")]
    pub item_ability_id: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CDotaMsgMapLine {
    #[prost(int32, optional, tag = "1")]
    pub x: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub y: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "3")]
    pub initial: ::core::option::Option<bool>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CDotaMsgWorldLine {
    #[prost(int32, optional, tag = "1")]
    pub x: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub y: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub z: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "4")]
    pub initial: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "5")]
    pub end: ::core::option::Option<bool>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDotaMsgSendStatPopup {
    #[prost(
        enumeration = "EDotaStatPopupTypes",
        optional,
        tag = "1",
        default = "KEDotaSptTextline"
    )]
    pub style: ::core::option::Option<i32>,
    #[prost(string, repeated, tag = "2")]
    pub stat_strings: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(int32, repeated, packed = "false", tag = "3")]
    pub stat_images: ::prost::alloc::vec::Vec<i32>,
    #[prost(int32, repeated, packed = "false", tag = "4")]
    pub stat_image_types: ::prost::alloc::vec::Vec<i32>,
    #[prost(float, optional, tag = "5")]
    pub duration: ::core::option::Option<f32>,
    #[prost(bool, optional, tag = "6")]
    pub use_html: ::core::option::Option<bool>,
    #[prost(string, optional, tag = "7")]
    pub movie_name: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CDotaMsgDismissAllStatPopups {
    #[prost(float, optional, tag = "1")]
    pub time_delay: ::core::option::Option<f32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDotaMsgCoachHudPing {
    #[prost(uint32, optional, tag = "1")]
    pub x: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub y: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "3")]
    pub tgtpath: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDotaMsgUnitOrder {
    #[prost(
        enumeration = "DotaunitorderT",
        optional,
        tag = "2",
        default = "DotaUnitOrderNone"
    )]
    pub order_type: ::core::option::Option<i32>,
    #[prost(int32, repeated, packed = "false", tag = "3")]
    pub units: ::prost::alloc::vec::Vec<i32>,
    #[prost(int32, optional, tag = "4", default = "0")]
    pub target_index: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "5", default = "-1")]
    pub ability_index: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "6")]
    pub position: ::core::option::Option<CMsgVector>,
    #[prost(int32, optional, tag = "8")]
    pub sequence_number: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "9")]
    pub flags: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VersusScenePlayActivity {
    #[prost(message, repeated, tag = "1")]
    pub activities: ::prost::alloc::vec::Vec<versus_scene_play_activity::ActivityInfo>,
    #[prost(float, optional, tag = "2")]
    pub playback_rate: ::core::option::Option<f32>,
}
/// Nested message and enum types in `VersusScene_PlayActivity`.
pub mod versus_scene_play_activity {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ActivityInfo {
        #[prost(string, optional, tag = "1")]
        pub activity: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(bool, optional, tag = "2")]
        pub disable_auto_kill: ::core::option::Option<bool>,
        #[prost(bool, optional, tag = "3")]
        pub force_looping: ::core::option::Option<bool>,
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct VersusSceneChatWheel {
    #[prost(uint32, optional, tag = "1", default = "4294967295")]
    pub chat_message_id: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub emoticon_id: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct VersusScenePlaybackRate {
    #[prost(float, optional, tag = "1")]
    pub rate: ::core::option::Option<f32>,
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum EPingSource {
    KEPingSourceDefault = 0,
    KEPingSourceWarning = 1,
    KEPingSourceWheel = 2,
    KEPingSourceSystem = 3,
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum EDotaStatPopupTypes {
    KEDotaSptTextline = 0,
    KEDotaSptBasic = 1,
    KEDotaSptPoll = 2,
    KEDotaSptGrid = 3,
    KEDotaSptDualImage = 4,
    KEDotaSptMovie = 5,
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum DotaunitorderT {
    DotaUnitOrderNone = 0,
    DotaUnitOrderMoveToPosition = 1,
    DotaUnitOrderMoveToTarget = 2,
    DotaUnitOrderAttackMove = 3,
    DotaUnitOrderAttackTarget = 4,
    DotaUnitOrderCastPosition = 5,
    DotaUnitOrderCastTarget = 6,
    DotaUnitOrderCastTargetTree = 7,
    DotaUnitOrderCastNoTarget = 8,
    DotaUnitOrderCastToggle = 9,
    DotaUnitOrderHoldPosition = 10,
    DotaUnitOrderTrainAbility = 11,
    DotaUnitOrderDropItem = 12,
    DotaUnitOrderGiveItem = 13,
    DotaUnitOrderPickupItem = 14,
    DotaUnitOrderPickupRune = 15,
    DotaUnitOrderPurchaseItem = 16,
    DotaUnitOrderSellItem = 17,
    DotaUnitOrderDisassembleItem = 18,
    DotaUnitOrderMoveItem = 19,
    DotaUnitOrderCastToggleAuto = 20,
    DotaUnitOrderStop = 21,
    DotaUnitOrderTaunt = 22,
    DotaUnitOrderBuyback = 23,
    DotaUnitOrderGlyph = 24,
    DotaUnitOrderEjectItemFromStash = 25,
    DotaUnitOrderCastRune = 26,
    DotaUnitOrderPingAbility = 27,
    DotaUnitOrderMoveToDirection = 28,
    DotaUnitOrderPatrol = 29,
    DotaUnitOrderVectorTargetPosition = 30,
    DotaUnitOrderRadar = 31,
    DotaUnitOrderSetItemCombineLock = 32,
    DotaUnitOrderContinue = 33,
    DotaUnitOrderVectorTargetCanceled = 34,
    DotaUnitOrderCastRiverPaint = 35,
    DotaUnitOrderPregameAdjustItemAssignment = 36,
    DotaUnitOrderDropItemAtFountain = 37,
    DotaUnitOrderTakeItemFromNeutralItemStash = 38,
    DotaUnitOrderMoveRelative = 39,
    DotaUnitOrderCastToggleAlt = 40,
    DotaUnitOrderConsumeItem = 41,
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum EDotaVersusScenePlayerBehavior {
    VsPlayerBehaviorPlayActivity = 1,
    VsPlayerBehaviorChatWheel = 2,
    VsPlayerBehaviorPlaybackRate = 3,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDotaModifierBuffTableEntry {
    #[prost(
        enumeration = "DotaModifierEntryType",
        required,
        tag = "1",
        default = "Active"
    )]
    pub entry_type: i32,
    #[prost(uint32, required, tag = "2", default = "16777215")]
    pub parent: u32,
    #[prost(int32, required, tag = "3")]
    pub index: i32,
    #[prost(int32, required, tag = "4")]
    pub serial_num: i32,
    #[prost(int32, optional, tag = "5")]
    pub modifier_class: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "6")]
    pub ability_level: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "7")]
    pub stack_count: ::core::option::Option<i32>,
    #[prost(float, optional, tag = "8")]
    pub creation_time: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "9", default = "-1")]
    pub duration: ::core::option::Option<f32>,
    #[prost(uint32, optional, tag = "10", default = "16777215")]
    pub caster: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "11", default = "16777215")]
    pub ability: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "12")]
    pub armor: ::core::option::Option<i32>,
    #[prost(float, optional, tag = "13")]
    pub fade_time: ::core::option::Option<f32>,
    #[prost(bool, optional, tag = "14")]
    pub subtle: ::core::option::Option<bool>,
    #[prost(float, optional, tag = "15")]
    pub channel_time: ::core::option::Option<f32>,
    #[prost(message, optional, tag = "16")]
    pub v_start: ::core::option::Option<CMsgVector>,
    #[prost(message, optional, tag = "17")]
    pub v_end: ::core::option::Option<CMsgVector>,
    #[prost(string, optional, tag = "18")]
    pub portal_loop_appear: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19")]
    pub portal_loop_disappear: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "20")]
    pub hero_loop_appear: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "21")]
    pub hero_loop_disappear: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "22")]
    pub movement_speed: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "23")]
    pub aura: ::core::option::Option<bool>,
    #[prost(int32, optional, tag = "24")]
    pub activity: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "25")]
    pub damage: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "26")]
    pub range: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "27")]
    pub dd_modifier_index: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "28", default = "-1")]
    pub dd_ability_id: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "29")]
    pub illusion_label: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "30")]
    pub active: ::core::option::Option<bool>,
    #[prost(string, optional, tag = "31")]
    pub player_ids: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "32")]
    pub lua_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "33")]
    pub attack_speed: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "34", default = "16777215")]
    pub aura_owner: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "35")]
    pub bonus_all_stats: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "36")]
    pub bonus_health: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "37")]
    pub bonus_mana: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "38", default = "16777215")]
    pub custom_entity: ::core::option::Option<u32>,
    #[prost(bool, optional, tag = "39")]
    pub aura_within_range: ::core::option::Option<bool>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDotaLuaModifierEntry {
    #[prost(int32, required, tag = "1")]
    pub modifier_type: i32,
    #[prost(string, required, tag = "2")]
    pub modifier_filename: ::prost::alloc::string::String,
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum DotaModifierEntryType {
    Active = 1,
    Removed = 2,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDotaClientHardwareSpecs {
    #[prost(uint32, optional, tag = "1")]
    pub logical_processors: ::core::option::Option<u32>,
    #[prost(fixed64, optional, tag = "2")]
    pub cpu_cycles_per_second: ::core::option::Option<u64>,
    #[prost(fixed64, optional, tag = "3")]
    pub total_physical_memory: ::core::option::Option<u64>,
    #[prost(bool, optional, tag = "4")]
    pub is_64_bit_os: ::core::option::Option<bool>,
    #[prost(uint64, optional, tag = "5")]
    pub upload_measurement: ::core::option::Option<u64>,
    #[prost(bool, optional, tag = "6")]
    pub prefer_not_host: ::core::option::Option<bool>,
    #[prost(uint32, repeated, packed = "false", tag = "7")]
    pub crc: ::prost::alloc::vec::Vec<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDotaSaveGame {
    #[prost(uint64, optional, tag = "5")]
    pub match_id: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "2")]
    pub save_time: ::core::option::Option<u32>,
    #[prost(message, repeated, tag = "3")]
    pub players: ::prost::alloc::vec::Vec<cdota_save_game::Player>,
    #[prost(message, repeated, tag = "4")]
    pub save_instances: ::prost::alloc::vec::Vec<cdota_save_game::SaveInstance>,
}
/// Nested message and enum types in `CDOTASaveGame`.
pub mod cdota_save_game {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Player {
        #[prost(
            enumeration = "super::DotaGcTeam",
            optional,
            tag = "1",
            default = "GoodGuys"
        )]
        pub team: ::core::option::Option<i32>,
        #[prost(string, optional, tag = "2")]
        pub name: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag = "3")]
        pub hero: ::core::option::Option<::prost::alloc::string::String>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SaveInstance {
        #[prost(uint32, optional, tag = "2")]
        pub game_time: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "3")]
        pub team1_score: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "4")]
        pub team2_score: ::core::option::Option<u32>,
        #[prost(message, repeated, tag = "5")]
        pub player_positions: ::prost::alloc::vec::Vec<save_instance::PlayerPositions>,
        #[prost(uint32, optional, tag = "6")]
        pub save_id: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "7")]
        pub save_time: ::core::option::Option<u32>,
    }
    /// Nested message and enum types in `SaveInstance`.
    pub mod save_instance {
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct PlayerPositions {
            #[prost(float, optional, tag = "1")]
            pub x: ::core::option::Option<f32>,
            #[prost(float, optional, tag = "2")]
            pub y: ::core::option::Option<f32>,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgDotaCombatLogEntry {
    #[prost(
        enumeration = "DotaCombatlogTypes",
        optional,
        tag = "1",
        default = "DotaCombatlogInvalid"
    )]
    pub r#type: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "2")]
    pub target_name: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub target_source_name: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub attacker_name: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "5")]
    pub damage_source_name: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "6")]
    pub inflictor_name: ::core::option::Option<u32>,
    #[prost(bool, optional, tag = "7")]
    pub is_attacker_illusion: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "8")]
    pub is_attacker_hero: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "9")]
    pub is_target_illusion: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "10")]
    pub is_target_hero: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "11")]
    pub is_visible_radiant: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "12")]
    pub is_visible_dire: ::core::option::Option<bool>,
    #[prost(uint32, optional, tag = "13")]
    pub value: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "14")]
    pub health: ::core::option::Option<i32>,
    #[prost(float, optional, tag = "15")]
    pub timestamp: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "16")]
    pub stun_duration: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "17")]
    pub slow_duration: ::core::option::Option<f32>,
    #[prost(bool, optional, tag = "18")]
    pub is_ability_toggle_on: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "19")]
    pub is_ability_toggle_off: ::core::option::Option<bool>,
    #[prost(uint32, optional, tag = "20")]
    pub ability_level: ::core::option::Option<u32>,
    #[prost(float, optional, tag = "21")]
    pub location_x: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "22")]
    pub location_y: ::core::option::Option<f32>,
    #[prost(uint32, optional, tag = "23")]
    pub gold_reason: ::core::option::Option<u32>,
    #[prost(float, optional, tag = "24")]
    pub timestamp_raw: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "25")]
    pub modifier_duration: ::core::option::Option<f32>,
    #[prost(uint32, optional, tag = "26")]
    pub xp_reason: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "27")]
    pub last_hits: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "28")]
    pub attacker_team: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "29")]
    pub target_team: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "30")]
    pub obs_wards_placed: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "31")]
    pub assist_player0: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "32")]
    pub assist_player1: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "33")]
    pub assist_player2: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "34")]
    pub assist_player3: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "35")]
    pub stack_count: ::core::option::Option<u32>,
    #[prost(bool, optional, tag = "36")]
    pub hidden_modifier: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "37")]
    pub is_target_building: ::core::option::Option<bool>,
    #[prost(uint32, optional, tag = "38")]
    pub neutral_camp_type: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "39")]
    pub rune_type: ::core::option::Option<u32>,
    #[prost(int32, repeated, packed = "false", tag = "40")]
    pub assist_players: ::prost::alloc::vec::Vec<i32>,
    #[prost(bool, optional, tag = "41")]
    pub is_heal_save: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "42")]
    pub is_ultimate_ability: ::core::option::Option<bool>,
    #[prost(uint32, optional, tag = "43")]
    pub attacker_hero_level: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "44")]
    pub target_hero_level: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "45")]
    pub xpm: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "46")]
    pub gpm: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "47")]
    pub event_location: ::core::option::Option<u32>,
    #[prost(bool, optional, tag = "48")]
    pub target_is_self: ::core::option::Option<bool>,
    #[prost(uint32, optional, tag = "49")]
    pub damage_type: ::core::option::Option<u32>,
    #[prost(bool, optional, tag = "50")]
    pub invisibility_modifier: ::core::option::Option<bool>,
    #[prost(uint32, optional, tag = "51")]
    pub damage_category: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "52")]
    pub networth: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "53")]
    pub building_type: ::core::option::Option<u32>,
    #[prost(float, optional, tag = "54")]
    pub modifier_elapsed_duration: ::core::option::Option<f32>,
    #[prost(bool, optional, tag = "55")]
    pub silence_modifier: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "56")]
    pub heal_from_lifesteal: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "57")]
    pub modifier_purged: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "58")]
    pub spell_evaded: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "59")]
    pub motion_controller_modifier: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "60")]
    pub long_range_kill: ::core::option::Option<bool>,
    #[prost(uint32, optional, tag = "61")]
    pub modifier_purge_ability: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "62")]
    pub modifier_purge_npc: ::core::option::Option<u32>,
    #[prost(bool, optional, tag = "63")]
    pub root_modifier: ::core::option::Option<bool>,
    #[prost(uint32, optional, tag = "64")]
    pub total_unit_death_count: ::core::option::Option<u32>,
    #[prost(bool, optional, tag = "65")]
    pub aura_modifier: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "66")]
    pub armor_debuff_modifier: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "67")]
    pub no_physical_damage_modifier: ::core::option::Option<bool>,
    #[prost(uint32, optional, tag = "68")]
    pub modifier_ability: ::core::option::Option<u32>,
    #[prost(bool, optional, tag = "69")]
    pub modifier_hidden: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "70")]
    pub inflictor_is_stolen_ability: ::core::option::Option<bool>,
    #[prost(uint32, optional, tag = "71")]
    pub kill_eater_event: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "72")]
    pub unit_status_label: ::core::option::Option<u32>,
    #[prost(bool, optional, tag = "73")]
    pub spell_generated_attack: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "74")]
    pub at_night_time: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "75")]
    pub attacker_has_scepter: ::core::option::Option<bool>,
    #[prost(uint32, optional, tag = "76")]
    pub neutral_camp_team: ::core::option::Option<u32>,
    #[prost(float, optional, tag = "77")]
    pub regenerated_health: ::core::option::Option<f32>,
    #[prost(bool, optional, tag = "78")]
    pub will_reincarnate: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "79")]
    pub uses_charges: ::core::option::Option<bool>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgPendingEventAward {
    #[prost(enumeration = "EEvent", optional, tag = "1", default = "EventIdNone")]
    pub event_id: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "2")]
    pub action_id: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub num_to_grant: ::core::option::Option<u32>,
    #[prost(
        enumeration = "EEventActionScoreMode",
        optional,
        tag = "4",
        default = "KEEventActionScoreModeAdd"
    )]
    pub score_mode: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "5")]
    pub audit_action: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "6")]
    pub audit_data: ::core::option::Option<u64>,
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum DotaGameMode {
    DotaGamemodeNone = 0,
    DotaGamemodeAp = 1,
    DotaGamemodeCm = 2,
    DotaGamemodeRd = 3,
    DotaGamemodeSd = 4,
    DotaGamemodeAr = 5,
    DotaGamemodeIntro = 6,
    DotaGamemodeHw = 7,
    DotaGamemodeReverseCm = 8,
    DotaGamemodeXmas = 9,
    DotaGamemodeTutorial = 10,
    DotaGamemodeMo = 11,
    DotaGamemodeLp = 12,
    DotaGamemodePool1 = 13,
    DotaGamemodeFh = 14,
    DotaGamemodeCustom = 15,
    DotaGamemodeCd = 16,
    DotaGamemodeBd = 17,
    DotaGamemodeAbilityDraft = 18,
    DotaGamemodeEvent = 19,
    DotaGamemodeArdm = 20,
    DotaGamemode1v1mid = 21,
    DotaGamemodeAllDraft = 22,
    DotaGamemodeTurbo = 23,
    DotaGamemodeMutation = 24,
    DotaGamemodeCoachesChallenge = 25,
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum DotaGameState {
    DotaGamerulesStateInit = 0,
    DotaGamerulesStateWaitForPlayersToLoad = 1,
    DotaGamerulesStateHeroSelection = 2,
    DotaGamerulesStateStrategyTime = 3,
    DotaGamerulesStatePreGame = 4,
    DotaGamerulesStateGameInProgress = 5,
    DotaGamerulesStatePostGame = 6,
    DotaGamerulesStateDisconnect = 7,
    DotaGamerulesStateTeamShowcase = 8,
    DotaGamerulesStateCustomGameSetup = 9,
    DotaGamerulesStateWaitForMapToLoad = 10,
    DotaGamerulesStateScenarioSetup = 11,
    DotaGamerulesStatePlayerDraft = 12,
    DotaGamerulesStateLast = 13,
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum DotaGcTeam {
    GoodGuys = 0,
    BadGuys = 1,
    Broadcaster = 2,
    Spectator = 3,
    PlayerPool = 4,
    Noteam = 5,
    Custom1 = 6,
    Custom2 = 7,
    Custom3 = 8,
    Custom4 = 9,
    Custom5 = 10,
    Custom6 = 11,
    Custom7 = 12,
    Custom8 = 13,
    Neutrals = 14,
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum EEvent {
    EventIdNone = 0,
    EventIdDiretide = 1,
    EventIdSpringFestival = 2,
    EventIdFrostivus2013 = 3,
    EventIdCompendium2014 = 4,
    EventIdNexonPcBang = 5,
    EventIdPwrdDac2015 = 6,
    EventIdNewBloom2015 = 7,
    EventIdInternational2015 = 8,
    EventIdFallMajor2015 = 9,
    EventIdOraclePa = 10,
    EventIdNewBloom2015Prebeast = 11,
    EventIdFrostivus = 12,
    EventIdWinterMajor2016 = 13,
    EventIdInternational2016 = 14,
    EventIdFallMajor2016 = 15,
    EventIdWinterMajor2017 = 16,
    EventIdNewBloom2017 = 17,
    EventIdInternational2017 = 18,
    EventIdPlusSubscription = 19,
    EventIdSinglesDay2017 = 20,
    EventIdFrostivus2017 = 21,
    EventIdInternational2018 = 22,
    EventIdFrostivus2018 = 23,
    EventIdNewBloom2019 = 24,
    EventIdInternational2019 = 25,
    EventIdNewPlayerExperience = 26,
    EventIdFrostivus2019 = 27,
    EventIdNewBloom2020 = 28,
    EventIdInternational2020 = 29,
    EventIdTeamFandom = 30,
    EventIdDiretide2020 = 31,
    EventIdSpring2021 = 32,
    EventIdFall2021 = 33,
    EventIdTeamFandomFall2021 = 34,
    EventIdTeam20212022Tour2 = 35,
    EventIdInternational2022 = 36,
    EventIdTeam20212022Tour3 = 37,
    EventIdTeamInternational2022 = 38,
    EventIdPermanentGrants = 39,
    EventIdMuertaReleaseSpring2023 = 40,
    EventIdTeam2023Tour1 = 41,
    EventIdTeam2023Tour2 = 42,
    EventIdTeam2023Tour3 = 43,
    EventIdInternational2023 = 45,
    EventId10thAnniversary = 46,
    EventIdCrownfall = 47,
    EventIdFrostivus2023 = 48,
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum ERankType {
    KERankTypeInvalid = 0,
    KERankTypeCasual = 1,
    KERankTypeRanked = 2,
    KERankTypeCasualLegacy = 3,
    KERankTypeRankedLegacy = 4,
    KERankTypeCasualGlicko = 5,
    KERankTypeRankedGlicko = 6,
    KERankTypeRankMax = 7,
    KERankTypeBehaviorPrivate = 100,
    KERankTypeBehaviorPublic = 101,
    KERankTypeMax = 102,
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum DotaLeaverStatusT {
    DotaLeaverNone = 0,
    DotaLeaverDisconnected = 1,
    DotaLeaverDisconnectedTooLong = 2,
    DotaLeaverAbandoned = 3,
    DotaLeaverAfk = 4,
    DotaLeaverNeverConnected = 5,
    DotaLeaverNeverConnectedTooLong = 6,
    DotaLeaverFailedToReadyUp = 7,
    DotaLeaverDeclined = 8,
    DotaLeaverDeclinedRequeue = 9,
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum DotaConnectionStateT {
    DotaConnectionStateUnknown = 0,
    DotaConnectionStateNotYetConnected = 1,
    DotaConnectionStateConnected = 2,
    DotaConnectionStateDisconnected = 3,
    DotaConnectionStateAbandoned = 4,
    DotaConnectionStateLoading = 5,
    DotaConnectionStateFailed = 6,
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum FantasyRoles {
    FantasyRoleUndefined = 0,
    FantasyRoleCore = 1,
    FantasyRoleSupport = 2,
    FantasyRoleOfflane = 3,
    FantasyRoleMid = 4,
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum FantasyScoring {
    Kills = 0,
    Deaths = 1,
    Cs = 2,
    Gpm = 3,
    TowerKills = 4,
    RoshanKills = 5,
    TeamfightParticipation = 6,
    WardsPlanted = 7,
    CampsStacked = 8,
    RunesGrabbed = 9,
    FirstBlood = 10,
    Stuns = 11,
    SmokesUsed = 12,
    NeutralTokensFound = 13,
    WatchersTaken = 14,
    LotusesGained = 15,
    TormentorKills = 16,
    CourierKills = 17,
    Types = 18,
    Invalid = 19,
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum FantasyTeamSlots {
    FantasySlotNone = 0,
    FantasySlotCore = 1,
    FantasySlotSupport = 2,
    FantasySlotAny = 3,
    FantasySlotBench = 4,
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum FantasySelectionMode {
    FantasySelectionInvalid = 0,
    FantasySelectionLocked = 1,
    FantasySelectionShuffle = 2,
    FantasySelectionFreePick = 3,
    FantasySelectionEnded = 4,
    FantasySelectionPreSeason = 5,
    FantasySelectionPreDraft = 6,
    FantasySelectionDrafting = 7,
    FantasySelectionRegularSeason = 8,
    FantasySelectionCardBased = 9,
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum FantasyGemType {
    Ruby = 0,
    Sapphire = 1,
    Emerald = 2,
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum DotaChatChannelTypeT {
    DotaChannelTypeRegional = 0,
    DotaChannelTypeCustom = 1,
    DotaChannelTypeParty = 2,
    DotaChannelTypeLobby = 3,
    DotaChannelTypeTeam = 4,
    DotaChannelTypeGuild = 5,
    DotaChannelTypeFantasy = 6,
    DotaChannelTypeWhisper = 7,
    DotaChannelTypeConsole = 8,
    DotaChannelTypeTab = 9,
    DotaChannelTypeInvalid = 10,
    DotaChannelTypeGameAll = 11,
    DotaChannelTypeGameAllies = 12,
    DotaChannelTypeGameSpectator = 13,
    DotaChannelTypeGameCoaching = 14,
    DotaChannelTypeCafe = 15,
    DotaChannelTypeCustomGame = 16,
    DotaChannelTypePrivate = 17,
    DotaChannelTypePostGame = 18,
    DotaChannelTypeBattleCup = 19,
    DotaChannelTypeHltvSpectator = 20,
    DotaChannelTypeGameEvents = 21,
    DotaChannelTypeTrivia = 22,
    DotaChannelTypeNewPlayer = 23,
    DotaChannelTypePrivateCoaching = 24,
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum EChatSpecialPrivileges {
    KEChatSpecialPrivilegesNone = 0,
    KEChatSpecialPrivilegesModerator = 1,
    KEChatSpecialPrivilegesSuperModerator = 2,
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum DotaCommTypeT {
    DotaCommTypeNone = 0,
    DotaCommTypePing = 1,
    DotaCommTypeChatwheel = 2,
    DotaCommTypeTip = 3,
    DotaCommTypeText = 4,
    DotaCommTypeShowcase = 5,
    DotaCommTypeVoice = 6,
    DotaCommTypeAllyAbility = 7,
    DotaCommTypePause = 8,
    DotaCommTypeCoaching = 9,
    DotaCommTypeNocooldown = 10,
    DotaCommTypeRankedmatchmake = 11,
    DotaCommTypeDrops = 12,
    DotaCommTypeNewplayerExpert = 13,
    DotaCommTypeCoached = 14,
    DotaCommTypeMapdrawing = 15,
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum DotaCommLevelT {
    DotaCommLevelNone = 0,
    DotaCommLevelCooldown = 1,
    DotaCommLevelPings = 2,
    DotaCommLevelMapdrawing = 3,
    DotaCommLevelChat = 4,
    DotaCommLevelTipping = 5,
    DotaCommLevelVoice = 6,
    DotaCommLevelAlliedAbility = 7,
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum DotaBehaviorLevelT {
    DotaBehaviorLevelNone = 0,
    DotaBehaviorLevelRankedAllowed = 1,
    DotaBehaviorLevelPausing = 2,
    DotaBehaviorLevelDrops = 3,
    DotaBehaviorLevelCoaching = 4,
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum EProfileCardSlotType {
    KEProfileCardSlotTypeEmpty = 0,
    KEProfileCardSlotTypeStat = 1,
    KEProfileCardSlotTypeTrophy = 2,
    KEProfileCardSlotTypeItem = 3,
    KEProfileCardSlotTypeHero = 4,
    KEProfileCardSlotTypeEmoticon = 5,
    KEProfileCardSlotTypeTeam = 6,
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum EMatchGroupServerStatus {
    KEMatchGroupServerStatusOk = 0,
    KEMatchGroupServerStatusLimitedAvailability = 1,
    KEMatchGroupServerStatusOffline = 2,
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum DotaCmPick {
    DotaCmRandom = 0,
    DotaCmGoodGuys = 1,
    DotaCmBadGuys = 2,
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum DotaLowPriorityBanType {
    DotaLowPriorityBanAbandon = 0,
    DotaLowPriorityBanReports = 1,
    DotaLowPriorityBanSecondaryAbandon = 2,
    DotaLowPriorityBanPreGameRole = 3,
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum DotaLobbyReadyState {
    Undeclared = 0,
    Accepted = 1,
    Declined = 2,
    DeclinedRequeue = 3,
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum DotaJoinLobbyResult {
    DotaJoinResultSuccess = 0,
    DotaJoinResultAlreadyInGame = 1,
    DotaJoinResultInvalidLobby = 2,
    DotaJoinResultIncorrectPassword = 3,
    DotaJoinResultAccessDenied = 4,
    DotaJoinResultGenericError = 5,
    DotaJoinResultIncorrectVersion = 6,
    DotaJoinResultInTeamParty = 7,
    DotaJoinResultNoLobbyFound = 8,
    DotaJoinResultLobbyFull = 9,
    DotaJoinResultCustomGameIncorrectVersion = 10,
    DotaJoinResultTimeout = 11,
    DotaJoinResultCustomGameCooldown = 12,
    DotaJoinResultBusy = 13,
    DotaJoinResultNoPlaytime = 14,
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum DotaSelectionPriorityRules {
    KDotaSelectionPriorityRulesManual = 0,
    KDotaSelectionPriorityRulesAutomatic = 1,
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum DotaSelectionPriorityChoice {
    KDotaSelectionPriorityChoiceInvalid = 0,
    KDotaSelectionPriorityChoiceFirstPick = 1,
    KDotaSelectionPriorityChoiceSecondPick = 2,
    KDotaSelectionPriorityChoiceRadiant = 3,
    KDotaSelectionPriorityChoiceDire = 4,
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum DotaMatchVote {
    Invalid = 0,
    Positive = 1,
    Negative = 2,
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum DotaLobbyVisibility {
    Public = 0,
    Friends = 1,
    Unlisted = 2,
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum EDotaPlayerMmrType {
    KEDotaPlayerMmrTypeInvalid = 0,
    KEDotaPlayerMmrTypeGeneralHidden = 1,
    KEDotaPlayerMmrTypeGeneralCompetitive = 3,
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum EDotammrBoostType {
    KEDotammrBoostTypeNone = 0,
    KEDotammrBoostTypeLeader = 1,
    KEDotammrBoostTypeFollower = 2,
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum MatchType {
    Casual = 0,
    CoopBots = 1,
    Competitive = 4,
    WeekendTourney = 5,
    Event = 7,
    CoachesChallenge = 12,
    NewPlayerPool = 14,
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum DotaBotDifficulty {
    BotDifficultyPassive = 0,
    BotDifficultyEasy = 1,
    BotDifficultyMedium = 2,
    BotDifficultyHard = 3,
    BotDifficultyUnfair = 4,
    BotDifficultyInvalid = 5,
    BotDifficultyExtra1 = 6,
    BotDifficultyExtra2 = 7,
    BotDifficultyExtra3 = 8,
    BotDifficultyNpx = 9,
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum DotaBotMode {
    None = 0,
    Laning = 1,
    Attack = 2,
    Roam = 3,
    Retreat = 4,
    SecretShop = 5,
    SideShop = 6,
    Rune = 7,
    PushTowerTop = 8,
    PushTowerMid = 9,
    PushTowerBot = 10,
    DefendTowerTop = 11,
    DefendTowerMid = 12,
    DefendTowerBot = 13,
    Assemble = 14,
    AssembleWithHumans = 15,
    TeamRoam = 16,
    Farm = 17,
    DefendAlly = 18,
    EvasiveManeuvers = 19,
    Roshan = 20,
    Item = 21,
    Ward = 22,
    Companion = 23,
    TutorialBoss = 24,
    Minion = 25,
    Outpost = 26,
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum MatchLanguages {
    MatchLanguageInvalid = 0,
    MatchLanguageEnglish = 1,
    MatchLanguageRussian = 2,
    MatchLanguageChinese = 3,
    MatchLanguageKorean = 4,
    MatchLanguageSpanish = 5,
    MatchLanguagePortuguese = 6,
    MatchLanguageEnglish2 = 7,
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum ETourneyQueueDeadlineState {
    KETourneyQueueDeadlineStateNormal = 0,
    KETourneyQueueDeadlineStateMissed = 1,
    KETourneyQueueDeadlineStateExpiredOk = 2,
    KETourneyQueueDeadlineStateSeekingBye = 3,
    KETourneyQueueDeadlineStateEligibleForRefund = 4,
    KETourneyQueueDeadlineStateNa = -1,
    KETourneyQueueDeadlineStateExpiringSoon = 101,
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum EMatchOutcome {
    KEMatchOutcomeUnknown = 0,
    KEMatchOutcomeRadVictory = 2,
    KEMatchOutcomeDireVictory = 3,
    KEMatchOutcomeNeutralVictory = 4,
    KEMatchOutcomeNoTeamWinner = 5,
    KEMatchOutcomeCustom1Victory = 6,
    KEMatchOutcomeCustom2Victory = 7,
    KEMatchOutcomeCustom3Victory = 8,
    KEMatchOutcomeCustom4Victory = 9,
    KEMatchOutcomeCustom5Victory = 10,
    KEMatchOutcomeCustom6Victory = 11,
    KEMatchOutcomeCustom7Victory = 12,
    KEMatchOutcomeCustom8Victory = 13,
    KEMatchOutcomeNotScoredPoorNetworkConditions = 64,
    KEMatchOutcomeNotScoredLeaver = 65,
    KEMatchOutcomeNotScoredServerCrash = 66,
    KEMatchOutcomeNotScoredNeverStarted = 67,
    KEMatchOutcomeNotScoredCanceled = 68,
    KEMatchOutcomeNotScoredSuspicious = 69,
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum ELaneType {
    LaneTypeUnknown = 0,
    LaneTypeSafe = 1,
    LaneTypeOff = 2,
    LaneTypeMid = 3,
    LaneTypeJungle = 4,
    LaneTypeRoam = 5,
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum EBadgeType {
    KEBadgeTypeInvalid = 0,
    KEBadgeTypeTi7Midweek = 1,
    KEBadgeTypeTi7Finals = 2,
    KEBadgeTypeTi7AllEvent = 3,
    KEBadgeTypeTi8Midweek = 4,
    KEBadgeTypeTi8Finals = 5,
    KEBadgeTypeTi8AllEvent = 6,
    KEBadgeTypeTi10 = 7,
    KEBadgeTypeTi11PlayoffsDay1 = 8,
    KEBadgeTypeTi11PlayoffsDay2 = 9,
    KEBadgeTypeTi11PlayoffsDay3 = 10,
    KEBadgeTypeTi11PlayoffsDay4 = 11,
    KEBadgeTypeTi11FinalsWeekend = 12,
    KEBadgeTypeTi12PlayoffsDay1 = 13,
    KEBadgeTypeTi12PlayoffsDay2 = 14,
    KEBadgeTypeTi12PlayoffsDay3 = 15,
    KEBadgeTypeTi12FinalsWeekend = 16,
    KEBadgeTypeTi12Special = 17,
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum ELeagueStatus {
    LeagueStatusUnset = 0,
    LeagueStatusUnsubmitted = 1,
    LeagueStatusSubmitted = 2,
    LeagueStatusAccepted = 3,
    LeagueStatusRejected = 4,
    LeagueStatusConcluded = 5,
    LeagueStatusDeleted = 6,
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum ELeagueRegion {
    LeagueRegionUnset = 0,
    LeagueRegionNa = 1,
    LeagueRegionSa = 2,
    LeagueRegionWeu = 3,
    LeagueRegionEeu = 4,
    LeagueRegionChina = 5,
    LeagueRegionSea = 6,
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum ELeagueTier {
    LeagueTierUnset = 0,
    LeagueTierAmateur = 1,
    LeagueTierProfessional = 2,
    LeagueTierMinor = 3,
    LeagueTierMajor = 4,
    LeagueTierInternational = 5,
    LeagueTierDpcQualifier = 6,
    LeagueTierDpcLeagueQualifier = 7,
    LeagueTierDpcLeague = 8,
    LeagueTierDpcLeagueFinals = 9,
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum ELeagueTierCategory {
    LeagueTierCategoryAmateur = 1,
    LeagueTierCategoryProfessional = 2,
    LeagueTierCategoryDpc = 3,
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum ELeagueDivision {
    LeagueDivisionUnset = 0,
    LeagueDivisionI = 1,
    LeagueDivisionIi = 2,
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum ELeagueBroadcastProvider {
    LeagueBroadcastUnknown = 0,
    LeagueBroadcastSteam = 1,
    LeagueBroadcastTwitch = 2,
    LeagueBroadcastYoutube = 3,
    LeagueBroadcastOther = 100,
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum ELeaguePhase {
    LeaguePhaseUnset = 0,
    LeaguePhaseRegionalQualifier = 1,
    LeaguePhaseGroupStage = 2,
    LeaguePhaseMainEvent = 3,
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum ELeagueAuditAction {
    LeagueAuditActionInvalid = 0,
    LeagueAuditActionLeagueCreate = 1,
    LeagueAuditActionLeagueEdit = 2,
    LeagueAuditActionLeagueDelete = 3,
    LeagueAuditActionLeagueAdminAdd = 4,
    LeagueAuditActionLeagueAdminRevoke = 5,
    LeagueAuditActionLeagueAdminPromote = 6,
    LeagueAuditActionLeagueStreamAdd = 7,
    LeagueAuditActionLeagueStreamRemove = 8,
    LeagueAuditActionLeagueImageUpdated = 9,
    LeagueAuditActionLeagueMessageAdded = 10,
    LeagueAuditActionLeagueSubmitted = 11,
    LeagueAuditActionLeagueSetPrizePool = 12,
    LeagueAuditActionLeagueAddPrizePoolItem = 13,
    LeagueAuditActionLeagueRemovePrizePoolItem = 14,
    LeagueAuditActionLeagueMatchStart = 15,
    LeagueAuditActionLeagueMatchEnd = 16,
    LeagueAuditActionLeagueAddInvitedTeam = 17,
    LeagueAuditActionLeagueRemoveInvitedTeam = 18,
    LeagueAuditActionLeagueStatusChanged = 19,
    LeagueAuditActionLeagueStreamEdit = 20,
    LeagueAuditActionLeagueTeamSwap = 21,
    LeagueAuditActionNodegroupCreate = 100,
    LeagueAuditActionNodegroupDestroy = 101,
    LeagueAuditActionNodegroupAddTeam = 102,
    LeagueAuditActionNodegroupRemoveTeam = 103,
    LeagueAuditActionNodegroupSetAdvancing = 104,
    LeagueAuditActionNodegroupEdit = 105,
    LeagueAuditActionNodegroupPopulate = 106,
    LeagueAuditActionNodegroupCompleted = 107,
    LeagueAuditActionNodegroupSetSecondaryAdvancing = 108,
    LeagueAuditActionNodegroupSetTertiaryAdvancing = 109,
    LeagueAuditActionNodeCreate = 200,
    LeagueAuditActionNodeDestroy = 201,
    LeagueAuditActionNodeAutocreate = 202,
    LeagueAuditActionNodeSetTeam = 203,
    LeagueAuditActionNodeSetSeriesId = 204,
    LeagueAuditActionNodeSetAdvancing = 205,
    LeagueAuditActionNodeSetTime = 206,
    LeagueAuditActionNodeMatchCompleted = 207,
    LeagueAuditActionNodeCompleted = 208,
    LeagueAuditActionNodeEdit = 209,
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum DotaCombatlogTypes {
    DotaCombatlogInvalid = -1,
    DotaCombatlogDamage = 0,
    DotaCombatlogHeal = 1,
    DotaCombatlogModifierAdd = 2,
    DotaCombatlogModifierRemove = 3,
    DotaCombatlogDeath = 4,
    DotaCombatlogAbility = 5,
    DotaCombatlogItem = 6,
    DotaCombatlogLocation = 7,
    DotaCombatlogGold = 8,
    DotaCombatlogGameState = 9,
    DotaCombatlogXp = 10,
    DotaCombatlogPurchase = 11,
    DotaCombatlogBuyback = 12,
    DotaCombatlogAbilityTrigger = 13,
    DotaCombatlogPlayerstats = 14,
    DotaCombatlogMultikill = 15,
    DotaCombatlogKillstreak = 16,
    DotaCombatlogTeamBuildingKill = 17,
    DotaCombatlogFirstBlood = 18,
    DotaCombatlogModifierStackEvent = 19,
    DotaCombatlogNeutralCampStack = 20,
    DotaCombatlogPickupRune = 21,
    DotaCombatlogRevealedInvisible = 22,
    DotaCombatlogHeroSaved = 23,
    DotaCombatlogManaRestored = 24,
    DotaCombatlogHeroLevelup = 25,
    DotaCombatlogBottleHealAlly = 26,
    DotaCombatlogEndgameStats = 27,
    DotaCombatlogInterruptChannel = 28,
    DotaCombatlogAlliedGold = 29,
    DotaCombatlogAegisTaken = 30,
    DotaCombatlogManaDamage = 31,
    DotaCombatlogPhysicalDamagePrevented = 32,
    DotaCombatlogUnitSummoned = 33,
    DotaCombatlogAttackEvade = 34,
    DotaCombatlogTreeCut = 35,
    DotaCombatlogSuccessfulScan = 36,
    DotaCombatlogEndKillstreak = 37,
    DotaCombatlogBloodstoneCharge = 38,
    DotaCombatlogCriticalDamage = 39,
    DotaCombatlogSpellAbsorb = 40,
    DotaCombatlogUnitTeleported = 41,
    DotaCombatlogKillEaterEvent = 42,
    DotaCombatlogNeutralItemEarned = 43,
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum EdpcFavoriteType {
    FavoriteTypeAll = 0,
    FavoriteTypePlayer = 1,
    FavoriteTypeTeam = 2,
    FavoriteTypeLeague = 3,
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum EdpcPushNotification {
    DpcPushNotificationMatchStarting = 1,
    DpcPushNotificationPlayerLeftTeam = 10,
    DpcPushNotificationPlayerJoinedTeam = 11,
    DpcPushNotificationPlayerJoinedTeamAsCoach = 12,
    DpcPushNotificationPlayerLeftTeamAsCoach = 13,
    DpcPushNotificationLeagueResult = 20,
    DpcPushNotificationPredictionMatchesAvailable = 30,
    DpcPushNotificationPredictionResult = 31,
    DpcPushNotificationFantasyPlayerCleared = 40,
    DpcPushNotificationFantasyDailySummary = 41,
    DpcPushNotificationFantasyFinalResults = 42,
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum EEventActionScoreMode {
    KEEventActionScoreModeAdd = 0,
    KEEventActionScoreModeMin = 1,
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum EPlayerChallengeHistoryType {
    KEPlayerChallengeHistoryTypeInvalid = 0,
    KEPlayerChallengeHistoryTypeKillEater = 1,
    KEPlayerChallengeHistoryTypeDotaPlusRelic = 2,
    KEPlayerChallengeHistoryTypeDotaPlusHeroPlayerChallenge = 3,
    KEPlayerChallengeHistoryTypeInGameEventChallenge = 4,
    KEPlayerChallengeHistoryTypeGuildContract = 5,
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum EOverwatchReportReason {
    KEOverwatchReportReasonUnknown = 0,
    KEOverwatchReportReasonCheating = 1,
    KEOverwatchReportReasonFeeding = 2,
    KEOverwatchReportReasonGriefing = 3,
    KEOverwatchReportReasonSuspicious = 4,
    KEOverwatchReportReasonAbilityAbuse = 5,
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum ECandyShopUpgrade {
    KECandyShopUpgradeInvalid = -1,
    KECandyShopUpgradeInventorySize = 0,
    KECandyShopUpgradeRewardShelf = 1,
    KECandyShopUpgradeExtraExchangeRecipe = 2,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgAiDebugLine {
    #[prost(string, optional, tag = "1")]
    pub message: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgPing {
    #[prost(uint32, optional, tag = "2")]
    pub ping: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub loss: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgSwapVerify {
    #[prost(int32, optional, tag = "1", default = "-1")]
    pub player_id: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgChatEvent {
    #[prost(
        enumeration = "DotaChatMessage",
        required,
        tag = "1",
        default = "ChatMessageInvalid"
    )]
    pub r#type: i32,
    #[prost(uint32, optional, tag = "2")]
    pub value: ::core::option::Option<u32>,
    #[prost(sint32, optional, tag = "3", default = "-1")]
    pub playerid_1: ::core::option::Option<i32>,
    #[prost(sint32, optional, tag = "4", default = "-1")]
    pub playerid_2: ::core::option::Option<i32>,
    #[prost(sint32, optional, tag = "5", default = "-1")]
    pub playerid_3: ::core::option::Option<i32>,
    #[prost(sint32, optional, tag = "6", default = "-1")]
    pub playerid_4: ::core::option::Option<i32>,
    #[prost(sint32, optional, tag = "7", default = "-1")]
    pub playerid_5: ::core::option::Option<i32>,
    #[prost(sint32, optional, tag = "8", default = "-1")]
    pub playerid_6: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "9")]
    pub value2: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "10")]
    pub value3: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgBotChat {
    #[prost(int32, optional, tag = "1", default = "-1")]
    pub player_id: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "3")]
    pub message: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "4")]
    pub target: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "5")]
    pub team_only: ::core::option::Option<bool>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgCombatHeroPositions {
    #[prost(uint32, optional, tag = "1")]
    pub index: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "2")]
    pub time: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "3")]
    pub world_pos: ::core::option::Option<CMsgVector2D>,
    #[prost(int32, optional, tag = "4")]
    pub health: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgCombatLogBulkData {
    #[prost(message, repeated, tag = "1")]
    pub combat_entries: ::prost::alloc::vec::Vec<CMsgDotaCombatLogEntry>,
    #[prost(float, optional, tag = "2")]
    pub timestamp: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "3")]
    pub duration: ::core::option::Option<f32>,
    #[prost(int32, optional, tag = "4", default = "-1")]
    pub player_id: ::core::option::Option<i32>,
    #[prost(float, optional, tag = "5")]
    pub request_time: ::core::option::Option<f32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgProjectileParticleCpData {
    #[prost(int32, optional, tag = "1")]
    pub control_point: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "2")]
    pub vector: ::core::option::Option<CMsgVector>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgUpdateLinearProjectileCpData {
    #[prost(int32, optional, tag = "1")]
    pub handle: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub control_point: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "3")]
    pub vector: ::core::option::Option<CMsgVector>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgMiniKillCamInfo {
    #[prost(message, repeated, tag = "1")]
    pub attackers: ::prost::alloc::vec::Vec<cdota_user_msg_mini_kill_cam_info::Attacker>,
}
/// Nested message and enum types in `CDOTAUserMsg_MiniKillCamInfo`.
pub mod cdota_user_msg_mini_kill_cam_info {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Attacker {
        #[prost(uint32, optional, tag = "1", default = "16777215")]
        pub attacker: ::core::option::Option<u32>,
        #[prost(int32, optional, tag = "2")]
        pub total_damage: ::core::option::Option<i32>,
        #[prost(message, repeated, tag = "3")]
        pub abilities: ::prost::alloc::vec::Vec<attacker::Ability>,
        #[prost(string, optional, tag = "4")]
        pub attacker_name: ::core::option::Option<::prost::alloc::string::String>,
    }
    /// Nested message and enum types in `Attacker`.
    pub mod attacker {
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct Ability {
            #[prost(int32, optional, tag = "1", default = "-1")]
            pub ability_id: ::core::option::Option<i32>,
            #[prost(int32, optional, tag = "2")]
            pub damage: ::core::option::Option<i32>,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgGlobalLightColor {
    #[prost(uint32, optional, tag = "1")]
    pub color: ::core::option::Option<u32>,
    #[prost(float, optional, tag = "2")]
    pub duration: ::core::option::Option<f32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgGlobalLightDirection {
    #[prost(message, optional, tag = "1")]
    pub direction: ::core::option::Option<CMsgVector>,
    #[prost(float, optional, tag = "2")]
    pub duration: ::core::option::Option<f32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgLocationPing {
    #[prost(int32, optional, tag = "1", default = "-1")]
    pub player_id: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "2")]
    pub location_ping: ::core::option::Option<CDotaMsgLocationPing>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgPingConfirmation {
    #[prost(int32, optional, tag = "1", default = "-1")]
    pub player_id_of_original_pinger: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "2")]
    pub entity_index: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub icon_type: ::core::option::Option<u32>,
    #[prost(message, optional, tag = "4")]
    pub location: ::core::option::Option<CMsgVector>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgItemAlert {
    #[prost(int32, optional, tag = "1", default = "-1")]
    pub player_id: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "2")]
    pub item_alert: ::core::option::Option<CDotaMsgItemAlert>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgEnemyItemAlert {
    #[prost(int32, optional, tag = "1", default = "-1")]
    pub player_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2", default = "-1")]
    pub target_player_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3", default = "-1")]
    pub item_ability_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "4", default = "-1")]
    pub rune_type: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "5")]
    pub entity_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "6", default = "-1")]
    pub item_level: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "7", default = "-1")]
    pub primary_charges: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "8", default = "-1")]
    pub secondary_charges: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgModifierAlert {
    #[prost(int32, optional, tag = "1", default = "-1")]
    pub player_id: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "2")]
    pub class_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "3")]
    pub stack_count: ::core::option::Option<u32>,
    #[prost(bool, optional, tag = "4")]
    pub is_debuff: ::core::option::Option<bool>,
    #[prost(int32, optional, tag = "5", default = "-1")]
    pub target_entindex: ::core::option::Option<i32>,
    #[prost(float, optional, tag = "6")]
    pub seconds_remaining: ::core::option::Option<f32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgHpManaAlert {
    #[prost(int32, optional, tag = "1", default = "-1")]
    pub player_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2", default = "-1")]
    pub target_entindex: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "3")]
    pub show_raw_values: ::core::option::Option<bool>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgNeutralCampAlert {
    #[prost(int32, optional, tag = "1", default = "-1")]
    pub player_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2", default = "-1")]
    pub spawner_entindex: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3", default = "-1")]
    pub unit_entindex: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "4")]
    pub stack_count: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "5")]
    pub camp_type: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "6")]
    pub stack_request: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "7")]
    pub stack_intention: ::core::option::Option<bool>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgGlyphAlert {
    #[prost(int32, optional, tag = "1", default = "-1")]
    pub player_id: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "2")]
    pub negative: ::core::option::Option<bool>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgRadarAlert {
    #[prost(int32, optional, tag = "1", default = "-1")]
    pub player_id: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "2")]
    pub negative: ::core::option::Option<bool>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgWillPurchaseAlert {
    #[prost(int32, optional, tag = "1", default = "-1")]
    pub item_ability_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2", default = "-1")]
    pub player_id: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "3")]
    pub gold_remaining: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "4", default = "-1")]
    pub suggestion_player_id: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgEmptyTeleportAlert {
    #[prost(int32, optional, tag = "1", default = "-1")]
    pub source_player_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2", default = "-1")]
    pub target_player_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub cooldown_seconds: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgMarsArenaOfBloodAttack {
    #[prost(uint32, optional, tag = "1", default = "16777215")]
    pub source_ehandle: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2", default = "16777215")]
    pub target_ehandle: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "3")]
    pub warrior_index: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CDotaEntityMsgInvokerSpellCast {
    #[prost(message, optional, tag = "1")]
    pub entity_msg: ::core::option::Option<CEntityMsg>,
    #[prost(int32, optional, tag = "2")]
    pub cast_activity: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgBuyBackStateAlert {
    #[prost(int32, optional, tag = "1", default = "-1")]
    pub player_id: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgQuickBuyAlert {
    #[prost(int32, optional, tag = "1", default = "-1")]
    pub player_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2", default = "-1")]
    pub item_ability_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub gold_cost: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "4")]
    pub item_cooldown_seconds: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "5")]
    pub show_buyback: ::core::option::Option<bool>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgCourierKilledAlert {
    #[prost(uint32, optional, tag = "1")]
    pub team: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub gold_value: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3", default = "16777215")]
    pub entity_handle: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "4")]
    pub timestamp: ::core::option::Option<i32>,
    #[prost(message, repeated, tag = "5")]
    pub lost_items: ::prost::alloc::vec::Vec<cdota_user_msg_courier_killed_alert::LostItem>,
    #[prost(int32, optional, tag = "6", default = "-1")]
    pub killer_player_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "7", default = "-1")]
    pub owning_player_id: ::core::option::Option<i32>,
}
/// Nested message and enum types in `CDOTAUserMsg_CourierKilledAlert`.
pub mod cdota_user_msg_courier_killed_alert {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct LostItem {
        #[prost(int32, optional, tag = "1", default = "-1")]
        pub item_ability_id: ::core::option::Option<i32>,
        #[prost(uint32, optional, tag = "2")]
        pub quantity: ::core::option::Option<u32>,
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgMinimapEvent {
    #[prost(int32, optional, tag = "1")]
    pub event_type: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "2", default = "16777215")]
    pub entity_handle: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "3")]
    pub x: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "4")]
    pub y: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "5")]
    pub duration: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "6", default = "16777215")]
    pub target_entity_handle: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgMapLine {
    #[prost(int32, optional, tag = "1", default = "-1")]
    pub player_id: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "2")]
    pub mapline: ::core::option::Option<CDotaMsgMapLine>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgMinimapDebugPoint {
    #[prost(message, optional, tag = "1")]
    pub location: ::core::option::Option<CMsgVector>,
    #[prost(uint32, optional, tag = "2")]
    pub color: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "3")]
    pub size: ::core::option::Option<i32>,
    #[prost(float, optional, tag = "4")]
    pub duration: ::core::option::Option<f32>,
    #[prost(int32, optional, tag = "5")]
    pub index: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgCreateLinearProjectile {
    #[prost(message, optional, tag = "1")]
    pub origin: ::core::option::Option<CMsgVector>,
    #[prost(message, optional, tag = "2")]
    pub velocity: ::core::option::Option<CMsgVector2D>,
    #[prost(int32, optional, tag = "4", default = "-1")]
    pub entindex: ::core::option::Option<i32>,
    #[prost(uint64, optional, tag = "5")]
    pub particle_index: ::core::option::Option<u64>,
    #[prost(int32, optional, tag = "6")]
    pub handle: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "7")]
    pub acceleration: ::core::option::Option<CMsgVector2D>,
    #[prost(float, optional, tag = "8")]
    pub max_speed: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "9")]
    pub fow_radius: ::core::option::Option<f32>,
    #[prost(bool, optional, tag = "10")]
    pub sticky_fow_reveal: ::core::option::Option<bool>,
    #[prost(float, optional, tag = "11")]
    pub distance: ::core::option::Option<f32>,
    #[prost(fixed32, optional, tag = "12")]
    pub colorgemcolor: ::core::option::Option<u32>,
    #[prost(message, repeated, tag = "13")]
    pub particle_cp_data: ::prost::alloc::vec::Vec<CDotaUserMsgProjectileParticleCpData>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgDestroyLinearProjectile {
    #[prost(int32, optional, tag = "1")]
    pub handle: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgDodgeTrackingProjectiles {
    #[prost(int32, required, tag = "1", default = "-1")]
    pub entindex: i32,
    #[prost(bool, optional, tag = "2")]
    pub attacks_only: ::core::option::Option<bool>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgSpectatorPlayerClick {
    #[prost(int32, required, tag = "1", default = "-1")]
    pub entindex: i32,
    #[prost(int32, optional, tag = "2")]
    pub order_type: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3", default = "0")]
    pub target_index: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgSpectatorPlayerUnitOrders {
    #[prost(int32, optional, tag = "1", default = "-1")]
    pub entindex: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub order_type: ::core::option::Option<i32>,
    #[prost(int32, repeated, packed = "false", tag = "3")]
    pub units: ::prost::alloc::vec::Vec<i32>,
    #[prost(int32, optional, tag = "4", default = "0")]
    pub target_index: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "5", default = "-1")]
    pub ability_id: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "6")]
    pub position: ::core::option::Option<CMsgVector>,
    #[prost(bool, optional, tag = "7")]
    pub queue: ::core::option::Option<bool>,
    #[prost(int32, optional, tag = "8")]
    pub sequence_number: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "9")]
    pub flags: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgNevermoreRequiem {
    #[prost(uint32, optional, tag = "1", default = "16777215")]
    pub entity_handle: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "2")]
    pub lines: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "3")]
    pub origin: ::core::option::Option<CMsgVector>,
    #[prost(bool, optional, tag = "4")]
    pub reverse: ::core::option::Option<bool>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgInvalidCommand {
    #[prost(string, optional, tag = "1")]
    pub message: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "2")]
    pub sequence_number: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgHudError {
    #[prost(int32, optional, tag = "1")]
    pub order_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub sequence_number: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgSharedCooldown {
    #[prost(int32, optional, tag = "1", default = "-1")]
    pub entindex: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "2")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(float, optional, tag = "3")]
    pub cooldown: ::core::option::Option<f32>,
    #[prost(int32, optional, tag = "4")]
    pub name_index: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgSetNextAutobuyItem {
    #[prost(string, optional, tag = "1")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgHalloweenDrops {
    #[prost(uint32, repeated, packed = "false", tag = "1")]
    pub item_defs: ::prost::alloc::vec::Vec<u32>,
    #[prost(int32, repeated, packed = "false", tag = "2")]
    pub player_ids: ::prost::alloc::vec::Vec<i32>,
    #[prost(uint32, optional, tag = "3")]
    pub prize_list: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgPredictionResult {
    #[prost(uint32, optional, tag = "1")]
    pub account_id: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "2")]
    pub match_id: ::core::option::Option<u64>,
    #[prost(bool, optional, tag = "3")]
    pub correct: ::core::option::Option<bool>,
    #[prost(message, repeated, tag = "4")]
    pub predictions: ::prost::alloc::vec::Vec<cdota_user_msg_prediction_result::Prediction>,
}
/// Nested message and enum types in `CDOTAUserMsg_PredictionResult`.
pub mod cdota_user_msg_prediction_result {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Prediction {
        #[prost(uint32, optional, tag = "1")]
        pub item_def: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "2")]
        pub num_correct: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "3")]
        pub num_fails: ::core::option::Option<u32>,
        #[prost(
            enumeration = "prediction::EResult",
            optional,
            tag = "4",
            default = "KEResultItemGranted"
        )]
        pub result: ::core::option::Option<i32>,
        #[prost(uint32, repeated, packed = "false", tag = "6")]
        pub granted_item_defs: ::prost::alloc::vec::Vec<u32>,
    }
    /// Nested message and enum types in `Prediction`.
    pub mod prediction {
        #[derive(
            serde::Serialize,
            serde::Deserialize,
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration,
        )]
        #[repr(i32)]
        pub enum EResult {
            KEResultItemGranted = 1,
            KEResultDestroyed = 2,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDotaResponseQuerySerialized {
    #[prost(message, repeated, tag = "1")]
    pub facts: ::prost::alloc::vec::Vec<cdota_response_query_serialized::Fact>,
}
/// Nested message and enum types in `CDOTAResponseQuerySerialized`.
pub mod cdota_response_query_serialized {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Fact {
        #[prost(int32, required, tag = "1")]
        pub key: i32,
        #[prost(
            enumeration = "fact::ValueType",
            required,
            tag = "2",
            default = "Numeric"
        )]
        pub valtype: i32,
        #[prost(float, optional, tag = "3")]
        pub val_numeric: ::core::option::Option<f32>,
        #[prost(string, optional, tag = "4")]
        pub val_string: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(int32, optional, tag = "5")]
        pub val_stringtable_index: ::core::option::Option<i32>,
        #[prost(sint32, optional, tag = "6")]
        pub val_int_numeric: ::core::option::Option<i32>,
    }
    /// Nested message and enum types in `Fact`.
    pub mod fact {
        #[derive(
            serde::Serialize,
            serde::Deserialize,
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration,
        )]
        #[repr(i32)]
        pub enum ValueType {
            Numeric = 1,
            String = 2,
            StringtableIndex = 3,
            IntNumeric = 4,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDotaSpeechMatchOnClient {
    #[prost(int32, optional, tag = "1")]
    pub speech_concept: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub recipient_type: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "3")]
    pub responsequery: ::core::option::Option<CDotaResponseQuerySerialized>,
    #[prost(sfixed32, optional, tag = "4", default = "0")]
    pub randomseed: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgUnitEvent {
    #[prost(
        enumeration = "EDotaEntityMessages",
        required,
        tag = "1",
        default = "DotaUnitSpeech"
    )]
    pub msg_type: i32,
    #[prost(int32, required, tag = "2")]
    pub entity_index: i32,
    #[prost(message, optional, tag = "3")]
    pub speech: ::core::option::Option<cdota_user_msg_unit_event::Speech>,
    #[prost(message, optional, tag = "4")]
    pub speech_mute: ::core::option::Option<cdota_user_msg_unit_event::SpeechMute>,
    #[prost(message, optional, tag = "5")]
    pub add_gesture: ::core::option::Option<cdota_user_msg_unit_event::AddGesture>,
    #[prost(message, optional, tag = "6")]
    pub remove_gesture: ::core::option::Option<cdota_user_msg_unit_event::RemoveGesture>,
    #[prost(message, optional, tag = "7")]
    pub blood_impact: ::core::option::Option<cdota_user_msg_unit_event::BloodImpact>,
    #[prost(message, optional, tag = "8")]
    pub fade_gesture: ::core::option::Option<cdota_user_msg_unit_event::FadeGesture>,
    #[prost(message, optional, tag = "9")]
    pub speech_match_on_client: ::core::option::Option<CDotaSpeechMatchOnClient>,
}
/// Nested message and enum types in `CDOTAUserMsg_UnitEvent`.
pub mod cdota_user_msg_unit_event {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Interval {
        #[prost(float, optional, tag = "1")]
        pub start: ::core::option::Option<f32>,
        #[prost(float, optional, tag = "2")]
        pub range: ::core::option::Option<f32>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Speech {
        #[prost(int32, optional, tag = "1")]
        pub speech_concept: ::core::option::Option<i32>,
        #[prost(string, optional, tag = "2")]
        pub response: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(int32, optional, tag = "3")]
        pub recipient_type: ::core::option::Option<i32>,
        #[prost(bool, optional, tag = "5", default = "false")]
        pub muteable: ::core::option::Option<bool>,
        #[prost(message, optional, tag = "6")]
        pub predelay: ::core::option::Option<Interval>,
        #[prost(uint32, optional, tag = "7")]
        pub flags: ::core::option::Option<u32>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct SpeechMute {
        #[prost(float, optional, tag = "1", default = "0.5")]
        pub delay: ::core::option::Option<f32>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct AddGesture {
        #[prost(int32, optional, tag = "1")]
        pub activity: ::core::option::Option<i32>,
        #[prost(int32, optional, tag = "2")]
        pub slot: ::core::option::Option<i32>,
        #[prost(float, optional, tag = "3", default = "0")]
        pub fade_in: ::core::option::Option<f32>,
        #[prost(float, optional, tag = "4", default = "0.1")]
        pub fade_out: ::core::option::Option<f32>,
        #[prost(float, optional, tag = "5", default = "1")]
        pub playback_rate: ::core::option::Option<f32>,
        #[prost(int32, optional, tag = "6")]
        pub sequence_variant: ::core::option::Option<i32>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct RemoveGesture {
        #[prost(int32, optional, tag = "1")]
        pub activity: ::core::option::Option<i32>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct BloodImpact {
        #[prost(int32, optional, tag = "1")]
        pub scale: ::core::option::Option<i32>,
        #[prost(int32, optional, tag = "2")]
        pub x_normal: ::core::option::Option<i32>,
        #[prost(int32, optional, tag = "3")]
        pub y_normal: ::core::option::Option<i32>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct FadeGesture {
        #[prost(int32, optional, tag = "1")]
        pub activity: ::core::option::Option<i32>,
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgItemPurchased {
    #[prost(int32, optional, tag = "1", default = "-1")]
    pub item_ability_id: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgItemSold {
    #[prost(int32, optional, tag = "1", default = "-1")]
    pub item_ability_id: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgItemFound {
    #[prost(int32, optional, tag = "1", default = "-1")]
    pub player: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub quality: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub rarity: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "4")]
    pub method: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "5")]
    pub itemdef: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgOverheadEvent {
    #[prost(
        enumeration = "DotaOverheadAlert",
        required,
        tag = "1",
        default = "OverheadAlertGold"
    )]
    pub message_type: i32,
    #[prost(int32, optional, tag = "2")]
    pub value: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3", default = "-1")]
    pub target_player_entindex: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "4", default = "-1")]
    pub target_entindex: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "5", default = "-1")]
    pub source_player_entindex: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgTutorialTipInfo {
    #[prost(string, optional, tag = "1")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "2")]
    pub progress: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgTutorialFinish {
    #[prost(string, optional, tag = "1")]
    pub heading: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "2")]
    pub emblem: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3")]
    pub body: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "4")]
    pub success: ::core::option::Option<bool>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgTutorialMinimapPosition {}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgSendGenericToolTip {
    #[prost(string, optional, tag = "1")]
    pub title: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "2")]
    pub text: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "3")]
    pub entindex: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "4")]
    pub close: ::core::option::Option<bool>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgWorldLine {
    #[prost(int32, optional, tag = "1", default = "-1")]
    pub player_id: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "2")]
    pub worldline: ::core::option::Option<CDotaMsgWorldLine>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgChatWheel {
    #[prost(uint32, optional, tag = "1", default = "4294967295")]
    pub chat_message_id: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "2", default = "-1")]
    pub player_id: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "3")]
    pub account_id: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub param_hero_id: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "5")]
    pub emoticon_id: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgReceivedXmasGift {
    #[prost(int32, optional, tag = "1", default = "-1")]
    pub player_id: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "2")]
    pub item_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "3")]
    pub inventory_slot: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgShowSurvey {
    #[prost(int32, optional, tag = "1")]
    pub survey_id: ::core::option::Option<i32>,
    #[prost(uint64, optional, tag = "2")]
    pub match_id: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "3")]
    pub response_style: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "4")]
    pub teammate_hero_id: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "5")]
    pub teammate_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "6")]
    pub teammate_account_id: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgUpdateSharedContent {
    #[prost(int32, optional, tag = "1")]
    pub slot_type: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgTutorialRequestExp {}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgTutorialFade {
    #[prost(int32, optional, tag = "1")]
    pub tgt_alpha: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgTutorialPingMinimap {
    #[prost(int32, optional, tag = "1", default = "-1")]
    pub player_id: ::core::option::Option<i32>,
    #[prost(float, optional, tag = "2")]
    pub pos_x: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "3")]
    pub pos_y: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "4")]
    pub pos_z: ::core::option::Option<f32>,
    #[prost(int32, optional, tag = "5")]
    pub entity_index: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgGamerulesStateChanged {
    #[prost(uint32, optional, tag = "1")]
    pub state: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgAddQuestLogEntry {
    #[prost(string, optional, tag = "1")]
    pub npc_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "2")]
    pub npc_dialog: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgSendStatPopup {
    #[prost(int32, optional, tag = "1", default = "-1")]
    pub player_id: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "2")]
    pub statpopup: ::core::option::Option<CDotaMsgSendStatPopup>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgDismissAllStatPopups {
    #[prost(message, optional, tag = "1")]
    pub dismissallmsg: ::core::option::Option<CDotaMsgDismissAllStatPopups>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgSendRoshanSpectatorPhase {
    #[prost(
        enumeration = "DotaRoshanPhase",
        optional,
        tag = "1",
        default = "KSrspRoshanAlive"
    )]
    pub phase: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub phase_start_time: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub phase_length: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgSendRoshanPopup {
    #[prost(bool, optional, tag = "1")]
    pub reclaimed: ::core::option::Option<bool>,
    #[prost(int32, optional, tag = "2")]
    pub gametime: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgSendFinalGold {
    #[prost(uint32, repeated, packed = "false", tag = "1")]
    pub reliable_gold: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, packed = "false", tag = "2")]
    pub unreliable_gold: ::prost::alloc::vec::Vec<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgCustomMsg {
    #[prost(string, optional, tag = "1")]
    pub message: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "2", default = "-1")]
    pub player_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub value: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgCoachHudPing {
    #[prost(int32, optional, tag = "1", default = "-1")]
    pub player_id: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "2")]
    pub hud_ping: ::core::option::Option<CDotaMsgCoachHudPing>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgClientLoadGridNav {}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgTeProjectile {
    #[prost(uint32, optional, tag = "1", default = "16777215")]
    pub source: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2", default = "16777215")]
    pub target: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "3")]
    pub move_speed: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "4")]
    pub source_attachment: ::core::option::Option<i32>,
    #[prost(int64, optional, tag = "5")]
    pub particle_system_handle: ::core::option::Option<i64>,
    #[prost(bool, optional, tag = "6")]
    pub dodgeable: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "7")]
    pub is_attack: ::core::option::Option<bool>,
    #[prost(float, optional, tag = "9")]
    pub expire_time: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "10")]
    pub maximpacttime: ::core::option::Option<f32>,
    #[prost(fixed32, optional, tag = "11")]
    pub colorgemcolor: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "12")]
    pub launch_tick: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "13")]
    pub handle: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "14")]
    pub target_loc: ::core::option::Option<CMsgVector>,
    #[prost(message, repeated, tag = "15")]
    pub particle_cp_data: ::prost::alloc::vec::Vec<CDotaUserMsgProjectileParticleCpData>,
    #[prost(int64, optional, tag = "16")]
    pub additional_particle_system_handle: ::core::option::Option<i64>,
    #[prost(int32, optional, tag = "17")]
    pub original_move_speed: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "18", default = "16777215")]
    pub ability: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgTeProjectileLoc {
    #[prost(message, optional, tag = "1")]
    pub source_loc: ::core::option::Option<CMsgVector>,
    #[prost(uint32, optional, tag = "2", default = "16777215")]
    pub target: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "3")]
    pub move_speed: ::core::option::Option<i32>,
    #[prost(int64, optional, tag = "4")]
    pub particle_system_handle: ::core::option::Option<i64>,
    #[prost(bool, optional, tag = "5")]
    pub dodgeable: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "6")]
    pub is_attack: ::core::option::Option<bool>,
    #[prost(float, optional, tag = "9")]
    pub expire_time: ::core::option::Option<f32>,
    #[prost(message, optional, tag = "10")]
    pub target_loc: ::core::option::Option<CMsgVector>,
    #[prost(fixed32, optional, tag = "11")]
    pub colorgemcolor: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "12")]
    pub launch_tick: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "13")]
    pub handle: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "14", default = "16777215")]
    pub source: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "15")]
    pub source_attachment: ::core::option::Option<i32>,
    #[prost(message, repeated, tag = "16")]
    pub particle_cp_data: ::prost::alloc::vec::Vec<CDotaUserMsgProjectileParticleCpData>,
    #[prost(int64, optional, tag = "17")]
    pub additional_particle_system_handle: ::core::option::Option<i64>,
    #[prost(int32, optional, tag = "18")]
    pub original_move_speed: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgTeDestroyProjectile {
    #[prost(int32, optional, tag = "1")]
    pub handle: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgTeDotaBloodImpact {
    #[prost(uint32, optional, tag = "1", default = "16777215")]
    pub entity: ::core::option::Option<u32>,
    #[prost(float, optional, tag = "2")]
    pub scale: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "3")]
    pub xnormal: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "4")]
    pub ynormal: ::core::option::Option<f32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgAbilityPing {
    #[prost(int32, optional, tag = "1", default = "-1")]
    pub player_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2", default = "-1")]
    pub ability_id: ::core::option::Option<i32>,
    #[prost(
        enumeration = "DotaAbilityPingType",
        optional,
        tag = "3",
        default = "AbilityPingReady"
    )]
    pub r#type: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "4")]
    pub cooldown_seconds: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "5")]
    pub level: ::core::option::Option<u32>,
    #[prost(bool, optional, tag = "6")]
    pub passive: ::core::option::Option<bool>,
    #[prost(uint32, optional, tag = "7")]
    pub mana_needed: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "8")]
    pub entity_id: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "9")]
    pub primary_charges: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "10")]
    pub secondary_charges: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "12")]
    pub ctrl_held: ::core::option::Option<bool>,
    #[prost(float, optional, tag = "13")]
    pub reclaim_time: ::core::option::Option<f32>,
    #[prost(int32, optional, tag = "14", default = "-1")]
    pub owner_entity: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgTeUnitAnimation {
    #[prost(uint32, optional, tag = "1", default = "16777215")]
    pub entity: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "2")]
    pub sequence_variant: ::core::option::Option<i32>,
    #[prost(float, optional, tag = "3")]
    pub playbackrate: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "4")]
    pub castpoint: ::core::option::Option<f32>,
    #[prost(int32, optional, tag = "5")]
    pub r#type: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "6")]
    pub activity: ::core::option::Option<i32>,
    #[prost(float, optional, tag = "7")]
    pub lag_compensation_time: ::core::option::Option<f32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgTeUnitAnimationEnd {
    #[prost(uint32, optional, tag = "1", default = "16777215")]
    pub entity: ::core::option::Option<u32>,
    #[prost(bool, optional, tag = "2")]
    pub snap: ::core::option::Option<bool>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgShowGenericPopup {
    #[prost(string, required, tag = "1")]
    pub header: ::prost::alloc::string::String,
    #[prost(string, required, tag = "2")]
    pub body: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "3")]
    pub param1: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "4")]
    pub param2: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "5")]
    pub tint_screen: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "6")]
    pub show_no_other_dialogs: ::core::option::Option<bool>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgVoteStart {
    #[prost(string, optional, tag = "1")]
    pub title: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(float, optional, tag = "2")]
    pub duration: ::core::option::Option<f32>,
    #[prost(int32, optional, tag = "3")]
    pub choice_count: ::core::option::Option<i32>,
    #[prost(string, repeated, tag = "4")]
    pub choices: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgVoteUpdate {
    #[prost(int32, repeated, packed = "false", tag = "1")]
    pub choice_counts: ::prost::alloc::vec::Vec<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgVoteEnd {
    #[prost(int32, optional, tag = "1")]
    pub selected_choice: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgBoosterStatePlayer {
    #[prost(int32, optional, tag = "1", default = "-1")]
    pub player_id: ::core::option::Option<i32>,
    #[prost(float, optional, tag = "2")]
    pub bonus: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "3")]
    pub event_bonus: ::core::option::Option<f32>,
    #[prost(uint32, optional, tag = "4")]
    pub bonus_item_id: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "5")]
    pub event_bonus_item_id: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgBoosterState {
    #[prost(message, repeated, tag = "1")]
    pub boosted_players: ::prost::alloc::vec::Vec<CDotaUserMsgBoosterStatePlayer>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgPlayerMmr {
    #[prost(sint32, repeated, tag = "1")]
    pub mmr: ::prost::alloc::vec::Vec<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgAbilitySteal {
    #[prost(int32, optional, tag = "1", default = "-1")]
    pub player_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2", default = "-1")]
    pub ability_id: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "3")]
    pub ability_level: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgStatsHeroLookup {
    #[prost(int32, optional, tag = "1", default = "-1")]
    pub player_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub hero_id: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "3")]
    pub hero_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "4")]
    pub persona: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgStatsHeroPositionInfo {
    #[prost(float, optional, tag = "1")]
    pub average_position: ::core::option::Option<f32>,
    #[prost(message, repeated, tag = "2")]
    pub position_details:
        ::prost::alloc::vec::Vec<cdota_user_msg_stats_hero_position_info::PositionPair>,
}
/// Nested message and enum types in `CDOTAUserMsg_StatsHeroPositionInfo`.
pub mod cdota_user_msg_stats_hero_position_info {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct PositionPair {
        #[prost(
            enumeration = "super::DotaPositionCategory",
            optional,
            tag = "1",
            default = "DotaPositionNone"
        )]
        pub position_category: ::core::option::Option<i32>,
        #[prost(uint32, optional, tag = "2")]
        pub position_count: ::core::option::Option<u32>,
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgStatsHeroMinuteDetails {
    #[prost(uint32, optional, tag = "1")]
    pub last_hits: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub hero_kills: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub hero_damage: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub tower_damage: ::core::option::Option<u32>,
    #[prost(message, optional, tag = "5")]
    pub position_info: ::core::option::Option<CDotaUserMsgStatsHeroPositionInfo>,
    #[prost(uint32, optional, tag = "6")]
    pub total_xp: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "7")]
    pub net_worth: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "8")]
    pub harvested_creep_gold: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "9")]
    pub claimed_farm: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "10")]
    pub wards_placed: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "11")]
    pub runes_collected: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "12")]
    pub tps_used: ::core::option::Option<u32>,
    #[prost(uint32, repeated, packed = "false", tag = "13")]
    pub mana_spent: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, packed = "false", tag = "14")]
    pub damage_absorbed: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, packed = "false", tag = "15")]
    pub damage_done: ::prost::alloc::vec::Vec<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgStatsTeamMinuteDetails {
    #[prost(message, repeated, tag = "1")]
    pub player_stats: ::prost::alloc::vec::Vec<CDotaUserMsgStatsHeroMinuteDetails>,
    #[prost(uint32, optional, tag = "2")]
    pub tower_kills: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub barrack_kills: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub available_lane_creep_gold: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "5")]
    pub balance_kill_value: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "6")]
    pub balance_tower_value: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "7")]
    pub balance_barracks_value: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "8")]
    pub balance_gold_value: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "9")]
    pub balance_xp_value: ::core::option::Option<u32>,
    #[prost(message, repeated, tag = "10")]
    pub lane_performance:
        ::prost::alloc::vec::Vec<cdota_user_msg_stats_team_minute_details::LocationPerformance>,
}
/// Nested message and enum types in `CDOTAUserMsg_StatsTeamMinuteDetails`.
pub mod cdota_user_msg_stats_team_minute_details {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct LocationPerformance {
        #[prost(uint32, optional, tag = "1")]
        pub location_category: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "2")]
        pub stat_type: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "3")]
        pub value: ::core::option::Option<u32>,
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgStatsPlayerKillShare {
    #[prost(int32, optional, tag = "1", default = "-1")]
    pub player_id: ::core::option::Option<i32>,
    #[prost(float, optional, tag = "2")]
    pub kill_share_percent: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "3")]
    pub player_loc_x: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "4")]
    pub player_loc_y: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "5")]
    pub health_percent: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "6")]
    pub mana_percent: ::core::option::Option<f32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgStatsKillDetails {
    #[prost(int32, optional, tag = "1", default = "-1")]
    pub victim_id: ::core::option::Option<i32>,
    #[prost(message, repeated, tag = "2")]
    pub kill_shares: ::prost::alloc::vec::Vec<CDotaUserMsgStatsPlayerKillShare>,
    #[prost(uint32, optional, tag = "3")]
    pub damage_to_kill: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub effective_health: ::core::option::Option<u32>,
    #[prost(float, optional, tag = "5")]
    pub death_time: ::core::option::Option<f32>,
    #[prost(int32, optional, tag = "6", default = "-1")]
    pub killer_id: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgStatsMatchDetails {
    #[prost(message, repeated, tag = "1")]
    pub hero_lookup: ::prost::alloc::vec::Vec<CDotaUserMsgStatsHeroLookup>,
    #[prost(message, repeated, tag = "2")]
    pub radiant_stats: ::prost::alloc::vec::Vec<CDotaUserMsgStatsTeamMinuteDetails>,
    #[prost(message, repeated, tag = "3")]
    pub dire_stats: ::prost::alloc::vec::Vec<CDotaUserMsgStatsTeamMinuteDetails>,
    #[prost(message, repeated, tag = "4")]
    pub radiant_kills: ::prost::alloc::vec::Vec<CDotaUserMsgStatsKillDetails>,
    #[prost(message, repeated, tag = "5")]
    pub dire_kills: ::prost::alloc::vec::Vec<CDotaUserMsgStatsKillDetails>,
    #[prost(message, repeated, tag = "6")]
    pub fight_details:
        ::prost::alloc::vec::Vec<cdota_user_msg_stats_match_details::CDotaUserMsgStatsFightDetails>,
}
/// Nested message and enum types in `CDOTAUserMsg_StatsMatchDetails`.
pub mod cdota_user_msg_stats_match_details {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CDotaUserMsgStatsFightTeamDetails {
        #[prost(int32, repeated, packed = "false", tag = "1")]
        pub participants: ::prost::alloc::vec::Vec<i32>,
        #[prost(int32, repeated, packed = "false", tag = "2")]
        pub deaths: ::prost::alloc::vec::Vec<i32>,
        #[prost(uint32, optional, tag = "3")]
        pub gold_delta: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "4")]
        pub xp_delta: ::core::option::Option<u32>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CDotaUserMsgStatsFightDetails {
        #[prost(float, optional, tag = "1")]
        pub start_time: ::core::option::Option<f32>,
        #[prost(float, optional, tag = "2")]
        pub end_time: ::core::option::Option<f32>,
        #[prost(message, optional, tag = "3")]
        pub radiant_fight_details: ::core::option::Option<CDotaUserMsgStatsFightTeamDetails>,
        #[prost(message, optional, tag = "4")]
        pub dire_fight_details: ::core::option::Option<CDotaUserMsgStatsFightTeamDetails>,
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgMiniTaunt {
    #[prost(int32, optional, tag = "1", default = "-1")]
    pub taunting_player_id: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgSpeechBubble {
    #[prost(bool, optional, tag = "1")]
    pub destroy_all: ::core::option::Option<bool>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgCustomHeaderMessage {
    #[prost(int32, optional, tag = "1", default = "-1")]
    pub player_id: ::core::option::Option<i32>,
    #[prost(float, optional, tag = "2")]
    pub duration: ::core::option::Option<f32>,
    #[prost(string, optional, tag = "3")]
    pub message: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "4")]
    pub value: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgHeroAbilityStat {
    #[prost(
        enumeration = "EHeroStatType",
        optional,
        tag = "1",
        default = "KEHeroStatTypeNone"
    )]
    pub stat_type: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub int_value: ::core::option::Option<i32>,
    #[prost(float, optional, tag = "3")]
    pub float_value: ::core::option::Option<f32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgCombatAnalyzerPlayerStat {
    #[prost(uint32, optional, tag = "1")]
    pub account_id: ::core::option::Option<u32>,
    #[prost(message, repeated, tag = "2")]
    pub hero_ability_stats: ::prost::alloc::vec::Vec<CMsgHeroAbilityStat>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgCombatAnalyzerStats {
    #[prost(uint64, optional, tag = "1")]
    pub match_id: ::core::option::Option<u64>,
    #[prost(message, repeated, tag = "2")]
    pub player_stats: ::prost::alloc::vec::Vec<CMsgCombatAnalyzerPlayerStat>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgBeastChat {
    #[prost(uint32, optional, tag = "1")]
    pub team: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "2")]
    pub format: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3")]
    pub message: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "4")]
    pub target: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgCustomHudElementCreate {
    #[prost(string, optional, tag = "1")]
    pub element_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "2")]
    pub layout_filename: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bytes = "vec", optional, tag = "3")]
    pub data: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgCustomHudElementModify {
    #[prost(string, optional, tag = "1")]
    pub element_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "2")]
    pub modify_visible: ::core::option::Option<bool>,
    #[prost(bytes = "vec", optional, tag = "3")]
    pub data: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgCustomHudElementDestroy {
    #[prost(string, optional, tag = "1")]
    pub element_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgCompendiumStatePlayer {
    #[prost(int32, optional, tag = "1", default = "-1")]
    pub player_id: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "2")]
    pub level: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgCompendiumState {
    #[prost(message, repeated, tag = "1")]
    pub compendium_players: ::prost::alloc::vec::Vec<CDotaUserMsgCompendiumStatePlayer>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgProjectionAbility {
    #[prost(int32, optional, tag = "1", default = "-1")]
    pub ability_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2", default = "-1")]
    pub caster_ent_index: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub caster_team: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "4")]
    pub channel_end: ::core::option::Option<bool>,
    #[prost(message, optional, tag = "5")]
    pub origin: ::core::option::Option<CMsgVector>,
    #[prost(bool, optional, tag = "6")]
    pub track_caster_only: ::core::option::Option<bool>,
    #[prost(float, optional, tag = "7")]
    pub end_time: ::core::option::Option<f32>,
    #[prost(int32, optional, tag = "8", default = "-1")]
    pub victim_ent_index: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgProjectionEvent {
    #[prost(
        enumeration = "EProjectionEvent",
        optional,
        tag = "1",
        default = "EPeFirstBlood"
    )]
    pub event_id: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "2")]
    pub team: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgXpAlert {
    #[prost(int32, optional, tag = "1", default = "-1")]
    pub player_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2", default = "-1")]
    pub target_entindex: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgTalentTreeAlert {
    #[prost(int32, optional, tag = "1", default = "-1")]
    pub player_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2", default = "-1")]
    pub target_entindex: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3", default = "-1")]
    pub ability_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "4")]
    pub slot: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "5")]
    pub learned: ::core::option::Option<bool>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgUpdateQuestProgress {}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgQuestStatus {
    #[prost(int32, required, tag = "1", default = "-1")]
    pub player_id: i32,
    #[prost(uint32, optional, tag = "2")]
    pub quest_id: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub challenge_id: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub progress: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "5")]
    pub goal: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "6")]
    pub query: ::core::option::Option<u32>,
    #[prost(float, optional, tag = "7")]
    pub fail_gametime: ::core::option::Option<f32>,
    #[prost(int32, optional, tag = "8", default = "-1")]
    pub item_ability_id: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgSuggestHeroPick {
    #[prost(int32, required, tag = "1", default = "-1")]
    pub player_id: i32,
    #[prost(uint32, optional, tag = "2")]
    pub hero_id: ::core::option::Option<u32>,
    #[prost(bool, optional, tag = "3")]
    pub ban: ::core::option::Option<bool>,
    #[prost(uint32, optional, tag = "4")]
    pub facet_id: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgSuggestHeroRole {
    #[prost(int32, required, tag = "1", default = "-1")]
    pub player_id: i32,
    #[prost(string, optional, tag = "2")]
    pub hero_role: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgKillcamDamageTaken {
    #[prost(int32, required, tag = "1", default = "-1")]
    pub player_id: i32,
    #[prost(uint32, optional, tag = "2")]
    pub damage_taken: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub item_type: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "4", default = "-1")]
    pub item_ability_id: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "5")]
    pub hero_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "6")]
    pub damage_color: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgSelectPenaltyGold {
    #[prost(int32, required, tag = "1", default = "-1")]
    pub player_id: i32,
    #[prost(sint32, optional, tag = "2")]
    pub cost: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgRollDiceResult {
    #[prost(int32, optional, tag = "1", default = "-1")]
    pub player_id: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "2")]
    pub channel_type: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub roll_min: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub roll_max: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "5")]
    pub result: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgFlipCoinResult {
    #[prost(int32, optional, tag = "1", default = "-1")]
    pub player_id: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "2")]
    pub channel_type: ::core::option::Option<u32>,
    #[prost(bool, optional, tag = "3")]
    pub result: ::core::option::Option<bool>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CDotaUserMessageRequestItemSuggestions {
    #[prost(int32, optional, tag = "1", default = "-1")]
    pub player_id: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CDotaUserMessageTeamCaptainChanged {
    #[prost(uint32, optional, tag = "1")]
    pub team: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "2", default = "-1")]
    pub captain_player_id: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgChatWheelCooldown {
    #[prost(uint32, optional, tag = "1", default = "4294967295")]
    pub message_id: ::core::option::Option<u32>,
    #[prost(float, optional, tag = "2")]
    pub cooldown_remaining: ::core::option::Option<f32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgHeroRelicProgress {
    #[prost(uint32, optional, tag = "1")]
    pub hero_relic_type: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub value: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3", default = "16777215")]
    pub ehandle: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub event_id: ::core::option::Option<u32>,
    #[prost(float, optional, tag = "5")]
    pub value_display: ::core::option::Option<f32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgAbilityDraftRequestAbility {
    #[prost(int32, optional, tag = "1", default = "-1")]
    pub player_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2", default = "-1")]
    pub requested_ability_id: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "3")]
    pub ctrl_is_down: ::core::option::Option<bool>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgDamageReport {
    #[prost(int32, optional, tag = "1", default = "-1")]
    pub player_id: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "2")]
    pub target_hero_id: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub source_hero_id: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "4")]
    pub damage_amount: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "5")]
    pub broadcast: ::core::option::Option<bool>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgSalutePlayer {
    #[prost(int32, optional, tag = "1", default = "-1")]
    pub source_player_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2", default = "-1")]
    pub target_player_id: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "3")]
    pub tip_amount: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub event_id: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "5")]
    pub custom_tip_style: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "6")]
    pub num_recent_tips: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgGiftPlayer {
    #[prost(int32, optional, tag = "1", default = "-1")]
    pub source_player_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2", default = "-1")]
    pub target_player_id: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "3")]
    pub gift_item_def_index: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgTipAlert {
    #[prost(int32, optional, tag = "1", default = "-1")]
    pub player_id: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "2")]
    pub tip_text: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgReplaceQueryUnit {
    #[prost(int32, required, tag = "1", default = "-1")]
    pub player_id: i32,
    #[prost(int32, optional, tag = "2", default = "-1")]
    pub source_entindex: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3", default = "-1")]
    pub target_entindex: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgEsArcanaCombo {
    #[prost(uint32, optional, tag = "1", default = "16777215")]
    pub ehandle: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub combo_count: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub arcana_level: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgEsArcanaComboSummary {
    #[prost(uint32, optional, tag = "1", default = "16777215")]
    pub ehandle: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub combo_count: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub damage_amount: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgOmArcanaCombo {
    #[prost(uint32, optional, tag = "1", default = "16777215")]
    pub ehandle: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub multicast_amount: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub arcana_level: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub multicast_chance: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgHighFiveCompleted {
    #[prost(int32, optional, tag = "1", default = "-1")]
    pub player_id_1: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2", default = "-1")]
    pub player_id_2: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "3")]
    pub special_high_five: ::core::option::Option<bool>,
    #[prost(int32, optional, tag = "4", default = "-1")]
    pub special_entindex: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgHighFiveLeftHanging {
    #[prost(int32, optional, tag = "1", default = "-1")]
    pub player_id: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgShovelUnearth {
    #[prost(int32, optional, tag = "1", default = "-1")]
    pub player_id: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "2")]
    pub all_chat: ::core::option::Option<bool>,
    #[prost(string, optional, tag = "3")]
    pub locstring: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "4")]
    pub quantity: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgAllStarEvent {
    #[prost(int32, optional, tag = "1", default = "-1")]
    pub source_player_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2", default = "-1")]
    pub target_player_id: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "3")]
    pub point_amount: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub event_id: ::core::option::Option<u32>,
    #[prost(message, repeated, tag = "5")]
    pub player_scores: ::prost::alloc::vec::Vec<cdota_user_msg_all_star_event::PlayerScore>,
}
/// Nested message and enum types in `CDOTAUserMsg_AllStarEvent`.
pub mod cdota_user_msg_all_star_event {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct PlayerScore {
        #[prost(int32, optional, tag = "1", default = "-1")]
        pub player_id: ::core::option::Option<i32>,
        #[prost(uint32, optional, tag = "2")]
        pub score_sans_kda: ::core::option::Option<u32>,
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgQueuedOrderRemoved {
    #[prost(uint32, repeated, packed = "false", tag = "1")]
    pub unit_order_sequence: ::prost::alloc::vec::Vec<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgDebugChallenge {
    #[prost(uint32, required, tag = "1")]
    pub challenge_type: u32,
    #[prost(uint32, required, tag = "2")]
    pub challenge_query_id: u32,
    #[prost(uint32, required, tag = "3")]
    pub event_id: u32,
    #[prost(uint32, optional, tag = "4")]
    pub instance_id: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "5")]
    pub challenge_var_0: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "6")]
    pub challenge_var_1: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "7")]
    pub challenge_max_rank: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgFoundNeutralItem {
    #[prost(int32, optional, tag = "1", default = "-1")]
    pub player_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2", default = "-1")]
    pub item_ability_id: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "3")]
    pub item_tier: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub tier_item_count: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgOutpostCaptured {
    #[prost(int32, optional, tag = "1", default = "-1")]
    pub outpost_entindex: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "2")]
    pub team_id: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgOutpostGrantedXp {
    #[prost(uint32, optional, tag = "1")]
    pub team_id: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub xp_amount: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgMoveCameraToUnit {
    #[prost(uint32, optional, tag = "1", default = "16777215")]
    pub unit_ehandle: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgPauseMinigameData {
    #[prost(message, repeated, tag = "1")]
    pub data_bits: ::prost::alloc::vec::Vec<cdota_user_msg_pause_minigame_data::DataBit>,
}
/// Nested message and enum types in `CDOTAUserMsg_PauseMinigameData`.
pub mod cdota_user_msg_pause_minigame_data {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct DataBit {
        #[prost(uint32, optional, tag = "1")]
        pub index: ::core::option::Option<u32>,
        #[prost(int32, optional, tag = "2")]
        pub data: ::core::option::Option<i32>,
        #[prost(int64, optional, tag = "3")]
        pub data_extra: ::core::option::Option<i64>,
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgVersusScenePlayerBehavior {
    #[prost(int32, optional, tag = "1", default = "-1")]
    pub player_id: ::core::option::Option<i32>,
    #[prost(
        enumeration = "EDotaVersusScenePlayerBehavior",
        optional,
        tag = "2",
        default = "VsPlayerBehaviorPlayActivity"
    )]
    pub behavior: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "3")]
    pub play_activity: ::core::option::Option<VersusScenePlayActivity>,
    #[prost(message, optional, tag = "4")]
    pub chat_wheel: ::core::option::Option<VersusSceneChatWheel>,
    #[prost(message, optional, tag = "5")]
    pub playback_rate: ::core::option::Option<VersusScenePlaybackRate>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgQoPArcanaSummary {
    #[prost(uint32, optional, tag = "1", default = "16777215")]
    pub ehandle: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub arcana_level: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub players_hit: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub players_killed: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgHotPotatoCreated {
    #[prost(int32, optional, tag = "1", default = "-1")]
    pub player_id_1: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2", default = "-1")]
    pub player_id_2: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgHotPotatoExploded {
    #[prost(int32, optional, tag = "1", default = "-1")]
    pub player_id: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgWkArcanaProgress {
    #[prost(uint32, optional, tag = "1", default = "16777215")]
    pub ehandle: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub arcana_level: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub hero_id: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgGuildChallengeProgress {
    #[prost(message, repeated, tag = "1")]
    pub player_progress:
        ::prost::alloc::vec::Vec<cdota_user_msg_guild_challenge_progress::PlayerProgress>,
    #[prost(uint32, optional, tag = "2")]
    pub guild_id: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub challenge_instance_id: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub challenge_parameter: ::core::option::Option<u32>,
    #[prost(
        enumeration = "cdota_user_msg_guild_challenge_progress::EChallengeType",
        optional,
        tag = "5",
        default = "KEChallengeTypeInvalid"
    )]
    pub challenge_type: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "7")]
    pub challenge_progress_at_start: ::core::option::Option<u32>,
    #[prost(bool, optional, tag = "8")]
    pub complete: ::core::option::Option<bool>,
}
/// Nested message and enum types in `CDOTAUserMsg_GuildChallenge_Progress`.
pub mod cdota_user_msg_guild_challenge_progress {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct PlayerProgress {
        #[prost(int32, optional, tag = "1", default = "-1")]
        pub player_id: ::core::option::Option<i32>,
        #[prost(uint32, optional, tag = "6")]
        pub progress: ::core::option::Option<u32>,
    }
    #[derive(
        serde::Serialize,
        serde::Deserialize,
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration,
    )]
    #[repr(i32)]
    pub enum EChallengeType {
        KEChallengeTypeInvalid = 0,
        KEChallengeTypeCooperative = 1,
        KEChallengeTypeContract = 2,
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgWrArcanaProgress {
    #[prost(uint32, optional, tag = "1", default = "16777215")]
    pub ehandle: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2", default = "16777215")]
    pub target_ehandle: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub arrows_landed: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub damage_dealt: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "5")]
    pub target_hp: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "6")]
    pub target_max_hp: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "7")]
    pub arcana_level: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgWrArcanaSummary {
    #[prost(uint32, optional, tag = "1", default = "16777215")]
    pub ehandle: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2", default = "16777215")]
    pub target_ehandle: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub arrows_landed: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub damage_dealt: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "5")]
    pub target_hp: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "6")]
    pub target_max_hp: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "7")]
    pub arcana_level: ::core::option::Option<u32>,
    #[prost(bool, optional, tag = "8")]
    pub success: ::core::option::Option<bool>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgEmptyItemSlotAlert {
    #[prost(int32, optional, tag = "1", default = "-1")]
    pub source_player_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2", default = "-1")]
    pub target_player_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub slot_index: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "4")]
    pub cooldown_seconds: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgAghsStatusAlert {
    #[prost(int32, optional, tag = "1", default = "-1")]
    pub source_player_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2", default = "-1")]
    pub target_player_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3", default = "-1")]
    pub target_entindex: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "4")]
    pub alert_type: ::core::option::Option<u32>,
    #[prost(bool, optional, tag = "5")]
    pub has_scepter: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "6")]
    pub has_shard: ::core::option::Option<bool>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgMutedPlayers {
    #[prost(int32, repeated, packed = "false", tag = "1")]
    pub text_muted_player_ids: ::prost::alloc::vec::Vec<i32>,
    #[prost(int32, repeated, packed = "false", tag = "2")]
    pub voice_muted_player_ids: ::prost::alloc::vec::Vec<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgContextualTip {
    #[prost(int32, optional, tag = "1")]
    pub tip_id: ::core::option::Option<i32>,
    #[prost(string, repeated, tag = "2")]
    pub referenced_abilities: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "3")]
    pub referenced_units: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "4")]
    pub panorama_classes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "5")]
    pub force_annotation: ::core::option::Option<bool>,
    #[prost(int32, optional, tag = "6")]
    pub variant: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "7")]
    pub int_param: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "8")]
    pub int_param2: ::core::option::Option<i32>,
    #[prost(float, optional, tag = "9")]
    pub float_param: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "10")]
    pub float_param2: ::core::option::Option<f32>,
    #[prost(string, optional, tag = "11")]
    pub string_param: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "12")]
    pub string_param2: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "13")]
    pub tip_text_override: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "14")]
    pub tip_annotation_override: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "15")]
    pub panorama_snippet: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgChatMessage {
    #[prost(int32, optional, tag = "1", default = "-1")]
    pub source_player_id: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "2")]
    pub channel_type: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "3")]
    pub message_text: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgRockPaperScissorsStarted {
    #[prost(int32, optional, tag = "1", default = "-1")]
    pub player_id_source: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2", default = "-1")]
    pub player_id_target: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgRockPaperScissorsFinished {
    #[prost(int32, optional, tag = "1", default = "-1")]
    pub player_id_1: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2", default = "-1")]
    pub player_id_2: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub player_1_choice: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "4")]
    pub player_2_choice: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgDuelOpponentKilled {
    #[prost(int32, optional, tag = "1")]
    pub player_id_winner: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub player_id_loser: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgDuelAccepted {
    #[prost(int32, optional, tag = "1")]
    pub player_id_1: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub player_id_2: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgDuelRequested {
    #[prost(int32, optional, tag = "1", default = "-1")]
    pub player_id_requestor: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgMuertaReleaseEventAssignedTargetKilled {
    #[prost(int32, required, tag = "1", default = "-1")]
    pub player_id_killer: i32,
    #[prost(int32, required, tag = "2", default = "-1")]
    pub player_id_target: i32,
    #[prost(int32, required, tag = "3")]
    pub points: i32,
    #[prost(int32, required, tag = "4")]
    pub points_total: i32,
    #[prost(bool, required, tag = "5")]
    pub last_hit: bool,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgPlayerDraftSuggestPick {
    #[prost(int32, optional, tag = "1", default = "-1")]
    pub player_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2", default = "-1")]
    pub suggestion_player_id: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgPlayerDraftPick {
    #[prost(int32, optional, tag = "1", default = "-1")]
    pub player_id_captain: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2", default = "-1")]
    pub player_id_target: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub team: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgFacetPing {
    #[prost(int32, optional, tag = "1", default = "-1")]
    pub player_id: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "2")]
    pub facet_strhash: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub entity_id: ::core::option::Option<u32>,
    #[prost(bool, optional, tag = "4")]
    pub all_chat: ::core::option::Option<bool>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CDotaUserMsgInnatePing {
    #[prost(int32, optional, tag = "1", default = "-1")]
    pub player_id: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "2")]
    pub entity_id: ::core::option::Option<u32>,
    #[prost(bool, optional, tag = "3")]
    pub all_chat: ::core::option::Option<bool>,
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum EDotaUserMessages {
    DotaUmAddUnitToSelection = 464,
    DotaUmAiDebugLine = 465,
    DotaUmChatEvent = 466,
    DotaUmCombatHeroPositions = 467,
    DotaUmCombatLogData = 468,
    DotaUmCombatLogBulkData = 470,
    DotaUmCreateLinearProjectile = 471,
    DotaUmDestroyLinearProjectile = 472,
    DotaUmDodgeTrackingProjectiles = 473,
    DotaUmGlobalLightColor = 474,
    DotaUmGlobalLightDirection = 475,
    DotaUmInvalidCommand = 476,
    DotaUmLocationPing = 477,
    DotaUmMapLine = 478,
    DotaUmMiniKillCamInfo = 479,
    DotaUmMinimapDebugPoint = 480,
    DotaUmMinimapEvent = 481,
    DotaUmNevermoreRequiem = 482,
    DotaUmOverheadEvent = 483,
    DotaUmSetNextAutobuyItem = 484,
    DotaUmSharedCooldown = 485,
    DotaUmSpectatorPlayerClick = 486,
    DotaUmTutorialTipInfo = 487,
    DotaUmUnitEvent = 488,
    DotaUmParticleManager = 489,
    DotaUmBotChat = 490,
    DotaUmHudError = 491,
    DotaUmItemPurchased = 492,
    DotaUmPing = 493,
    DotaUmItemFound = 494,
    DotaUmCharacterSpeakConcept = 495,
    DotaUmSwapVerify = 496,
    DotaUmWorldLine = 497,
    DotaUmTournamentDrop = 498,
    DotaUmItemAlert = 499,
    DotaUmHalloweenDrops = 500,
    DotaUmChatWheel = 501,
    DotaUmReceivedXmasGift = 502,
    DotaUmUpdateSharedContent = 503,
    DotaUmTutorialRequestExp = 504,
    DotaUmTutorialPingMinimap = 505,
    DotaUmGamerulesStateChanged = 506,
    DotaUmShowSurvey = 507,
    DotaUmTutorialFade = 508,
    DotaUmAddQuestLogEntry = 509,
    DotaUmSendStatPopup = 510,
    DotaUmTutorialFinish = 511,
    DotaUmSendRoshanPopup = 512,
    DotaUmSendGenericToolTip = 513,
    DotaUmSendFinalGold = 514,
    DotaUmCustomMsg = 515,
    DotaUmCoachHudPing = 516,
    DotaUmClientLoadGridNav = 517,
    DotaUmTeProjectile = 518,
    DotaUmTeProjectileLoc = 519,
    DotaUmTeDotaBloodImpact = 520,
    DotaUmTeUnitAnimation = 521,
    DotaUmTeUnitAnimationEnd = 522,
    DotaUmAbilityPing = 523,
    DotaUmShowGenericPopup = 524,
    DotaUmVoteStart = 525,
    DotaUmVoteUpdate = 526,
    DotaUmVoteEnd = 527,
    DotaUmBoosterState = 528,
    DotaUmWillPurchaseAlert = 529,
    DotaUmTutorialMinimapPosition = 530,
    DotaUmPlayerMmr = 531,
    DotaUmAbilitySteal = 532,
    DotaUmCourierKilledAlert = 533,
    DotaUmEnemyItemAlert = 534,
    DotaUmStatsMatchDetails = 535,
    DotaUmMiniTaunt = 536,
    DotaUmBuyBackStateAlert = 537,
    DotaUmSpeechBubble = 538,
    DotaUmCustomHeaderMessage = 539,
    DotaUmQuickBuyAlert = 540,
    DotaUmStatsHeroDetails = 541,
    DotaUmPredictionResult = 542,
    DotaUmModifierAlert = 543,
    DotaUmHpManaAlert = 544,
    DotaUmGlyphAlert = 545,
    DotaUmBeastChat = 546,
    DotaUmSpectatorPlayerUnitOrders = 547,
    DotaUmCustomHudElementCreate = 548,
    DotaUmCustomHudElementModify = 549,
    DotaUmCustomHudElementDestroy = 550,
    DotaUmCompendiumState = 551,
    DotaUmProjectionAbility = 552,
    DotaUmProjectionEvent = 553,
    DotaUmCombatLogDataHltv = 554,
    DotaUmXpAlert = 555,
    DotaUmUpdateQuestProgress = 556,
    DotaUmMatchMetadata = 557,
    DotaUmMatchDetails = 558,
    DotaUmQuestStatus = 559,
    DotaUmSuggestHeroPick = 560,
    DotaUmSuggestHeroRole = 561,
    DotaUmKillcamDamageTaken = 562,
    DotaUmSelectPenaltyGold = 563,
    DotaUmRollDiceResult = 564,
    DotaUmFlipCoinResult = 565,
    DotaUmRequestItemSuggestions = 566,
    DotaUmTeamCaptainChanged = 567,
    DotaUmSendRoshanSpectatorPhase = 568,
    DotaUmChatWheelCooldown = 569,
    DotaUmDismissAllStatPopups = 570,
    DotaUmTeDestroyProjectile = 571,
    DotaUmHeroRelicProgress = 572,
    DotaUmAbilityDraftRequestAbility = 573,
    DotaUmItemSold = 574,
    DotaUmDamageReport = 575,
    DotaUmSalutePlayer = 576,
    DotaUmTipAlert = 577,
    DotaUmReplaceQueryUnit = 578,
    DotaUmEmptyTeleportAlert = 579,
    DotaUmMarsArenaOfBloodAttack = 580,
    DotaUmEsArcanaCombo = 581,
    DotaUmEsArcanaComboSummary = 582,
    DotaUmHighFiveLeftHanging = 583,
    DotaUmHighFiveCompleted = 584,
    DotaUmShovelUnearth = 585,
    DotaEmInvokerSpellCast = 586,
    DotaUmRadarAlert = 587,
    DotaUmAllStarEvent = 588,
    DotaUmTalentTreeAlert = 589,
    DotaUmQueuedOrderRemoved = 590,
    DotaUmDebugChallenge = 591,
    DotaUmOmArcanaCombo = 592,
    DotaUmFoundNeutralItem = 593,
    DotaUmOutpostCaptured = 594,
    DotaUmOutpostGrantedXp = 595,
    DotaUmMoveCameraToUnit = 596,
    DotaUmPauseMinigameData = 597,
    DotaUmVersusScenePlayerBehavior = 598,
    DotaUmQoPArcanaSummary = 600,
    DotaUmHotPotatoCreated = 601,
    DotaUmHotPotatoExploded = 602,
    DotaUmWkArcanaProgress = 603,
    DotaUmGuildChallengeProgress = 604,
    DotaUmWrArcanaProgress = 605,
    DotaUmWrArcanaSummary = 606,
    DotaUmEmptyItemSlotAlert = 607,
    DotaUmAghsStatusAlert = 608,
    DotaUmPingConfirmation = 609,
    DotaUmMutedPlayers = 610,
    DotaUmContextualTip = 611,
    DotaUmChatMessage = 612,
    DotaUmNeutralCampAlert = 613,
    DotaUmRockPaperScissorsStarted = 614,
    DotaUmRockPaperScissorsFinished = 615,
    DotaUmDuelOpponentKilled = 616,
    DotaUmDuelAccepted = 617,
    DotaUmDuelRequested = 618,
    DotaUmMuertaReleaseEventAssignedTargetKilled = 619,
    DotaUmPlayerDraftSuggestPick = 620,
    DotaUmPlayerDraftPick = 621,
    DotaUmUpdateLinearProjectileCpData = 622,
    DotaUmGiftPlayer = 623,
    DotaUmFacetPing = 624,
    DotaUmInnatePing = 625,
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum DotaChatMessage {
    ChatMessageInvalid = -1,
    ChatMessageHeroKill = 0,
    ChatMessageHeroDeny = 1,
    ChatMessageBarracksKill = 2,
    ChatMessageTowerKill = 3,
    ChatMessageTowerDeny = 4,
    ChatMessageFirstblood = 5,
    ChatMessageStreakKill = 6,
    ChatMessageBuyback = 7,
    ChatMessageAegis = 8,
    ChatMessageRoshanKill = 9,
    ChatMessageCourierLost = 10,
    ChatMessageCourierRespawned = 11,
    ChatMessageGlyphUsed = 12,
    ChatMessageItemPurchase = 13,
    ChatMessageConnect = 14,
    ChatMessageDisconnect = 15,
    ChatMessageDisconnectWaitForReconnect = 16,
    ChatMessageDisconnectTimeRemaining = 17,
    ChatMessageDisconnectTimeRemainingPlural = 18,
    ChatMessageReconnect = 19,
    ChatMessagePlayerLeft = 20,
    ChatMessageSafeToLeave = 21,
    ChatMessageRunePickup = 22,
    ChatMessageRuneBottle = 23,
    ChatMessageRuneDeny = 114,
    ChatMessageInthebag = 24,
    ChatMessageSecretshop = 25,
    ChatMessageItemAutopurchased = 26,
    ChatMessageItemsCombined = 27,
    ChatMessageSuperCreeps = 28,
    ChatMessageCantUseActionItem = 29,
    ChatMessageCantpause = 31,
    ChatMessageNopausesleft = 32,
    ChatMessageCantpauseyet = 33,
    ChatMessagePaused = 34,
    ChatMessageUnpauseCountdown = 35,
    ChatMessageUnpaused = 36,
    ChatMessageAutoUnpaused = 37,
    ChatMessageYoupaused = 38,
    ChatMessageCantunpauseteam = 39,
    ChatMessageVoiceTextBanned = 41,
    ChatMessageSpectatorsWatchingThisGame = 42,
    ChatMessageReportReminder = 43,
    ChatMessageEconItem = 44,
    ChatMessageTaunt = 45,
    ChatMessageRandom = 46,
    ChatMessageRdTurn = 47,
    ChatMessageDropRateBonus = 49,
    ChatMessageNoBattlePoints = 50,
    ChatMessageDeniedAegis = 51,
    ChatMessageInformational = 52,
    ChatMessageAegisStolen = 53,
    ChatMessageRoshanCandy = 54,
    ChatMessageItemGifted = 55,
    ChatMessageHeroKillWithGreevil = 56,
    ChatMessageHoldoutTowerDestroyed = 57,
    ChatMessageHoldoutWallDestroyed = 58,
    ChatMessageHoldoutWallFinished = 59,
    ChatMessagePlayerLeftLimitedHero = 62,
    ChatMessageAbandonLimitedHeroExplanation = 63,
    ChatMessageDisconnectLimitedHero = 64,
    ChatMessageLowPriorityCompletedExplanation = 65,
    ChatMessageRecruitmentDropRateBonus = 66,
    ChatMessageFrostivusShiningBoosterActive = 67,
    ChatMessagePlayerLeftAfk = 73,
    ChatMessagePlayerLeftDisconnectedTooLong = 74,
    ChatMessagePlayerAbandoned = 75,
    ChatMessagePlayerAbandonedAfk = 76,
    ChatMessagePlayerAbandonedDisconnectedTooLong = 77,
    ChatMessageWillNotBeScored = 78,
    ChatMessageWillNotBeScoredRanked = 79,
    ChatMessageWillNotBeScoredNetwork = 80,
    ChatMessageWillNotBeScoredNetworkRanked = 81,
    ChatMessageCanQuitWithoutAbandon = 82,
    ChatMessageRankedGameStillScoredLeaversGetLoss = 83,
    ChatMessageAbandonRankedBeforeFirstBloodParty = 84,
    ChatMessageCompendiumLevel = 85,
    ChatMessageVictoryPredictionStreak = 86,
    ChatMessageAssassinAnnounce = 87,
    ChatMessageAssassinSuccess = 88,
    ChatMessageAssassinDenied = 89,
    ChatMessageVictoryPredictionSingleUserConfirm = 90,
    ChatMessageEffigyKill = 91,
    ChatMessageVoiceTextBannedOverflow = 92,
    ChatMessageYearBeastKilled = 93,
    ChatMessagePauseCountdown = 94,
    ChatMessageCoinsWagered = 95,
    ChatMessageHeroNominatedBan = 96,
    ChatMessageHeroBanned = 97,
    ChatMessageHeroBanCount = 98,
    ChatMessageRiverPainted = 99,
    ChatMessageScanUsed = 100,
    ChatMessageShrineKilled = 101,
    ChatMessageWagerTokenSpent = 102,
    ChatMessageRankWager = 103,
    ChatMessageNewPlayerReminder = 104,
    ChatMessageObserverWardKilled = 105,
    ChatMessageSentryWardKilled = 106,
    ChatMessageItemPlacedInNeutralStash = 107,
    ChatMessageHeroChoiceInvalid = 108,
    ChatMessageBounty = 109,
    ChatMessageAbilityDraftStart = 110,
    ChatMessageHeroFoundCandy = 111,
    ChatMessageAbilityDraftRandomed = 112,
    ChatMessagePrivateCoachConnected = 113,
    ChatMessageCantPauseTooEarly = 115,
    ChatMessageHeroKillWithPenguin = 116,
    ChatMessageMinibossKill = 117,
    ChatMessagePlayerInGameBanText = 118,
    ChatMessageBannerPlanted = 119,
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum DotaNoBattlePointsReasons {
    NoBattlePointsWrongLobbyType = 1,
    NoBattlePointsPracticeBots = 2,
    NoBattlePointsCheatsEnabled = 3,
    NoBattlePointsLowPriority = 4,
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum DotaChatInformational {
    InfoCoopBattlePointsRules = 1,
    InfoFrostivusAbandonReminder = 2,
    InfoRankedReminder = 3,
    InfoCoopLowPriorityPassiveReminder = 4,
    InfoCustomGamePenaltyReminder = 5,
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum DotaAbilityPingType {
    AbilityPingReady = 1,
    AbilityPingMana = 2,
    AbilityPingCooldown = 3,
    AbilityPingEnemy = 4,
    AbilityPingUnlearned = 5,
    AbilityPingInbackpack = 6,
    AbilityPingInstash = 7,
    AbilityPingOncourier = 8,
    AbilityPingAlly = 9,
    AbilityPingLearnReady = 10,
    AbilityPingWillLearn = 11,
    AbilityPingFutureLearn = 12,
    AbilityPingNeutralOffer = 13,
    AbilityPingNeutralRequest = 14,
    AbilityPingNeutralEquip = 15,
    AbilityPingIncourierbackpack = 16,
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum DotaReplayStateEvent {
    GameStart = 1,
    StartingHorn = 2,
    FirstBlood = 3,
    Showcase = 4,
    PostGame = 5,
    WaitForMap = 6,
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum EDotaEntityMessages {
    DotaUnitSpeech = 0,
    DotaUnitSpeechMute = 1,
    DotaUnitAddGesture = 2,
    DotaUnitRemoveGesture = 3,
    DotaUnitRemoveAllGestures = 4,
    DotaUnitFadeGesture = 6,
    DotaUnitSpeechClientsideRules = 7,
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum DotaOverheadAlert {
    OverheadAlertGold = 0,
    OverheadAlertDeny = 1,
    OverheadAlertCritical = 2,
    OverheadAlertXp = 3,
    OverheadAlertBonusSpellDamage = 4,
    OverheadAlertMiss = 5,
    OverheadAlertDamage = 6,
    OverheadAlertEvade = 7,
    OverheadAlertBlock = 8,
    OverheadAlertBonusPoisonDamage = 9,
    OverheadAlertHeal = 10,
    OverheadAlertManaAdd = 11,
    OverheadAlertManaLoss = 12,
    OverheadAlertLastHitEarly = 13,
    OverheadAlertLastHitClose = 14,
    OverheadAlertLastHitMiss = 15,
    OverheadAlertMagicalBlock = 16,
    OverheadAlertIncomingDamage = 17,
    OverheadAlertOutgoingDamage = 18,
    OverheadAlertDisableResist = 19,
    OverheadAlertDeath = 20,
    OverheadAlertBlocked = 21,
    OverheadAlertItemReceived = 22,
    OverheadAlertShard = 23,
    OverheadAlertDeadlyBlow = 24,
    OverheadAlertForceMiss = 25,
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum DotaRoshanPhase {
    KSrspRoshanAlive = 0,
    KSrspRoshanBaseTimer = 1,
    KSrspRoshanVisibleTimer = 2,
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum DotaPositionCategory {
    DotaPositionNone = 0,
    DotaPositionBottomLane = 1,
    DotaPositionMidLane = 2,
    DotaPositionTopLane = 3,
    DotaPositionRadiantJungle = 4,
    DotaPositionDireJungle = 5,
    DotaPositionRadiantAncients = 6,
    DotaPositionDireAncients = 7,
    DotaPositionRadiantSecretShop = 8,
    DotaPositionDireSecretShop = 9,
    DotaPositionRiver = 10,
    DotaPositionRoshanPit = 11,
    DotaPositionRadiantBase = 12,
    DotaPositionDireBase = 13,
    DotaPositionFountain = 14,
    DotaPositionOther = 15,
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum DotaAbilityTargetType {
    DotaAbilityTargetNone = 0,
    DotaAbilityTargetSelf = 1,
    DotaAbilityTargetAllyHero = 2,
    DotaAbilityTargetAllyCreep = 3,
    DotaAbilityTargetEnemyHero = 4,
    DotaAbilityTargetEnemyCreep = 5,
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum EHeroStatType {
    KEHeroStatTypeNone = 0,
    KEHeroStatTypeAxeTotalDamage = 2000,
    KEHeroStatTypeBattleHungerDamage = 2001,
    KEHeroStatTypeCounterHelixDamage = 2002,
    KEHeroStatTypeCullingBladeDamage = 2003,
    KEHeroStatTypeBerserkersCallCastCount = 2004,
    KEHeroStatTypeBerserkersCallHeroesHitAverage = 2005,
    KEHeroStatTypeBerserkersCallOtherUnitsHit = 2006,
    KEHeroStatTypeBerserkersCallHeroAttacksTaken = 2007,
    KEHeroStatTypeBerserkersCallOtherAttacksTaken = 2008,
    KEHeroStatTypeBattleHungerCastCount = 2009,
    KEHeroStatTypeBattleHungerPotentialDuration = 2010,
    KEHeroStatTypeBattleHungerAverageDuration = 2011,
    KEHeroStatTypeCounterHelixProcCount = 2012,
    KEHeroStatTypeCounterHelixHeroProcCount = 2013,
    KEHeroStatTypeCounterHelixHeroesHitAverage = 2014,
    KEHeroStatTypeCounterHelixOtherUnitsHitCount = 2015,
    KEHeroStatTypeCullingBladeCastCount = 2016,
    KEHeroStatTypeCullingBladeKillCount = 2017,
    KEHeroStatTypeCullingBladeAverageHealthCulled = 2018,
    KEHeroStatTypeCullingBladeAverageDamageAvailable = 2019,
    KEHeroStatTypeCullingBladeHeroBuffAverage = 2020,
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum EPlayerVoiceListenState {
    KPvlsNone = 0,
    KPvlsDeniedChatBanned = 1,
    KPvlsDeniedPartner = 2,
    KPvlsDeniedHltvTalkerNotSpectator = 3,
    KPvlsDeniedHltvNoTalkerPlayerId = 4,
    KPvlsDeniedHltvTalkerNotBroadcaster = 5,
    KPvlsDeniedTeamSpectator = 6,
    KPvlsDeniedStudent = 8,
    KPvlsDeniedPrivateCoach = 9,
    KPvlsDenied = 64,
    KPvlsAllowHltvTalkerIsBroadcaster = 65,
    KPvlsAllowCoBroadcaster = 66,
    KPvlsAllowAllChat = 67,
    KPvlsAllowStudentToCoach = 68,
    KPvlsAllowFellowStudent = 69,
    KPvlsAllowTalkerIsCoach = 70,
    KPvlsAllowCoachHearTeam = 71,
    KPvlsAllowSameTeam = 72,
    KPvlsAllowShowcase = 73,
    KPvlsAllowPrivateCoach = 74,
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum EProjectionEvent {
    EPeFirstBlood = 0,
    EPeKillstreakGodlike = 1,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgVDebugGameSessionIdEvent {
    #[prost(int32, optional, tag = "1")]
    pub clientid: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "2")]
    pub gamesessionid: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgPlaceDecalEvent {
    #[prost(message, optional, tag = "1")]
    pub position: ::core::option::Option<CMsgVector>,
    #[prost(message, optional, tag = "2")]
    pub normal: ::core::option::Option<CMsgVector>,
    #[prost(message, optional, tag = "3")]
    pub saxis: ::core::option::Option<CMsgVector>,
    #[prost(uint32, optional, tag = "4")]
    pub decalmaterialindex: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "5")]
    pub flags: ::core::option::Option<u32>,
    #[prost(fixed32, optional, tag = "6")]
    pub color: ::core::option::Option<u32>,
    #[prost(float, optional, tag = "7")]
    pub width: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "8")]
    pub height: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "9")]
    pub depth: ::core::option::Option<f32>,
    #[prost(uint32, optional, tag = "10")]
    pub entityhandleindex: ::core::option::Option<u32>,
    #[prost(fixed32, optional, tag = "11")]
    pub skeletoninstancehash: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "12")]
    pub boneindex: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "13")]
    pub translucenthit: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "14")]
    pub is_adjacent: ::core::option::Option<bool>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgClearWorldDecalsEvent {
    #[prost(uint32, optional, tag = "1")]
    pub flagstoclear: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgClearEntityDecalsEvent {
    #[prost(uint32, optional, tag = "1")]
    pub flagstoclear: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgClearDecalsForSkeletonInstanceEvent {
    #[prost(uint32, optional, tag = "1")]
    pub flagstoclear: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub entityhandleindex: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub skeletoninstancehash: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgSource1LegacyGameEventList {
    #[prost(message, repeated, tag = "1")]
    pub descriptors: ::prost::alloc::vec::Vec<c_msg_source1_legacy_game_event_list::DescriptorT>,
}
/// Nested message and enum types in `CMsgSource1LegacyGameEventList`.
pub mod c_msg_source1_legacy_game_event_list {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct KeyT {
        #[prost(int32, optional, tag = "1")]
        pub r#type: ::core::option::Option<i32>,
        #[prost(string, optional, tag = "2")]
        pub name: ::core::option::Option<::prost::alloc::string::String>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DescriptorT {
        #[prost(int32, optional, tag = "1")]
        pub eventid: ::core::option::Option<i32>,
        #[prost(string, optional, tag = "2")]
        pub name: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(message, repeated, tag = "3")]
        pub keys: ::prost::alloc::vec::Vec<KeyT>,
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgSource1LegacyListenEvents {
    #[prost(int32, optional, tag = "1")]
    pub playerslot: ::core::option::Option<i32>,
    #[prost(uint32, repeated, packed = "false", tag = "2")]
    pub eventarraybits: ::prost::alloc::vec::Vec<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgSource1LegacyGameEvent {
    #[prost(string, optional, tag = "1")]
    pub event_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "2")]
    pub eventid: ::core::option::Option<i32>,
    #[prost(message, repeated, tag = "3")]
    pub keys: ::prost::alloc::vec::Vec<c_msg_source1_legacy_game_event::KeyT>,
    #[prost(int32, optional, tag = "4")]
    pub server_tick: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "5")]
    pub passthrough: ::core::option::Option<i32>,
}
/// Nested message and enum types in `CMsgSource1LegacyGameEvent`.
pub mod c_msg_source1_legacy_game_event {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct KeyT {
        #[prost(int32, optional, tag = "1")]
        pub r#type: ::core::option::Option<i32>,
        #[prost(string, optional, tag = "2")]
        pub val_string: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(float, optional, tag = "3")]
        pub val_float: ::core::option::Option<f32>,
        #[prost(int32, optional, tag = "4")]
        pub val_long: ::core::option::Option<i32>,
        #[prost(int32, optional, tag = "5")]
        pub val_short: ::core::option::Option<i32>,
        #[prost(int32, optional, tag = "6")]
        pub val_byte: ::core::option::Option<i32>,
        #[prost(bool, optional, tag = "7")]
        pub val_bool: ::core::option::Option<bool>,
        #[prost(uint64, optional, tag = "8")]
        pub val_uint64: ::core::option::Option<u64>,
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgSosStartSoundEvent {
    #[prost(int32, optional, tag = "1")]
    pub soundevent_guid: ::core::option::Option<i32>,
    #[prost(fixed32, optional, tag = "2")]
    pub soundevent_hash: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "3", default = "-1")]
    pub source_entity_index: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "4")]
    pub seed: ::core::option::Option<i32>,
    #[prost(bytes = "vec", optional, tag = "5")]
    pub packed_params: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(float, optional, tag = "6")]
    pub start_time: ::core::option::Option<f32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgSosStopSoundEvent {
    #[prost(int32, optional, tag = "1")]
    pub soundevent_guid: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgSosStopSoundEventHash {
    #[prost(fixed32, optional, tag = "1")]
    pub soundevent_hash: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "2", default = "-1")]
    pub source_entity_index: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgSosSetSoundEventParams {
    #[prost(int32, optional, tag = "1")]
    pub soundevent_guid: ::core::option::Option<i32>,
    #[prost(bytes = "vec", optional, tag = "5")]
    pub packed_params: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgSosSetLibraryStackFields {
    #[prost(fixed32, optional, tag = "1")]
    pub stack_hash: ::core::option::Option<u32>,
    #[prost(bytes = "vec", optional, tag = "5")]
    pub packed_fields: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum EBaseGameEvents {
    GeVDebugGameSessionIdEvent = 200,
    GePlaceDecalEvent = 201,
    GeClearWorldDecalsEvent = 202,
    GeClearEntityDecalsEvent = 203,
    GeClearDecalsForSkeletonInstanceEvent = 204,
    GeSource1LegacyGameEventList = 205,
    GeSource1LegacyListenEvents = 206,
    GeSource1LegacyGameEvent = 207,
    GeSosStartSoundEvent = 208,
    GeSosStopSoundEvent = 209,
    GeSosSetSoundEventParams = 210,
    GeSosSetLibraryStackFields = 211,
    GeSosStopSoundEventHash = 212,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CClcMsgClientInfo {
    #[prost(fixed32, optional, tag = "1")]
    pub send_table_crc: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub server_count: ::core::option::Option<u32>,
    #[prost(bool, optional, tag = "3")]
    pub is_hltv: ::core::option::Option<bool>,
    #[prost(uint32, optional, tag = "5")]
    pub friends_id: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "6")]
    pub friends_name: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CClcMsgMove {
    #[prost(bytes = "vec", optional, tag = "3")]
    pub data: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(uint32, optional, tag = "4")]
    pub command_number: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "5")]
    pub num_commands: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgVoiceAudio {
    #[prost(
        enumeration = "VoiceDataFormatT",
        optional,
        tag = "1",
        default = "VoicedataFormatSteam"
    )]
    pub format: ::core::option::Option<i32>,
    #[prost(bytes = "vec", optional, tag = "2")]
    pub voice_data: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(int32, optional, tag = "3")]
    pub sequence_bytes: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "4")]
    pub section_number: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "5")]
    pub sample_rate: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "6")]
    pub uncompressed_sample_offset: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "7")]
    pub num_packets: ::core::option::Option<u32>,
    #[prost(uint32, repeated, tag = "8")]
    pub packet_offsets: ::prost::alloc::vec::Vec<u32>,
    #[prost(float, optional, tag = "9")]
    pub voice_level: ::core::option::Option<f32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CClcMsgVoiceData {
    #[prost(message, optional, tag = "1")]
    pub audio: ::core::option::Option<CMsgVoiceAudio>,
    #[prost(fixed64, optional, tag = "2")]
    pub xuid: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "3")]
    pub tick: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CClcMsgBaselineAck {
    #[prost(int32, optional, tag = "1")]
    pub baseline_tick: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub baseline_nr: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CClcMsgListenEvents {
    #[prost(fixed32, repeated, packed = "false", tag = "1")]
    pub event_mask: ::prost::alloc::vec::Vec<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CClcMsgRespondCvarValue {
    #[prost(int32, optional, tag = "1")]
    pub cookie: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub status_code: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "3")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "4")]
    pub value: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CClcMsgFileCrcCheck {
    #[prost(int32, optional, tag = "1")]
    pub code_path: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "2")]
    pub path: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "3")]
    pub code_filename: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "4")]
    pub filename: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(fixed32, optional, tag = "5")]
    pub crc: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CClcMsgLoadingProgress {
    #[prost(int32, optional, tag = "1")]
    pub progress: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CClcMsgSplitPlayerConnect {
    #[prost(string, optional, tag = "1")]
    pub playername: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CClcMsgClientMessage {
    #[prost(int32, optional, tag = "1")]
    pub msg_type: ::core::option::Option<i32>,
    #[prost(bytes = "vec", optional, tag = "2")]
    pub data: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CClcMsgSplitPlayerDisconnect {
    #[prost(int32, optional, tag = "1")]
    pub slot: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CClcMsgServerStatus {
    #[prost(bool, optional, tag = "1")]
    pub simplified: ::core::option::Option<bool>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CClcMsgRequestPause {
    #[prost(
        enumeration = "RequestPauseT",
        optional,
        tag = "1",
        default = "RpPause"
    )]
    pub pause_type: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub pause_group: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CClcMsgCmdKeyValues {
    #[prost(bytes = "vec", optional, tag = "1")]
    pub data: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CClcMsgRconServerDetails {
    #[prost(bytes = "vec", optional, tag = "1")]
    pub token: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CSvcMsgServerInfo {
    #[prost(int32, optional, tag = "1")]
    pub protocol: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub server_count: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "3")]
    pub is_dedicated: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "4")]
    pub is_hltv: ::core::option::Option<bool>,
    #[prost(int32, optional, tag = "6")]
    pub c_os: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "10")]
    pub max_clients: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "11")]
    pub max_classes: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "12", default = "-1")]
    pub player_slot: ::core::option::Option<i32>,
    #[prost(float, optional, tag = "13")]
    pub tick_interval: ::core::option::Option<f32>,
    #[prost(string, optional, tag = "14")]
    pub game_dir: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "15")]
    pub map_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "16")]
    pub sky_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "17")]
    pub host_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "18")]
    pub addon_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "19")]
    pub game_session_config: ::core::option::Option<CSvcMsgGameSessionConfiguration>,
    #[prost(bytes = "vec", optional, tag = "20")]
    pub game_session_manifest: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CSvcMsgClassInfo {
    #[prost(bool, optional, tag = "1")]
    pub create_on_client: ::core::option::Option<bool>,
    #[prost(message, repeated, tag = "2")]
    pub classes: ::prost::alloc::vec::Vec<csvc_msg_class_info::ClassT>,
}
/// Nested message and enum types in `CSVCMsg_ClassInfo`.
pub mod csvc_msg_class_info {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ClassT {
        #[prost(int32, optional, tag = "1")]
        pub class_id: ::core::option::Option<i32>,
        #[prost(string, optional, tag = "3")]
        pub class_name: ::core::option::Option<::prost::alloc::string::String>,
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CSvcMsgSetPause {
    #[prost(bool, optional, tag = "1")]
    pub paused: ::core::option::Option<bool>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CSvcMsgVoiceInit {
    #[prost(int32, optional, tag = "1")]
    pub quality: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "2")]
    pub codec: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "3", default = "0")]
    pub version: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CSvcMsgPrint {
    #[prost(string, optional, tag = "1")]
    pub text: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CSvcMsgSounds {
    #[prost(bool, optional, tag = "1")]
    pub reliable_sound: ::core::option::Option<bool>,
    #[prost(message, repeated, tag = "2")]
    pub sounds: ::prost::alloc::vec::Vec<csvc_msg_sounds::SounddataT>,
}
/// Nested message and enum types in `CSVCMsg_Sounds`.
pub mod csvc_msg_sounds {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct SounddataT {
        #[prost(sint32, optional, tag = "1")]
        pub origin_x: ::core::option::Option<i32>,
        #[prost(sint32, optional, tag = "2")]
        pub origin_y: ::core::option::Option<i32>,
        #[prost(sint32, optional, tag = "3")]
        pub origin_z: ::core::option::Option<i32>,
        #[prost(uint32, optional, tag = "4")]
        pub volume: ::core::option::Option<u32>,
        #[prost(float, optional, tag = "5")]
        pub delay_value: ::core::option::Option<f32>,
        #[prost(int32, optional, tag = "6")]
        pub sequence_number: ::core::option::Option<i32>,
        #[prost(int32, optional, tag = "7", default = "-1")]
        pub entity_index: ::core::option::Option<i32>,
        #[prost(int32, optional, tag = "8")]
        pub channel: ::core::option::Option<i32>,
        #[prost(int32, optional, tag = "9")]
        pub pitch: ::core::option::Option<i32>,
        #[prost(int32, optional, tag = "10")]
        pub flags: ::core::option::Option<i32>,
        #[prost(uint32, optional, tag = "11")]
        pub sound_num: ::core::option::Option<u32>,
        #[prost(fixed32, optional, tag = "12")]
        pub sound_num_handle: ::core::option::Option<u32>,
        #[prost(int32, optional, tag = "13")]
        pub speaker_entity: ::core::option::Option<i32>,
        #[prost(int32, optional, tag = "14")]
        pub random_seed: ::core::option::Option<i32>,
        #[prost(int32, optional, tag = "15")]
        pub sound_level: ::core::option::Option<i32>,
        #[prost(bool, optional, tag = "16")]
        pub is_sentence: ::core::option::Option<bool>,
        #[prost(bool, optional, tag = "17")]
        pub is_ambient: ::core::option::Option<bool>,
        #[prost(uint32, optional, tag = "18")]
        pub guid: ::core::option::Option<u32>,
        #[prost(fixed64, optional, tag = "19")]
        pub sound_resource_id: ::core::option::Option<u64>,
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CSvcMsgPrefetch {
    #[prost(int32, optional, tag = "1")]
    pub sound_index: ::core::option::Option<i32>,
    #[prost(
        enumeration = "PrefetchType",
        optional,
        tag = "2",
        default = "PftSound"
    )]
    pub resource_type: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CSvcMsgSetView {
    #[prost(int32, optional, tag = "1", default = "-1")]
    pub entity_index: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2", default = "-1")]
    pub slot: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CSvcMsgFixAngle {
    #[prost(bool, optional, tag = "1")]
    pub relative: ::core::option::Option<bool>,
    #[prost(message, optional, tag = "2")]
    pub angle: ::core::option::Option<CMsgQAngle>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CSvcMsgCrosshairAngle {
    #[prost(message, optional, tag = "1")]
    pub angle: ::core::option::Option<CMsgQAngle>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CSvcMsgBspDecal {
    #[prost(message, optional, tag = "1")]
    pub pos: ::core::option::Option<CMsgVector>,
    #[prost(int32, optional, tag = "2")]
    pub decal_texture_index: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3", default = "-1")]
    pub entity_index: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "4")]
    pub model_index: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "5")]
    pub low_priority: ::core::option::Option<bool>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CSvcMsgSplitScreen {
    #[prost(
        enumeration = "ESplitScreenMessageType",
        optional,
        tag = "1",
        default = "MsgSplitscreenAdduser"
    )]
    pub r#type: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub slot: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3", default = "-1")]
    pub player_index: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CSvcMsgGetCvarValue {
    #[prost(int32, optional, tag = "1")]
    pub cookie: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "2")]
    pub cvar_name: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CSvcMsgMenu {
    #[prost(int32, optional, tag = "1")]
    pub dialog_type: ::core::option::Option<i32>,
    #[prost(bytes = "vec", optional, tag = "2")]
    pub menu_key_values: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CSvcMsgUserMessage {
    #[prost(int32, optional, tag = "1")]
    pub msg_type: ::core::option::Option<i32>,
    #[prost(bytes = "vec", optional, tag = "2")]
    pub msg_data: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(int32, optional, tag = "3")]
    pub passthrough: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CSvcMsgSendTable {
    #[prost(bool, optional, tag = "1")]
    pub is_end: ::core::option::Option<bool>,
    #[prost(string, optional, tag = "2")]
    pub net_table_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "3")]
    pub needs_decoder: ::core::option::Option<bool>,
    #[prost(message, repeated, tag = "4")]
    pub props: ::prost::alloc::vec::Vec<csvc_msg_send_table::SendpropT>,
}
/// Nested message and enum types in `CSVCMsg_SendTable`.
pub mod csvc_msg_send_table {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SendpropT {
        #[prost(int32, optional, tag = "1")]
        pub r#type: ::core::option::Option<i32>,
        #[prost(string, optional, tag = "2")]
        pub var_name: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(int32, optional, tag = "3")]
        pub flags: ::core::option::Option<i32>,
        #[prost(int32, optional, tag = "4")]
        pub priority: ::core::option::Option<i32>,
        #[prost(string, optional, tag = "5")]
        pub dt_name: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(int32, optional, tag = "6")]
        pub num_elements: ::core::option::Option<i32>,
        #[prost(float, optional, tag = "7")]
        pub low_value: ::core::option::Option<f32>,
        #[prost(float, optional, tag = "8")]
        pub high_value: ::core::option::Option<f32>,
        #[prost(int32, optional, tag = "9")]
        pub num_bits: ::core::option::Option<i32>,
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CSvcMsgGameEventList {
    #[prost(message, repeated, tag = "1")]
    pub descriptors: ::prost::alloc::vec::Vec<csvc_msg_game_event_list::DescriptorT>,
}
/// Nested message and enum types in `CSVCMsg_GameEventList`.
pub mod csvc_msg_game_event_list {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct KeyT {
        #[prost(int32, optional, tag = "1")]
        pub r#type: ::core::option::Option<i32>,
        #[prost(string, optional, tag = "2")]
        pub name: ::core::option::Option<::prost::alloc::string::String>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DescriptorT {
        #[prost(int32, optional, tag = "1")]
        pub eventid: ::core::option::Option<i32>,
        #[prost(string, optional, tag = "2")]
        pub name: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(message, repeated, tag = "3")]
        pub keys: ::prost::alloc::vec::Vec<KeyT>,
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CSvcMsgPacketEntities {
    #[prost(int32, optional, tag = "1")]
    pub max_entries: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub updated_entries: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "3")]
    pub legacy_is_delta: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "4")]
    pub update_baseline: ::core::option::Option<bool>,
    #[prost(int32, optional, tag = "5")]
    pub baseline: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "6")]
    pub delta_from: ::core::option::Option<i32>,
    #[prost(bytes = "vec", optional, tag = "7")]
    pub entity_data: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bool, optional, tag = "8")]
    pub pending_full_frame: ::core::option::Option<bool>,
    #[prost(uint32, optional, tag = "9")]
    pub active_spawngroup_handle: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "10")]
    pub max_spawngroup_creationsequence: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "11")]
    pub last_cmd_number_executed: ::core::option::Option<u32>,
    #[prost(sint32, optional, tag = "17")]
    pub last_cmd_number_recv_delta: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "12")]
    pub server_tick: ::core::option::Option<u32>,
    #[prost(bytes = "vec", optional, tag = "13")]
    pub serialized_entities: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(message, optional, tag = "14")]
    pub command_queue_info: ::core::option::Option<csvc_msg_packet_entities::CommandQueueInfoT>,
    #[prost(message, repeated, tag = "15")]
    pub alternate_baselines: ::prost::alloc::vec::Vec<csvc_msg_packet_entities::AlternateBaselineT>,
    #[prost(uint32, optional, tag = "16")]
    pub has_pvs_vis_bits: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "18")]
    pub last_cmd_recv_margin: ::core::option::Option<u32>,
    #[prost(message, optional, tag = "19")]
    pub non_transmitted_entities:
        ::core::option::Option<csvc_msg_packet_entities::NonTransmittedEntitiesT>,
    #[prost(bytes = "vec", optional, tag = "999")]
    pub dev_padding: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
/// Nested message and enum types in `CSVCMsg_PacketEntities`.
pub mod csvc_msg_packet_entities {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct CommandQueueInfoT {
        #[prost(uint32, optional, tag = "1")]
        pub commands_queued: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "3")]
        pub starved_command_ticks: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "5")]
        pub discarded_command_ticks: ::core::option::Option<u32>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct AlternateBaselineT {
        #[prost(int32, optional, tag = "1")]
        pub entity_index: ::core::option::Option<i32>,
        #[prost(int32, optional, tag = "2")]
        pub baseline_index: ::core::option::Option<i32>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct NonTransmittedEntitiesT {
        #[prost(int32, optional, tag = "1")]
        pub header_count: ::core::option::Option<i32>,
        #[prost(bytes = "vec", optional, tag = "2")]
        pub data: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CSvcMsgTempEntities {
    #[prost(bool, optional, tag = "1")]
    pub reliable: ::core::option::Option<bool>,
    #[prost(int32, optional, tag = "2")]
    pub num_entries: ::core::option::Option<i32>,
    #[prost(bytes = "vec", optional, tag = "3")]
    pub entity_data: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CSvcMsgCreateStringTable {
    #[prost(string, optional, tag = "1")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "2")]
    pub num_entries: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "3")]
    pub user_data_fixed_size: ::core::option::Option<bool>,
    #[prost(int32, optional, tag = "4")]
    pub user_data_size: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "5")]
    pub user_data_size_bits: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "6")]
    pub flags: ::core::option::Option<i32>,
    #[prost(bytes = "vec", optional, tag = "7")]
    pub string_data: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(int32, optional, tag = "8")]
    pub uncompressed_size: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "9")]
    pub data_compressed: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "10")]
    pub using_varint_bitcounts: ::core::option::Option<bool>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CSvcMsgUpdateStringTable {
    #[prost(int32, optional, tag = "1")]
    pub table_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub num_changed_entries: ::core::option::Option<i32>,
    #[prost(bytes = "vec", optional, tag = "3")]
    pub string_data: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CSvcMsgVoiceData {
    #[prost(message, optional, tag = "1")]
    pub audio: ::core::option::Option<CMsgVoiceAudio>,
    #[prost(int32, optional, tag = "2", default = "-1")]
    pub client: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "3")]
    pub proximity: ::core::option::Option<bool>,
    #[prost(fixed64, optional, tag = "4")]
    pub xuid: ::core::option::Option<u64>,
    #[prost(int32, optional, tag = "5")]
    pub audible_mask: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "6")]
    pub tick: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "7")]
    pub passthrough: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CSvcMsgPacketReliable {
    #[prost(int32, optional, tag = "1")]
    pub tick: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub messagessize: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "3")]
    pub state: ::core::option::Option<bool>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CSvcMsgFullFrameSplit {
    #[prost(int32, optional, tag = "1")]
    pub tick: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub section: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub total: ::core::option::Option<i32>,
    #[prost(bytes = "vec", optional, tag = "4")]
    pub data: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CSvcMsgHltvStatus {
    #[prost(string, optional, tag = "1")]
    pub master: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "2")]
    pub clients: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub slots: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "4")]
    pub proxies: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CSvcMsgServerSteamId {
    #[prost(uint64, optional, tag = "1")]
    pub steam_id: ::core::option::Option<u64>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CSvcMsgCmdKeyValues {
    #[prost(bytes = "vec", optional, tag = "1")]
    pub data: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CSvcMsgRconServerDetails {
    #[prost(bytes = "vec", optional, tag = "1")]
    pub token: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(string, optional, tag = "2")]
    pub details: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgIpcAddress {
    #[prost(fixed64, optional, tag = "1")]
    pub computer_guid: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "2")]
    pub process_id: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgServerPeer {
    #[prost(int32, optional, tag = "1", default = "-1")]
    pub player_slot: ::core::option::Option<i32>,
    #[prost(fixed64, optional, tag = "2")]
    pub steamid: ::core::option::Option<u64>,
    #[prost(message, optional, tag = "3")]
    pub ipc: ::core::option::Option<CMsgIpcAddress>,
    #[prost(bool, optional, tag = "4")]
    pub they_hear_you: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "5")]
    pub you_hear_them: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "6")]
    pub is_listenserver_host: ::core::option::Option<bool>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CSvcMsgPeerList {
    #[prost(message, repeated, tag = "1")]
    pub peer: ::prost::alloc::vec::Vec<CMsgServerPeer>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CSvcMsgClearAllStringTables {
    #[prost(string, optional, tag = "1")]
    pub mapname: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "3")]
    pub create_tables_skipped: ::core::option::Option<bool>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProtoFlattenedSerializerFieldT {
    #[prost(int32, optional, tag = "1")]
    pub var_type_sym: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub var_name_sym: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub bit_count: ::core::option::Option<i32>,
    #[prost(float, optional, tag = "4")]
    pub low_value: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "5")]
    pub high_value: ::core::option::Option<f32>,
    #[prost(int32, optional, tag = "6")]
    pub encode_flags: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "7")]
    pub field_serializer_name_sym: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "8")]
    pub field_serializer_version: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "9")]
    pub send_node_sym: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "10")]
    pub var_encoder_sym: ::core::option::Option<i32>,
    #[prost(message, repeated, tag = "11")]
    pub polymorphic_types:
        ::prost::alloc::vec::Vec<proto_flattened_serializer_field_t::PolymorphicFieldT>,
    #[prost(int32, optional, tag = "12")]
    pub var_serializer_sym: ::core::option::Option<i32>,
}
/// Nested message and enum types in `ProtoFlattenedSerializerField_t`.
pub mod proto_flattened_serializer_field_t {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct PolymorphicFieldT {
        #[prost(int32, optional, tag = "1")]
        pub polymorphic_field_serializer_name_sym: ::core::option::Option<i32>,
        #[prost(int32, optional, tag = "2")]
        pub polymorphic_field_serializer_version: ::core::option::Option<i32>,
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProtoFlattenedSerializerT {
    #[prost(int32, optional, tag = "1")]
    pub serializer_name_sym: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub serializer_version: ::core::option::Option<i32>,
    #[prost(int32, repeated, packed = "false", tag = "3")]
    pub fields_index: ::prost::alloc::vec::Vec<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CSvcMsgFlattenedSerializer {
    #[prost(message, repeated, tag = "1")]
    pub serializers: ::prost::alloc::vec::Vec<ProtoFlattenedSerializerT>,
    #[prost(string, repeated, tag = "2")]
    pub symbols: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "3")]
    pub fields: ::prost::alloc::vec::Vec<ProtoFlattenedSerializerFieldT>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CSvcMsgStopSound {
    #[prost(fixed32, optional, tag = "1")]
    pub guid: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CBidirMsgRebroadcastGameEvent {
    #[prost(bool, optional, tag = "1")]
    pub posttoserver: ::core::option::Option<bool>,
    #[prost(int32, optional, tag = "2")]
    pub buftype: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "3")]
    pub clientbitcount: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "4")]
    pub receivingclients: ::core::option::Option<u64>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CBidirMsgRebroadcastSource {
    #[prost(int32, optional, tag = "1")]
    pub eventsource: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgServerNetworkStats {
    #[prost(bool, optional, tag = "1")]
    pub dedicated: ::core::option::Option<bool>,
    #[prost(int32, optional, tag = "2")]
    pub cpu_usage: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub memory_used_mb: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "4")]
    pub memory_free_mb: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "5")]
    pub uptime: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "6")]
    pub spawn_count: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "8")]
    pub num_clients: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "9")]
    pub num_bots: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "10")]
    pub num_spectators: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "11")]
    pub num_tv_relays: ::core::option::Option<i32>,
    #[prost(float, optional, tag = "12")]
    pub fps: ::core::option::Option<f32>,
    #[prost(message, repeated, tag = "17")]
    pub ports: ::prost::alloc::vec::Vec<c_msg_server_network_stats::Port>,
    #[prost(float, optional, tag = "18")]
    pub avg_ping_ms: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "19")]
    pub avg_engine_latency_out: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "20")]
    pub avg_packets_out: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "21")]
    pub avg_packets_in: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "22")]
    pub avg_loss_out: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "23")]
    pub avg_loss_in: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "24")]
    pub avg_data_out: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "25")]
    pub avg_data_in: ::core::option::Option<f32>,
    #[prost(uint64, optional, tag = "26")]
    pub total_data_in: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "27")]
    pub total_packets_in: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "28")]
    pub total_data_out: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "29")]
    pub total_packets_out: ::core::option::Option<u64>,
    #[prost(message, repeated, tag = "30")]
    pub players: ::prost::alloc::vec::Vec<c_msg_server_network_stats::Player>,
}
/// Nested message and enum types in `CMsgServerNetworkStats`.
pub mod c_msg_server_network_stats {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Port {
        #[prost(int32, optional, tag = "1")]
        pub port: ::core::option::Option<i32>,
        #[prost(string, optional, tag = "2")]
        pub name: ::core::option::Option<::prost::alloc::string::String>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Player {
        #[prost(uint64, optional, tag = "1")]
        pub steamid: ::core::option::Option<u64>,
        #[prost(string, optional, tag = "2")]
        pub remote_addr: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(int32, optional, tag = "4")]
        pub ping_avg_ms: ::core::option::Option<i32>,
        #[prost(float, optional, tag = "5")]
        pub packet_loss_pct: ::core::option::Option<f32>,
        #[prost(bool, optional, tag = "6")]
        pub is_bot: ::core::option::Option<bool>,
        #[prost(float, optional, tag = "7")]
        pub loss_in: ::core::option::Option<f32>,
        #[prost(float, optional, tag = "8")]
        pub loss_out: ::core::option::Option<f32>,
        #[prost(int32, optional, tag = "9")]
        pub engine_latency_ms: ::core::option::Option<i32>,
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CSvcMsgHltvReplay {
    #[prost(int32, optional, tag = "1")]
    pub delay: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2", default = "-1")]
    pub primary_target: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub replay_stop_at: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "4")]
    pub replay_start_at: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "5")]
    pub replay_slowdown_begin: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "6")]
    pub replay_slowdown_end: ::core::option::Option<i32>,
    #[prost(float, optional, tag = "7")]
    pub replay_slowdown_rate: ::core::option::Option<f32>,
    #[prost(int32, optional, tag = "8")]
    pub reason: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CClcMsgHltvReplay {
    #[prost(int32, optional, tag = "1")]
    pub request: ::core::option::Option<i32>,
    #[prost(float, optional, tag = "2")]
    pub slowdown_length: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "3")]
    pub slowdown_rate: ::core::option::Option<f32>,
    #[prost(int32, optional, tag = "4", default = "-1")]
    pub primary_target: ::core::option::Option<i32>,
    #[prost(float, optional, tag = "5")]
    pub event_time: ::core::option::Option<f32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CSvcMsgBroadcastCommand {
    #[prost(string, optional, tag = "1")]
    pub cmd: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CClcMsgHltvFixupOperatorTick {
    #[prost(int32, optional, tag = "1")]
    pub tick: ::core::option::Option<i32>,
    #[prost(bytes = "vec", optional, tag = "2")]
    pub props_data: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(message, optional, tag = "3")]
    pub origin: ::core::option::Option<CMsgVector>,
    #[prost(message, optional, tag = "4")]
    pub eye_angles: ::core::option::Option<CMsgQAngle>,
    #[prost(int32, optional, tag = "5")]
    pub observer_mode: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "6")]
    pub cameraman_scoreboard: ::core::option::Option<bool>,
    #[prost(int32, optional, tag = "7")]
    pub observer_target: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "8")]
    pub view_offset: ::core::option::Option<CMsgVector>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CSvcMsgHltvFixupOperatorStatus {
    #[prost(uint32, optional, tag = "1")]
    pub mode: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "2")]
    pub override_operator_name: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum ClcMessages {
    ClcClientInfo = 20,
    ClcMove = 21,
    ClcVoiceData = 22,
    ClcBaselineAck = 23,
    ClcListenEvents = 24,
    ClcRespondCvarValue = 25,
    ClcFileCrcCheck = 26,
    ClcLoadingProgress = 27,
    ClcSplitPlayerConnect = 28,
    ClcClientMessage = 29,
    ClcSplitPlayerDisconnect = 30,
    ClcServerStatus = 31,
    ClcServerPing = 32,
    ClcRequestPause = 33,
    ClcCmdKeyValues = 34,
    ClcRconServerDetails = 35,
    ClcHltvReplay = 36,
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum SvcMessages {
    SvcServerInfo = 40,
    SvcFlattenedSerializer = 41,
    SvcClassInfo = 42,
    SvcSetPause = 43,
    SvcCreateStringTable = 44,
    SvcUpdateStringTable = 45,
    SvcVoiceInit = 46,
    SvcVoiceData = 47,
    SvcPrint = 48,
    SvcSounds = 49,
    SvcSetView = 50,
    SvcClearAllStringTables = 51,
    SvcCmdKeyValues = 52,
    SvcBspDecal = 53,
    SvcSplitScreen = 54,
    SvcPacketEntities = 55,
    SvcPrefetch = 56,
    SvcMenu = 57,
    SvcGetCvarValue = 58,
    SvcStopSound = 59,
    SvcPeerList = 60,
    SvcPacketReliable = 61,
    SvcHltvStatus = 62,
    SvcServerSteamId = 63,
    SvcFullFrameSplit = 70,
    SvcRconServerDetails = 71,
    SvcUserMessage = 72,
    SvcHltvReplay = 73,
    SvcBroadcastCommand = 74,
    SvcHltvFixupOperatorStatus = 75,
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum VoiceDataFormatT {
    VoicedataFormatSteam = 0,
    VoicedataFormatEngine = 1,
    VoicedataFormatOpus = 2,
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum RequestPauseT {
    RpPause = 0,
    RpUnpause = 1,
    RpTogglepause = 2,
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum PrefetchType {
    PftSound = 0,
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum ESplitScreenMessageType {
    MsgSplitscreenAdduser = 0,
    MsgSplitscreenRemoveuser = 1,
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum EQueryCvarValueStatus {
    ValueIntact = 0,
    CvarNotFound = 1,
    NotACvar = 2,
    CvarProtected = 3,
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum DialogType {
    DialogMsg = 0,
    DialogMenu = 1,
    DialogText = 2,
    DialogEntry = 3,
    DialogAskconnect = 4,
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum SvcMessagesLowFrequency {
    SvcDummy = 600,
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum BidirectionalMessages {
    BiRebroadcastGameEvent = 16,
    BiRebroadcastSource = 17,
    BiGameEvent = 18,
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum BidirectionalMessagesLowFrequency {
    BiRelayInfo = 700,
    BiRelayPacket = 701,
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum ReplayEventTypeT {
    ReplayEventCancel = 0,
    ReplayEventDeath = 1,
    ReplayEventGeneric = 2,
    ReplayEventStuckNeedFullUpdate = 3,
    ReplayEventVictory = 4,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CUserMessageAchievementEvent {
    #[prost(uint32, optional, tag = "1")]
    pub achievement: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CUserMessageCloseCaption {
    #[prost(fixed32, optional, tag = "1")]
    pub hash: ::core::option::Option<u32>,
    #[prost(float, optional, tag = "2")]
    pub duration: ::core::option::Option<f32>,
    #[prost(bool, optional, tag = "3")]
    pub from_player: ::core::option::Option<bool>,
    #[prost(int32, optional, tag = "4", default = "-1")]
    pub ent_index: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CUserMessageCloseCaptionDirect {
    #[prost(fixed32, optional, tag = "1")]
    pub hash: ::core::option::Option<u32>,
    #[prost(float, optional, tag = "2")]
    pub duration: ::core::option::Option<f32>,
    #[prost(bool, optional, tag = "3")]
    pub from_player: ::core::option::Option<bool>,
    #[prost(int32, optional, tag = "4", default = "-1")]
    pub ent_index: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CUserMessageCloseCaptionPlaceholder {
    #[prost(string, optional, tag = "1")]
    pub string: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(float, optional, tag = "2")]
    pub duration: ::core::option::Option<f32>,
    #[prost(bool, optional, tag = "3")]
    pub from_player: ::core::option::Option<bool>,
    #[prost(int32, optional, tag = "4", default = "-1")]
    pub ent_index: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CUserMessageCurrentTimescale {
    #[prost(float, optional, tag = "1")]
    pub current: ::core::option::Option<f32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CUserMessageDesiredTimescale {
    #[prost(float, optional, tag = "1")]
    pub desired: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "2")]
    pub acceleration: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "3")]
    pub minblendrate: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "4")]
    pub blenddeltamultiplier: ::core::option::Option<f32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CUserMessageFade {
    #[prost(uint32, optional, tag = "1")]
    pub duration: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub hold_time: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub flags: ::core::option::Option<u32>,
    #[prost(fixed32, optional, tag = "4")]
    pub color: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CUserMessageShake {
    #[prost(uint32, optional, tag = "1")]
    pub command: ::core::option::Option<u32>,
    #[prost(float, optional, tag = "2")]
    pub amplitude: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "3")]
    pub frequency: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "4")]
    pub duration: ::core::option::Option<f32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CUserMessageShakeDir {
    #[prost(message, optional, tag = "1")]
    pub shake: ::core::option::Option<CUserMessageShake>,
    #[prost(message, optional, tag = "2")]
    pub direction: ::core::option::Option<CMsgVector>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CUserMessageWaterShake {
    #[prost(uint32, optional, tag = "1")]
    pub command: ::core::option::Option<u32>,
    #[prost(float, optional, tag = "2")]
    pub amplitude: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "3")]
    pub frequency: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "4")]
    pub duration: ::core::option::Option<f32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CUserMessageScreenTilt {
    #[prost(uint32, optional, tag = "1")]
    pub command: ::core::option::Option<u32>,
    #[prost(bool, optional, tag = "2")]
    pub ease_in_out: ::core::option::Option<bool>,
    #[prost(message, optional, tag = "3")]
    pub angle: ::core::option::Option<CMsgVector>,
    #[prost(float, optional, tag = "4")]
    pub duration: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "5")]
    pub time: ::core::option::Option<f32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CUserMessageSayText {
    #[prost(int32, optional, tag = "1", default = "-1")]
    pub playerindex: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "2")]
    pub text: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "3")]
    pub chat: ::core::option::Option<bool>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CUserMessageSayText2 {
    #[prost(int32, optional, tag = "1", default = "-1")]
    pub entityindex: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "2")]
    pub chat: ::core::option::Option<bool>,
    #[prost(string, optional, tag = "3")]
    pub messagename: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "4")]
    pub param1: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "5")]
    pub param2: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "6")]
    pub param3: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "7")]
    pub param4: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CUserMessageHudMsg {
    #[prost(uint32, optional, tag = "1")]
    pub channel: ::core::option::Option<u32>,
    #[prost(float, optional, tag = "2")]
    pub x: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "3")]
    pub y: ::core::option::Option<f32>,
    #[prost(fixed32, optional, tag = "4")]
    pub color1: ::core::option::Option<u32>,
    #[prost(fixed32, optional, tag = "5")]
    pub color2: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "6")]
    pub effect: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "11")]
    pub message: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CUserMessageHudText {
    #[prost(string, optional, tag = "1")]
    pub message: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CUserMessageTextMsg {
    #[prost(uint32, optional, tag = "1")]
    pub dest: ::core::option::Option<u32>,
    #[prost(string, repeated, tag = "2")]
    pub param: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CUserMessageGameTitle {}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CUserMessageResetHud {}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CUserMessageSendAudio {
    #[prost(string, optional, tag = "1")]
    pub soundname: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "2")]
    pub stop: ::core::option::Option<bool>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CUserMessageAudioParameter {
    #[prost(uint32, optional, tag = "1")]
    pub parameter_type: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub name_hash_code: ::core::option::Option<u32>,
    #[prost(float, optional, tag = "3")]
    pub value: ::core::option::Option<f32>,
    #[prost(uint32, optional, tag = "4")]
    pub int_value: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CUserMessageVoiceMask {
    #[prost(uint32, repeated, packed = "false", tag = "1")]
    pub gamerules_masks: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, packed = "false", tag = "2")]
    pub ban_masks: ::prost::alloc::vec::Vec<u32>,
    #[prost(bool, optional, tag = "3")]
    pub mod_enable: ::core::option::Option<bool>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CUserMessageRequestState {}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CUserMessageRumble {
    #[prost(int32, optional, tag = "1")]
    pub index: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub data: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub flags: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CUserMessageSayTextChannel {
    #[prost(int32, optional, tag = "1")]
    pub player: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub channel: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "3")]
    pub text: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CUserMessageColoredText {
    #[prost(uint32, optional, tag = "1")]
    pub color: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "2")]
    pub text: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "3")]
    pub reset: ::core::option::Option<bool>,
    #[prost(int32, optional, tag = "4", default = "-1")]
    pub context_player_slot: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "5")]
    pub context_value: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "6")]
    pub context_team_id: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CUserMessageItemPickup {
    #[prost(string, optional, tag = "1")]
    pub itemname: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CUserMessageAmmoDenied {
    #[prost(uint32, optional, tag = "1")]
    pub ammo_id: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CUserMessageShowMenu {
    #[prost(uint32, optional, tag = "1")]
    pub validslots: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub displaytime: ::core::option::Option<u32>,
    #[prost(bool, optional, tag = "3")]
    pub needmore: ::core::option::Option<bool>,
    #[prost(string, optional, tag = "4")]
    pub menustring: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CUserMessageCreditsMsg {
    #[prost(enumeration = "ERollType", optional, tag = "1", default = "RollNone")]
    pub rolltype: ::core::option::Option<i32>,
    #[prost(float, optional, tag = "2")]
    pub logo_length: ::core::option::Option<f32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CEntityMessagePlayJingle {
    #[prost(message, optional, tag = "1")]
    pub entity_msg: ::core::option::Option<CEntityMsg>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CEntityMessageScreenOverlay {
    #[prost(bool, optional, tag = "1")]
    pub start_effect: ::core::option::Option<bool>,
    #[prost(message, optional, tag = "2")]
    pub entity_msg: ::core::option::Option<CEntityMsg>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CEntityMessageRemoveAllDecals {
    #[prost(bool, optional, tag = "1")]
    pub remove_decals: ::core::option::Option<bool>,
    #[prost(message, optional, tag = "2")]
    pub entity_msg: ::core::option::Option<CEntityMsg>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CEntityMessagePropagateForce {
    #[prost(message, optional, tag = "1")]
    pub impulse: ::core::option::Option<CMsgVector>,
    #[prost(message, optional, tag = "2")]
    pub entity_msg: ::core::option::Option<CEntityMsg>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CEntityMessageDoSpark {
    #[prost(message, optional, tag = "1")]
    pub origin: ::core::option::Option<CMsgVector>,
    #[prost(int32, optional, tag = "2", default = "-1")]
    pub entityindex: ::core::option::Option<i32>,
    #[prost(float, optional, tag = "3")]
    pub radius: ::core::option::Option<f32>,
    #[prost(fixed32, optional, tag = "4")]
    pub color: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "5")]
    pub beams: ::core::option::Option<u32>,
    #[prost(float, optional, tag = "6")]
    pub thick: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "7")]
    pub duration: ::core::option::Option<f32>,
    #[prost(message, optional, tag = "8")]
    pub entity_msg: ::core::option::Option<CEntityMsg>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CEntityMessageFixAngle {
    #[prost(bool, optional, tag = "1")]
    pub relative: ::core::option::Option<bool>,
    #[prost(message, optional, tag = "2")]
    pub angle: ::core::option::Option<CMsgQAngle>,
    #[prost(message, optional, tag = "3")]
    pub entity_msg: ::core::option::Option<CEntityMsg>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CUserMessageCameraTransition {
    #[prost(uint32, optional, tag = "1")]
    pub camera_type: ::core::option::Option<u32>,
    #[prost(float, optional, tag = "2")]
    pub duration: ::core::option::Option<f32>,
    #[prost(message, optional, tag = "3")]
    pub params_data_driven:
        ::core::option::Option<c_user_message_camera_transition::TransitionDataDriven>,
}
/// Nested message and enum types in `CUserMessageCameraTransition`.
pub mod c_user_message_camera_transition {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TransitionDataDriven {
        #[prost(string, optional, tag = "1")]
        pub filename: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(int32, optional, tag = "2", default = "-1")]
        pub attach_ent_index: ::core::option::Option<i32>,
        #[prost(float, optional, tag = "3")]
        pub duration: ::core::option::Option<f32>,
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CUserMsgParticleManager {
    #[prost(
        enumeration = "ParticleMessage",
        required,
        tag = "1",
        default = "GameParticleManagerEventCreate"
    )]
    pub r#type: i32,
    #[prost(uint32, required, tag = "2")]
    pub index: u32,
    #[prost(message, optional, tag = "3")]
    pub release_particle_index:
        ::core::option::Option<c_user_msg_particle_manager::ReleaseParticleIndex>,
    #[prost(message, optional, tag = "4")]
    pub create_particle: ::core::option::Option<c_user_msg_particle_manager::CreateParticle>,
    #[prost(message, optional, tag = "5")]
    pub destroy_particle: ::core::option::Option<c_user_msg_particle_manager::DestroyParticle>,
    #[prost(message, optional, tag = "6")]
    pub destroy_particle_involving:
        ::core::option::Option<c_user_msg_particle_manager::DestroyParticleInvolving>,
    #[prost(message, optional, tag = "7")]
    pub update_particle:
        ::core::option::Option<c_user_msg_particle_manager::UpdateParticleObsolete>,
    #[prost(message, optional, tag = "8")]
    pub update_particle_fwd:
        ::core::option::Option<c_user_msg_particle_manager::UpdateParticleFwdObsolete>,
    #[prost(message, optional, tag = "9")]
    pub update_particle_orient:
        ::core::option::Option<c_user_msg_particle_manager::UpdateParticleOrientObsolete>,
    #[prost(message, optional, tag = "10")]
    pub update_particle_fallback:
        ::core::option::Option<c_user_msg_particle_manager::UpdateParticleFallback>,
    #[prost(message, optional, tag = "11")]
    pub update_particle_offset:
        ::core::option::Option<c_user_msg_particle_manager::UpdateParticleOffset>,
    #[prost(message, optional, tag = "12")]
    pub update_particle_ent: ::core::option::Option<c_user_msg_particle_manager::UpdateParticleEnt>,
    #[prost(message, optional, tag = "14")]
    pub update_particle_should_draw:
        ::core::option::Option<c_user_msg_particle_manager::UpdateParticleShouldDraw>,
    #[prost(message, optional, tag = "15")]
    pub update_particle_set_frozen:
        ::core::option::Option<c_user_msg_particle_manager::UpdateParticleSetFrozen>,
    #[prost(message, optional, tag = "16")]
    pub change_control_point_attachment:
        ::core::option::Option<c_user_msg_particle_manager::ChangeControlPointAttachment>,
    #[prost(message, optional, tag = "17")]
    pub update_entity_position:
        ::core::option::Option<c_user_msg_particle_manager::UpdateEntityPosition>,
    #[prost(message, optional, tag = "18")]
    pub set_particle_fow_properties:
        ::core::option::Option<c_user_msg_particle_manager::SetParticleFoWProperties>,
    #[prost(message, optional, tag = "19")]
    pub set_particle_text: ::core::option::Option<c_user_msg_particle_manager::SetParticleText>,
    #[prost(message, optional, tag = "20")]
    pub set_particle_should_check_fow:
        ::core::option::Option<c_user_msg_particle_manager::SetParticleShouldCheckFoW>,
    #[prost(message, optional, tag = "21")]
    pub set_control_point_model:
        ::core::option::Option<c_user_msg_particle_manager::SetControlPointModel>,
    #[prost(message, optional, tag = "22")]
    pub set_control_point_snapshot:
        ::core::option::Option<c_user_msg_particle_manager::SetControlPointSnapshot>,
    #[prost(message, optional, tag = "23")]
    pub set_texture_attribute:
        ::core::option::Option<c_user_msg_particle_manager::SetTextureAttribute>,
    #[prost(message, optional, tag = "24")]
    pub set_scene_object_generic_flag:
        ::core::option::Option<c_user_msg_particle_manager::SetSceneObjectGenericFlag>,
    #[prost(message, optional, tag = "25")]
    pub set_scene_object_tint_and_desat:
        ::core::option::Option<c_user_msg_particle_manager::SetSceneObjectTintAndDesat>,
    #[prost(message, optional, tag = "26")]
    pub destroy_particle_named:
        ::core::option::Option<c_user_msg_particle_manager::DestroyParticleNamed>,
    #[prost(message, optional, tag = "27")]
    pub particle_skip_to_time:
        ::core::option::Option<c_user_msg_particle_manager::ParticleSkipToTime>,
    #[prost(message, optional, tag = "28")]
    pub particle_can_freeze: ::core::option::Option<c_user_msg_particle_manager::ParticleCanFreeze>,
    #[prost(message, optional, tag = "29")]
    pub set_named_value_context:
        ::core::option::Option<c_user_msg_particle_manager::SetParticleNamedValueContext>,
    #[prost(message, optional, tag = "30")]
    pub update_particle_transform:
        ::core::option::Option<c_user_msg_particle_manager::UpdateParticleTransform>,
    #[prost(message, optional, tag = "31")]
    pub particle_freeze_transition_override:
        ::core::option::Option<c_user_msg_particle_manager::ParticleFreezeTransitionOverride>,
    #[prost(message, optional, tag = "32")]
    pub freeze_particle_involving:
        ::core::option::Option<c_user_msg_particle_manager::FreezeParticleInvolving>,
    #[prost(message, optional, tag = "33")]
    pub add_modellist_override_element:
        ::core::option::Option<c_user_msg_particle_manager::AddModellistOverrideElement>,
    #[prost(message, optional, tag = "34")]
    pub clear_modellist_override:
        ::core::option::Option<c_user_msg_particle_manager::ClearModellistOverride>,
    #[prost(message, optional, tag = "35")]
    pub create_physics_sim: ::core::option::Option<c_user_msg_particle_manager::CreatePhysicsSim>,
    #[prost(message, optional, tag = "36")]
    pub destroy_physics_sim: ::core::option::Option<c_user_msg_particle_manager::DestroyPhysicsSim>,
}
/// Nested message and enum types in `CUserMsg_ParticleManager`.
pub mod c_user_msg_particle_manager {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct ReleaseParticleIndex {}
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CreateParticle {
        #[prost(fixed64, optional, tag = "1")]
        pub particle_name_index: ::core::option::Option<u64>,
        #[prost(int32, optional, tag = "2")]
        pub attach_type: ::core::option::Option<i32>,
        #[prost(uint32, optional, tag = "3", default = "16777215")]
        pub entity_handle: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "4", default = "16777215")]
        pub entity_handle_for_modifiers: ::core::option::Option<u32>,
        #[prost(bool, optional, tag = "5")]
        pub apply_voice_ban_rules: ::core::option::Option<bool>,
        #[prost(int32, optional, tag = "6")]
        pub team_behavior: ::core::option::Option<i32>,
        #[prost(string, optional, tag = "7")]
        pub control_point_configuration: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(bool, optional, tag = "8")]
        pub cluster: ::core::option::Option<bool>,
        #[prost(float, optional, tag = "9")]
        pub endcap_time: ::core::option::Option<f32>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct DestroyParticle {
        #[prost(bool, optional, tag = "1")]
        pub destroy_immediately: ::core::option::Option<bool>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct DestroyParticleInvolving {
        #[prost(bool, optional, tag = "1")]
        pub destroy_immediately: ::core::option::Option<bool>,
        #[prost(uint32, optional, tag = "3", default = "16777215")]
        pub entity_handle: ::core::option::Option<u32>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct DestroyParticleNamed {
        #[prost(fixed64, optional, tag = "1")]
        pub particle_name_index: ::core::option::Option<u64>,
        #[prost(uint32, optional, tag = "2", default = "16777215")]
        pub entity_handle: ::core::option::Option<u32>,
        #[prost(bool, optional, tag = "3")]
        pub destroy_immediately: ::core::option::Option<bool>,
        #[prost(bool, optional, tag = "4")]
        pub play_endcap: ::core::option::Option<bool>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct UpdateParticleObsolete {
        #[prost(int32, optional, tag = "1")]
        pub control_point: ::core::option::Option<i32>,
        #[prost(message, optional, tag = "2")]
        pub position: ::core::option::Option<super::CMsgVector>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct UpdateParticleFwdObsolete {
        #[prost(int32, optional, tag = "1")]
        pub control_point: ::core::option::Option<i32>,
        #[prost(message, optional, tag = "2")]
        pub forward: ::core::option::Option<super::CMsgVector>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct UpdateParticleOrientObsolete {
        #[prost(int32, optional, tag = "1")]
        pub control_point: ::core::option::Option<i32>,
        #[prost(message, optional, tag = "2")]
        pub forward: ::core::option::Option<super::CMsgVector>,
        #[prost(message, optional, tag = "3")]
        pub deprecated_right: ::core::option::Option<super::CMsgVector>,
        #[prost(message, optional, tag = "4")]
        pub up: ::core::option::Option<super::CMsgVector>,
        #[prost(message, optional, tag = "5")]
        pub left: ::core::option::Option<super::CMsgVector>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct UpdateParticleTransform {
        #[prost(int32, optional, tag = "1")]
        pub control_point: ::core::option::Option<i32>,
        #[prost(message, optional, tag = "2")]
        pub position: ::core::option::Option<super::CMsgVector>,
        #[prost(message, optional, tag = "3")]
        pub orientation: ::core::option::Option<super::CMsgQuaternion>,
        #[prost(float, optional, tag = "4")]
        pub interpolation_interval: ::core::option::Option<f32>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct UpdateParticleFallback {
        #[prost(int32, optional, tag = "1")]
        pub control_point: ::core::option::Option<i32>,
        #[prost(message, optional, tag = "2")]
        pub position: ::core::option::Option<super::CMsgVector>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct UpdateParticleOffset {
        #[prost(int32, optional, tag = "1")]
        pub control_point: ::core::option::Option<i32>,
        #[prost(message, optional, tag = "2")]
        pub origin_offset: ::core::option::Option<super::CMsgVector>,
        #[prost(message, optional, tag = "3")]
        pub angle_offset: ::core::option::Option<super::CMsgQAngle>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct UpdateParticleEnt {
        #[prost(int32, optional, tag = "1")]
        pub control_point: ::core::option::Option<i32>,
        #[prost(uint32, optional, tag = "2", default = "16777215")]
        pub entity_handle: ::core::option::Option<u32>,
        #[prost(int32, optional, tag = "3")]
        pub attach_type: ::core::option::Option<i32>,
        #[prost(int32, optional, tag = "4")]
        pub attachment: ::core::option::Option<i32>,
        #[prost(message, optional, tag = "5")]
        pub fallback_position: ::core::option::Option<super::CMsgVector>,
        #[prost(bool, optional, tag = "6")]
        pub include_wearables: ::core::option::Option<bool>,
        #[prost(message, optional, tag = "7")]
        pub offset_position: ::core::option::Option<super::CMsgVector>,
        #[prost(message, optional, tag = "8")]
        pub offset_angles: ::core::option::Option<super::CMsgQAngle>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct UpdateParticleSetFrozen {
        #[prost(bool, optional, tag = "1")]
        pub set_frozen: ::core::option::Option<bool>,
        #[prost(float, optional, tag = "2")]
        pub transition_duration: ::core::option::Option<f32>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct UpdateParticleShouldDraw {
        #[prost(bool, optional, tag = "1")]
        pub should_draw: ::core::option::Option<bool>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct ChangeControlPointAttachment {
        #[prost(int32, optional, tag = "1")]
        pub attachment_old: ::core::option::Option<i32>,
        #[prost(int32, optional, tag = "2")]
        pub attachment_new: ::core::option::Option<i32>,
        #[prost(uint32, optional, tag = "3", default = "16777215")]
        pub entity_handle: ::core::option::Option<u32>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct UpdateEntityPosition {
        #[prost(uint32, optional, tag = "1", default = "16777215")]
        pub entity_handle: ::core::option::Option<u32>,
        #[prost(message, optional, tag = "2")]
        pub position: ::core::option::Option<super::CMsgVector>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct SetParticleFoWProperties {
        #[prost(int32, optional, tag = "1")]
        pub fow_control_point: ::core::option::Option<i32>,
        #[prost(int32, optional, tag = "2")]
        pub fow_control_point2: ::core::option::Option<i32>,
        #[prost(float, optional, tag = "3")]
        pub fow_radius: ::core::option::Option<f32>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct SetParticleShouldCheckFoW {
        #[prost(bool, optional, tag = "1")]
        pub check_fow: ::core::option::Option<bool>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SetControlPointModel {
        #[prost(int32, optional, tag = "1")]
        pub control_point: ::core::option::Option<i32>,
        #[prost(string, optional, tag = "2")]
        pub model_name: ::core::option::Option<::prost::alloc::string::String>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SetControlPointSnapshot {
        #[prost(int32, optional, tag = "1")]
        pub control_point: ::core::option::Option<i32>,
        #[prost(string, optional, tag = "2")]
        pub snapshot_name: ::core::option::Option<::prost::alloc::string::String>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SetParticleText {
        #[prost(string, optional, tag = "1")]
        pub text: ::core::option::Option<::prost::alloc::string::String>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SetTextureAttribute {
        #[prost(string, optional, tag = "1")]
        pub attribute_name: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag = "2")]
        pub texture_name: ::core::option::Option<::prost::alloc::string::String>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct SetSceneObjectGenericFlag {
        #[prost(bool, optional, tag = "1")]
        pub flag_value: ::core::option::Option<bool>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct SetSceneObjectTintAndDesat {
        #[prost(fixed32, optional, tag = "1")]
        pub tint: ::core::option::Option<u32>,
        #[prost(float, optional, tag = "2")]
        pub desat: ::core::option::Option<f32>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct ParticleSkipToTime {
        #[prost(float, optional, tag = "1")]
        pub skip_to_time: ::core::option::Option<f32>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct ParticleCanFreeze {
        #[prost(bool, optional, tag = "1")]
        pub can_freeze: ::core::option::Option<bool>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct ParticleFreezeTransitionOverride {
        #[prost(float, optional, tag = "1")]
        pub freeze_transition_override: ::core::option::Option<f32>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct FreezeParticleInvolving {
        #[prost(bool, optional, tag = "1")]
        pub set_frozen: ::core::option::Option<bool>,
        #[prost(float, optional, tag = "2")]
        pub transition_duration: ::core::option::Option<f32>,
        #[prost(uint32, optional, tag = "3", default = "16777215")]
        pub entity_handle: ::core::option::Option<u32>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AddModellistOverrideElement {
        #[prost(string, optional, tag = "1")]
        pub model_name: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(float, optional, tag = "2")]
        pub spawn_probability: ::core::option::Option<f32>,
        #[prost(uint32, optional, tag = "3")]
        pub groupid: ::core::option::Option<u32>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct ClearModellistOverride {
        #[prost(uint32, optional, tag = "1")]
        pub groupid: ::core::option::Option<u32>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SetParticleNamedValueContext {
        #[prost(message, repeated, tag = "1")]
        pub float_values:
            ::prost::alloc::vec::Vec<set_particle_named_value_context::FloatContextValue>,
        #[prost(message, repeated, tag = "2")]
        pub vector_values:
            ::prost::alloc::vec::Vec<set_particle_named_value_context::VectorContextValue>,
        #[prost(message, repeated, tag = "3")]
        pub transform_values:
            ::prost::alloc::vec::Vec<set_particle_named_value_context::TransformContextValue>,
        #[prost(message, repeated, tag = "4")]
        pub ehandle_values:
            ::prost::alloc::vec::Vec<set_particle_named_value_context::EHandleContext>,
    }
    /// Nested message and enum types in `SetParticleNamedValueContext`.
    pub mod set_particle_named_value_context {
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct FloatContextValue {
            #[prost(uint32, optional, tag = "1")]
            pub value_name_hash: ::core::option::Option<u32>,
            #[prost(float, optional, tag = "2")]
            pub value: ::core::option::Option<f32>,
        }
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct VectorContextValue {
            #[prost(uint32, optional, tag = "1")]
            pub value_name_hash: ::core::option::Option<u32>,
            #[prost(message, optional, tag = "2")]
            pub value: ::core::option::Option<super::super::CMsgVector>,
        }
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct TransformContextValue {
            #[prost(uint32, optional, tag = "1")]
            pub value_name_hash: ::core::option::Option<u32>,
            #[prost(message, optional, tag = "2")]
            pub angles: ::core::option::Option<super::super::CMsgQAngle>,
            #[prost(message, optional, tag = "3")]
            pub translation: ::core::option::Option<super::super::CMsgVector>,
        }
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct EHandleContext {
            #[prost(uint32, optional, tag = "1")]
            pub value_name_hash: ::core::option::Option<u32>,
            #[prost(uint32, optional, tag = "2", default = "16777215")]
            pub ent_index: ::core::option::Option<u32>,
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CreatePhysicsSim {
        #[prost(string, optional, tag = "1")]
        pub prop_group_name: ::core::option::Option<::prost::alloc::string::String>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct DestroyPhysicsSim {}
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CUserMsgHudError {
    #[prost(int32, optional, tag = "1")]
    pub order_id: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CUserMsgCustomGameEvent {
    #[prost(string, optional, tag = "1")]
    pub event_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bytes = "vec", optional, tag = "2")]
    pub data: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CUserMessageHapticsManagerPulse {
    #[prost(int32, optional, tag = "1")]
    pub hand_id: ::core::option::Option<i32>,
    #[prost(float, optional, tag = "2")]
    pub effect_amplitude: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "3")]
    pub effect_frequency: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "4")]
    pub effect_duration: ::core::option::Option<f32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CUserMessageHapticsManagerEffect {
    #[prost(int32, optional, tag = "1")]
    pub hand_id: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "2")]
    pub effect_name_hash_code: ::core::option::Option<u32>,
    #[prost(float, optional, tag = "3")]
    pub effect_scale: ::core::option::Option<f32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CUserMessageAnimStateGraphState {
    #[prost(int32, optional, tag = "1")]
    pub entity_index: ::core::option::Option<i32>,
    #[prost(bytes = "vec", optional, tag = "2")]
    pub data: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CUserMessageUpdateCssClasses {
    #[prost(int32, optional, tag = "1")]
    pub target_world_panel: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "2")]
    pub css_classes: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "3")]
    pub is_add: ::core::option::Option<bool>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CUserMessageServerFrameTime {
    #[prost(float, optional, tag = "1")]
    pub frame_time: ::core::option::Option<f32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CUserMessageLagCompensationError {
    #[prost(float, optional, tag = "1")]
    pub distance: ::core::option::Option<f32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CUserMessageRequestDllStatus {
    #[prost(string, optional, tag = "1")]
    pub dll_action: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "2")]
    pub full_report: ::core::option::Option<bool>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CUserMessageRequestUtilAction {
    #[prost(int32, optional, tag = "2")]
    pub util1: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub util2: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "4")]
    pub util3: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "5")]
    pub util4: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "6")]
    pub util5: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CUserMessageUtilMsgResponse {
    #[prost(fixed32, optional, tag = "1")]
    pub crc: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "2")]
    pub item_count: ::core::option::Option<i32>,
    #[prost(fixed32, optional, tag = "3")]
    pub crc2: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "4")]
    pub item_count2: ::core::option::Option<i32>,
    #[prost(int32, repeated, packed = "false", tag = "5")]
    pub crc_part: ::prost::alloc::vec::Vec<i32>,
    #[prost(int32, repeated, packed = "false", tag = "6")]
    pub crc_part2: ::prost::alloc::vec::Vec<i32>,
    #[prost(int32, optional, tag = "7")]
    pub client_timestamp: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "8")]
    pub platform: ::core::option::Option<i32>,
    #[prost(message, repeated, tag = "9")]
    pub itemdetails: ::prost::alloc::vec::Vec<c_user_message_util_msg_response::ItemDetail>,
    #[prost(int32, optional, tag = "10")]
    pub itemgroup: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "11")]
    pub total_count: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "12")]
    pub total_count2: ::core::option::Option<i32>,
}
/// Nested message and enum types in `CUserMessage_UtilMsg_Response`.
pub mod c_user_message_util_msg_response {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ItemDetail {
        #[prost(int32, optional, tag = "1")]
        pub index: ::core::option::Option<i32>,
        #[prost(int32, optional, tag = "2")]
        pub hash: ::core::option::Option<i32>,
        #[prost(int32, optional, tag = "3")]
        pub crc: ::core::option::Option<i32>,
        #[prost(string, optional, tag = "4")]
        pub name: ::core::option::Option<::prost::alloc::string::String>,
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CUserMessageDllStatus {
    #[prost(string, optional, tag = "1")]
    pub file_report: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "2")]
    pub command_line: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "3")]
    pub total_files: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub process_id: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "5")]
    pub osversion: ::core::option::Option<i32>,
    #[prost(uint64, optional, tag = "6")]
    pub client_time: ::core::option::Option<u64>,
    #[prost(message, repeated, tag = "7")]
    pub diagnostics: ::prost::alloc::vec::Vec<c_user_message_dll_status::CvDiagnostic>,
    #[prost(message, repeated, tag = "8")]
    pub modules: ::prost::alloc::vec::Vec<c_user_message_dll_status::CModule>,
}
/// Nested message and enum types in `CUserMessage_DllStatus`.
pub mod c_user_message_dll_status {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CvDiagnostic {
        #[prost(uint32, optional, tag = "1")]
        pub id: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "2")]
        pub extended: ::core::option::Option<u32>,
        #[prost(uint64, optional, tag = "3")]
        pub value: ::core::option::Option<u64>,
        #[prost(string, optional, tag = "4")]
        pub string_value: ::core::option::Option<::prost::alloc::string::String>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CModule {
        #[prost(uint64, optional, tag = "1")]
        pub base_addr: ::core::option::Option<u64>,
        #[prost(string, optional, tag = "2")]
        pub name: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(uint32, optional, tag = "3")]
        pub size: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "4")]
        pub timestamp: ::core::option::Option<u32>,
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CUserMessageRequestInventory {
    #[prost(int32, optional, tag = "1")]
    pub inventory: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub offset: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub options: ::core::option::Option<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CUserMessageInventoryResponse {
    #[prost(fixed32, optional, tag = "1")]
    pub crc: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "2")]
    pub item_count: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "5")]
    pub osversion: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "6")]
    pub perf_time: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "7")]
    pub client_timestamp: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "8")]
    pub platform: ::core::option::Option<i32>,
    #[prost(message, repeated, tag = "9")]
    pub inventories: ::prost::alloc::vec::Vec<c_user_message_inventory_response::InventoryDetail>,
    #[prost(message, repeated, tag = "10")]
    pub inventories2: ::prost::alloc::vec::Vec<c_user_message_inventory_response::InventoryDetail>,
    #[prost(message, repeated, tag = "14")]
    pub inventories3: ::prost::alloc::vec::Vec<c_user_message_inventory_response::InventoryDetail>,
    #[prost(int32, optional, tag = "11")]
    pub inv_type: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "12")]
    pub build_version: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "13")]
    pub instance: ::core::option::Option<i32>,
    #[prost(int64, optional, tag = "15")]
    pub start_time: ::core::option::Option<i64>,
}
/// Nested message and enum types in `CUserMessage_Inventory_Response`.
pub mod c_user_message_inventory_response {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct InventoryDetail {
        #[prost(int32, optional, tag = "1")]
        pub index: ::core::option::Option<i32>,
        #[prost(int64, optional, tag = "2")]
        pub primary: ::core::option::Option<i64>,
        #[prost(int64, optional, tag = "3")]
        pub offset: ::core::option::Option<i64>,
        #[prost(int64, optional, tag = "4")]
        pub first: ::core::option::Option<i64>,
        #[prost(int64, optional, tag = "5")]
        pub base: ::core::option::Option<i64>,
        #[prost(string, optional, tag = "6")]
        pub name: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag = "7")]
        pub base_name: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(int32, optional, tag = "8")]
        pub base_detail: ::core::option::Option<i32>,
        #[prost(int32, optional, tag = "9")]
        pub base_time: ::core::option::Option<i32>,
        #[prost(int32, optional, tag = "10")]
        pub base_hash: ::core::option::Option<i32>,
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CUserMessageRequestDiagnostic {
    #[prost(message, repeated, tag = "1")]
    pub diagnostics: ::prost::alloc::vec::Vec<c_user_message_request_diagnostic::Diagnostic>,
}
/// Nested message and enum types in `CUserMessageRequestDiagnostic`.
pub mod c_user_message_request_diagnostic {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Diagnostic {
        #[prost(int32, optional, tag = "1")]
        pub index: ::core::option::Option<i32>,
        #[prost(int64, optional, tag = "2")]
        pub offset: ::core::option::Option<i64>,
        #[prost(int32, optional, tag = "3")]
        pub param: ::core::option::Option<i32>,
        #[prost(int32, optional, tag = "4")]
        pub length: ::core::option::Option<i32>,
        #[prost(int32, optional, tag = "5")]
        pub r#type: ::core::option::Option<i32>,
        #[prost(int64, optional, tag = "6")]
        pub base: ::core::option::Option<i64>,
        #[prost(int64, optional, tag = "7")]
        pub range: ::core::option::Option<i64>,
        #[prost(int64, optional, tag = "8")]
        pub extent: ::core::option::Option<i64>,
        #[prost(int64, optional, tag = "9")]
        pub detail: ::core::option::Option<i64>,
        #[prost(string, optional, tag = "10")]
        pub name: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag = "11")]
        pub alias: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(bytes = "vec", optional, tag = "12")]
        pub vardetail: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(int32, optional, tag = "13")]
        pub context: ::core::option::Option<i32>,
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CUserMessageDiagnosticResponse {
    #[prost(message, repeated, tag = "1")]
    pub diagnostics: ::prost::alloc::vec::Vec<c_user_message_diagnostic_response::Diagnostic>,
    #[prost(int32, optional, tag = "2")]
    pub build_version: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub instance: ::core::option::Option<i32>,
    #[prost(int64, optional, tag = "4")]
    pub start_time: ::core::option::Option<i64>,
    #[prost(int32, optional, tag = "5")]
    pub osversion: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "6")]
    pub platform: ::core::option::Option<i32>,
}
/// Nested message and enum types in `CUserMessage_Diagnostic_Response`.
pub mod c_user_message_diagnostic_response {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Diagnostic {
        #[prost(int32, optional, tag = "1")]
        pub index: ::core::option::Option<i32>,
        #[prost(int64, optional, tag = "2")]
        pub offset: ::core::option::Option<i64>,
        #[prost(int32, optional, tag = "3")]
        pub param: ::core::option::Option<i32>,
        #[prost(int32, optional, tag = "4")]
        pub length: ::core::option::Option<i32>,
        #[prost(bytes = "vec", optional, tag = "5")]
        pub detail: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(int64, optional, tag = "6")]
        pub base: ::core::option::Option<i64>,
        #[prost(int64, optional, tag = "7")]
        pub range: ::core::option::Option<i64>,
        #[prost(int32, optional, tag = "8")]
        pub r#type: ::core::option::Option<i32>,
        #[prost(string, optional, tag = "10")]
        pub name: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag = "11")]
        pub alias: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(bytes = "vec", optional, tag = "12")]
        pub backup: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(int32, optional, tag = "13")]
        pub context: ::core::option::Option<i32>,
        #[prost(int64, optional, tag = "14")]
        pub control: ::core::option::Option<i64>,
        #[prost(int64, optional, tag = "15")]
        pub augment: ::core::option::Option<i64>,
        #[prost(int64, optional, tag = "16")]
        pub placebo: ::core::option::Option<i64>,
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CUserMessageExtraUserData {
    #[prost(int32, optional, tag = "1")]
    pub item: ::core::option::Option<i32>,
    #[prost(int64, optional, tag = "2")]
    pub value1: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "3")]
    pub value2: ::core::option::Option<i64>,
    #[prost(bytes = "vec", repeated, tag = "4")]
    pub detail1: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes = "vec", repeated, tag = "5")]
    pub detail2: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CUserMessageNotifyResponseFound {
    #[prost(int32, optional, tag = "1", default = "-1")]
    pub ent_index: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "2")]
    pub rule_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3")]
    pub response_value: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "4")]
    pub response_concept: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "5")]
    pub criteria: ::prost::alloc::vec::Vec<c_user_message_notify_response_found::Criteria>,
}
/// Nested message and enum types in `CUserMessage_NotifyResponseFound`.
pub mod c_user_message_notify_response_found {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Criteria {
        #[prost(uint32, optional, tag = "1")]
        pub name_symbol: ::core::option::Option<u32>,
        #[prost(string, optional, tag = "2")]
        pub value: ::core::option::Option<::prost::alloc::string::String>,
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CUserMessagePlayResponseConditional {
    #[prost(int32, optional, tag = "1", default = "-1")]
    pub ent_index: ::core::option::Option<i32>,
    #[prost(int32, repeated, packed = "false", tag = "2")]
    pub player_slots: ::prost::alloc::vec::Vec<i32>,
    #[prost(string, optional, tag = "3")]
    pub response: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "4")]
    pub ent_origin: ::core::option::Option<CMsgVector>,
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum EBaseUserMessages {
    UmAchievementEvent = 101,
    UmCloseCaption = 102,
    UmCloseCaptionDirect = 103,
    UmCurrentTimescale = 104,
    UmDesiredTimescale = 105,
    UmFade = 106,
    UmGameTitle = 107,
    UmHudMsg = 110,
    UmHudText = 111,
    UmColoredText = 113,
    UmRequestState = 114,
    UmResetHud = 115,
    UmRumble = 116,
    UmSayText = 117,
    UmSayText2 = 118,
    UmSayTextChannel = 119,
    UmShake = 120,
    UmShakeDir = 121,
    UmWaterShake = 122,
    UmTextMsg = 124,
    UmScreenTilt = 125,
    UmVoiceMask = 128,
    UmSendAudio = 130,
    UmItemPickup = 131,
    UmAmmoDenied = 132,
    UmShowMenu = 134,
    UmCreditsMsg = 135,
    UmCloseCaptionPlaceholder = 142,
    UmCameraTransition = 143,
    UmAudioParameter = 144,
    UmParticleManager = 145,
    UmHudError = 146,
    UmCustomGameEvent = 148,
    UmAnimGraphUpdate = 149,
    UmHapticsManagerPulse = 150,
    UmHapticsManagerEffect = 151,
    UmCommandQueueState = 152,
    UmUpdateCssClasses = 153,
    UmServerFrameTime = 154,
    UmLagCompensationError = 155,
    UmRequestDllStatus = 156,
    UmRequestUtilAction = 157,
    UmUtilActionResponse = 158,
    UmDllStatusResponse = 159,
    UmRequestInventory = 160,
    UmInventoryResponse = 161,
    UmRequestDiagnostic = 162,
    UmDiagnosticResponse = 163,
    UmExtraUserData = 164,
    UmNotifyResponseFound = 165,
    UmPlayResponseConditional = 166,
    UmMaxBase = 200,
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum EBaseEntityMessages {
    EmPlayJingle = 136,
    EmScreenOverlay = 137,
    EmRemoveAllDecals = 138,
    EmPropagateForce = 139,
    EmDoSpark = 140,
    EmFixAngle = 141,
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum ERollType {
    RollNone = -1,
    RollStats = 0,
    RollCredits = 1,
    RollLateJoinLogo = 2,
    RollOuttro = 3,
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum ParticleMessage {
    GameParticleManagerEventCreate = 0,
    GameParticleManagerEventUpdate = 1,
    GameParticleManagerEventUpdateForward = 2,
    GameParticleManagerEventUpdateOrientation = 3,
    GameParticleManagerEventUpdateFallback = 4,
    GameParticleManagerEventUpdateEnt = 5,
    GameParticleManagerEventUpdateOffset = 6,
    GameParticleManagerEventDestroy = 7,
    GameParticleManagerEventDestroyInvolving = 8,
    GameParticleManagerEventRelease = 9,
    GameParticleManagerEventLatency = 10,
    GameParticleManagerEventShouldDraw = 11,
    GameParticleManagerEventFrozen = 12,
    GameParticleManagerEventChangeControlPointAttachment = 13,
    GameParticleManagerEventUpdateEntityPosition = 14,
    GameParticleManagerEventSetFowProperties = 15,
    GameParticleManagerEventSetText = 16,
    GameParticleManagerEventSetShouldCheckFow = 17,
    GameParticleManagerEventSetControlPointModel = 18,
    GameParticleManagerEventSetControlPointSnapshot = 19,
    GameParticleManagerEventSetTextureAttribute = 20,
    GameParticleManagerEventSetSceneObjectGenericFlag = 21,
    GameParticleManagerEventSetSceneObjectTintAndDesat = 22,
    GameParticleManagerEventDestroyNamed = 23,
    GameParticleManagerEventSkipToTime = 24,
    GameParticleManagerEventCanFreeze = 25,
    GameParticleManagerEventSetNamedValueContext = 26,
    GameParticleManagerEventUpdateTransform = 27,
    GameParticleManagerEventFreezeTransitionOverride = 28,
    GameParticleManagerEventFreezeInvolving = 29,
    GameParticleManagerEventAddModellistOverrideElement = 30,
    GameParticleManagerEventClearModellistOverride = 31,
    GameParticleManagerEventCreatePhysicsSim = 32,
    GameParticleManagerEventDestroyPhysicsSim = 33,
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum EHapticPulseType {
    VrHandHapticPulseLight = 0,
    VrHandHapticPulseMedium = 1,
    VrHandHapticPulseStrong = 2,
}
